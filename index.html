<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Color-by-Number Demo</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "Inter", "Segoe UI", -apple-system, BlinkMacSystemFont, system-ui,
          sans-serif;
        background-color: #030712;
        color: #e2e8f0;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, rgba(56, 189, 248, 0.08), transparent),
          #030712;
        color: inherit;
      }

      #root {
        min-height: 100vh;
      }

      button {
        font: inherit;
      }

      svg {
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <div id="root" role="application" aria-label="Color-by-number painting app"></div>

    <script src="./vendor/react.development.js"></script>
    <script src="./vendor/react-dom.development.js"></script>
    <script src="./vendor/babel.min.js"></script>
    <script type="text/babel">
const { useCallback, useEffect, useMemo, useRef, useState } = React;

// Capybooper Web Game - MVP single-file React app (patched)
// Fixes: correct zoom/pan math, pan over filled cells, pinch zoom, drag-fill,
// eyedropper, auto-advance, hint stroke highlight, smoke-test HUD.
// No external libs. LocalStorage autosave. Keyboard support.

// ---------- Types ----------
/** @typedef {number} ColorId */

/**
 * @typedef PaletteItem
 * @property {ColorId} id
 * @property {string=} name
 * @property {string} rgba
 */

/**
 * @typedef Cell
 * @property {string} id
 * @property {ColorId} colorId
 * @property {string} d
 * @property {number=} area
 */

/**
 * @typedef Artwork
 * @property {string} id
 * @property {string} title
 * @property {number} width
 * @property {number} height
 * @property {PaletteItem[]} palette
 * @property {Cell[]} cells
 */

/**
 * @typedef SaveState
 * @property {string} artworkId
 * @property {Record<string, boolean>} filled
 * @property {ColorId=} activeColor
 * @property {{ scale: number; x: number; y: number }=} viewport
 * @property {number} lastSaved
 */

// ---------- Sample Artwork ----------
const DEMO_ART = {
  id: "demo-capybara-forest",
  title: "Capybara Forest Retreat",
  width: 960,
  height: 600,
  palette: [
    { id: 1, name: "Sky Mist", rgba: "#86c5ff" },
    { id: 2, name: "Sky Veil", rgba: "#e6f0ff" },
    { id: 3, name: "Dawn Glow", rgba: "#fef6e4" },
    { id: 4, name: "Distant Hills", rgba: "#b7d1a7" },
    { id: 5, name: "Pine Canopy", rgba: "#2f7a33" },
    { id: 6, name: "Pine Shadow", rgba: "#255f27" },
    { id: 7, name: "Pond Light", rgba: "#7fd5ef" },
    { id: 8, name: "Meadow Moss", rgba: "#3b7b46" },
    { id: 9, name: "Capybara Fur", rgba: "#8e5b3a" },
    { id: 10, name: "Capybara Shade", rgba: "#5a3d2a" },
    { id: 11, name: "Forest Accent", rgba: "#2c6e49" },
  ],
  cells: [
    { id: "c1", colorId: 1, d: "M0 0 L960 0 L960 140 C 860 150 760 150 660 140 C 560 130 480 130 400 140 C 280 155 160 150 0 130 Z" },
    { id: "c2", colorId: 3, d: "M0 130 C 160 150 320 160 480 160 L480 210 C 320 205 160 200 0 190 Z" },
    { id: "c3", colorId: 2, d: "M480 160 C 640 170 800 160 960 140 L960 210 C 800 215 640 215 480 210 Z" },
    { id: "c4", colorId: 4, d: "M0 190 C 120 210 240 220 360 220 C 400 220 420 218 420 218 L420 260 L0 260 Z" },
    { id: "c5", colorId: 4, d: "M420 218 C 560 210 700 210 840 205 C 900 202 940 200 960 205 L960 260 L420 260 Z" },
    { id: "c6", colorId: 5, d: "M0 260 C 100 300 220 320 300 330 C 220 340 140 350 40 340 C 20 330 0 300 0 260 Z" },
    { id: "c7", colorId: 6, d: "M300 330 C 380 300 500 290 620 300 C 680 310 740 330 780 360 L780 360 L300 360 Z" },
    { id: "c8", colorId: 5, d: "M780 360 C 820 320 880 300 960 290 L960 360 L780 360 Z" },
    { id: "c9", colorId: 6, d: "M0 360 C 120 380 240 390 360 390 C 480 390 600 370 720 360 C 820 350 900 350 960 360 L960 420 C 860 430 760 430 660 420 C 560 410 460 410 360 420 C 240 430 120 420 0 400 Z" },
    { id: "c10", colorId: 2, d: "M0 420 C 160 440 320 450 480 445 C 640 440 800 430 960 420 L960 460 C 800 480 640 490 480 485 C 320 480 160 470 0 450 Z" },
    { id: "c11", colorId: 7, d: "M0 460 C 160 480 320 495 480 490 C 640 485 800 470 960 460 L960 500 L0 500 Z" },
    { id: "c12", colorId: 8, d: "M0 500 L170 508 L170 560 L0 560 Z" },
    { id: "c13", colorId: 8, d: "M240 508 L320 515 L320 560 L240 560 Z" },
    { id: "c14", colorId: 8, d: "M320 515 L360 518 L360 560 L320 560 Z" },
    { id: "c15", colorId: 8, d: "M680 515 L720 518 L720 560 L680 560 Z" },
    { id: "c16", colorId: 3, d: "M168 500 L240 504 L240 540 C 224 548 204 552 176 554 L168 554 Z" },
    { id: "c17", colorId: 11, d: "M160 540 C 188 518 216 518 240 540 L240 560 L160 560 Z" },
    { id: "c18", colorId: 9, d: "M360 540 L360 508 C 380 472 430 450 500 444 C 580 438 650 456 680 496 L680 540 Z" },
    { id: "c19", colorId: 10, d: "M360 540 L680 540 L680 560 C 620 576 540 582 460 576 C 400 572 372 562 360 552 Z" },
    { id: "c20", colorId: 8, d: "M720 518 L736 516 L736 560 L720 560 Z" },
    { id: "c21", colorId: 3, d: "M736 500 L792 504 L792 540 C 780 546 766 550 744 552 L736 552 Z" },
    { id: "c22", colorId: 11, d: "M724 540 C 752 520 788 520 820 540 L820 560 L724 560 Z" },
    { id: "c23", colorId: 8, d: "M792 504 L820 502 L820 540 L792 540 Z" },
    { id: "c24", colorId: 8, d: "M820 502 L880 500 L880 560 L820 560 Z" },
    { id: "c25", colorId: 8, d: "M880 500 L960 500 L960 560 L880 560 Z" },
    { id: "c26", colorId: 8, d: "M0 560 C 200 580 400 590 600 585 C 760 580 880 570 960 575 L960 600 L0 600 Z" },
  ].map((c) => ({ ...c, area: estimatePathArea(c.d) })),
};
function cloneArtwork(art) {
  return {
    ...art,
    palette: (art.palette ?? []).map((p) => ({ ...p })),
    cells: (art.cells ?? []).map((c) => ({ ...c })),
  };
}

function getStarterArtworks() {
  return [cloneArtwork(DEMO_ART)];
}

// Rough polygon area estimator for simple paths.
function estimatePathArea(d) {
  try {
    const tokens = d.split(/[ ,]/).filter(Boolean);
    const pts = [];
    for (let i = 0; i < tokens.length; i++) {
      const t = tokens[i];
      if (t === "M" || t === "L" || t === "Z") continue;
      const n = Number(t);
      if (!Number.isNaN(n)) pts.push(n);
    }
    const xy = [];
    for (let i = 0; i + 1 < pts.length; i += 2) xy.push([pts[i], pts[i + 1]]);
    let area = 0;
    for (let i = 0; i < xy.length; i++) {
      const [x1, y1] = xy[i];
      const [x2, y2] = xy[(i + 1) % xy.length];
      area += x1 * y2 - x2 * y1;
    }
    return Math.abs(area / 2);
  } catch (err) {
    return 1000;
  }
}

// ---------- Utilities ----------
const SAVE_KEY = (artId) => `capybooper_save_${artId}`;
const ARTWORKS_KEY = "capybooper_artworks_v1";
const ACTIVE_ART_KEY = "capybooper_active_art";

function normalizeArtwork(raw) {
  if (!raw) return null;
  try {
    const width = Number(raw.width);
    const height = Number(raw.height);
    if (!Number.isFinite(width) || width <= 0) return null;
    if (!Number.isFinite(height) || height <= 0) return null;
    const palette = Array.isArray(raw.palette)
      ? raw.palette
          .map((item) => ({
            id: item.id,
            name: item.name ?? undefined,
            rgba: item.rgba,
          }))
          .filter((item) => item.id !== undefined && typeof item.rgba === "string")
      : [];
    const cells = Array.isArray(raw.cells)
      ? raw.cells
          .map((cell) => ({
            id: cell.id,
            colorId: cell.colorId,
            d: cell.d,
            area: cell.area ?? estimatePathArea(cell.d ?? ""),
          }))
          .filter(
            (cell) =>
              typeof cell.id === "string" &&
              cell.id.length > 0 &&
              typeof cell.d === "string" &&
              cell.d.length > 0 &&
              cell.colorId !== undefined
          )
      : [];
    const title = (raw.title ?? "").trim();
    let id = (raw.id ?? "").toString().trim();
    if (!title || !palette.length || !cells.length) return null;
    if (!id) {
      const slug = title
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "");
      id = slug || `art-${Math.random().toString(36).slice(2, 8)}`;
    }
    return {
      id,
      title,
      width,
      height,
      palette,
      cells,
    };
  } catch (err) {
    return null;
  }
}

function loadArtworks() {
  try {
    const raw = localStorage.getItem(ARTWORKS_KEY);
    if (!raw) return getStarterArtworks();
    const parsed = JSON.parse(raw);
    const normalized = (Array.isArray(parsed) ? parsed : [])
      .map((art) => normalizeArtwork(art))
      .filter(Boolean);
    return normalized.length ? normalized : getStarterArtworks();
  } catch (err) {
    return getStarterArtworks();
  }
}

function persistArtworks(list) {
  try {
    localStorage.setItem(ARTWORKS_KEY, JSON.stringify(list));
  } catch (err) {}
}

function loadActiveArtworkId(artworks) {
  try {
    const stored = localStorage.getItem(ACTIVE_ART_KEY);
    if (!stored) return artworks?.[0]?.id ?? null;
    return artworks?.some((art) => art.id === stored) ? stored : artworks?.[0]?.id ?? null;
  } catch (err) {
    return artworks?.[0]?.id ?? null;
  }
}

function persistActiveArtworkId(id) {
  try {
    if (id) {
      localStorage.setItem(ACTIVE_ART_KEY, id);
    } else {
      localStorage.removeItem(ACTIVE_ART_KEY);
    }
  } catch (err) {}
}

const DEFAULT_CONFIG = {
  enableAutosave: true,
  autoAdvanceOnComplete: true,
  enableHintPulse: true,
  enableDragFill: true,
  enableEyedropper: true,
  enableKeyboardShortcuts: true,
  showNumberBadges: true,
  showHeatmapDots: true,
  enableSmokeHud: true,
};

const CONFIG_KEY = "capybooper_config";

function loadConfig() {
  try {
    const raw = localStorage.getItem(CONFIG_KEY);
    if (!raw) return DEFAULT_CONFIG;
    const parsed = JSON.parse(raw);
    return { ...DEFAULT_CONFIG, ...parsed };
  } catch (err) {
    return DEFAULT_CONFIG;
  }
}

function persistConfig(next) {
  try {
    localStorage.setItem(CONFIG_KEY, JSON.stringify(next));
  } catch (err) {}
}

function shallowEqual(a, b) {
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) return false;
  for (const key of keysA) if (a[key] !== b[key]) return false;
  return true;
}

function loadSave(art) {
  if (!art) return undefined;
  try {
    const raw = localStorage.getItem(SAVE_KEY(art.id));
    if (!raw) return undefined;
    const s = JSON.parse(raw);
    if (s.artworkId !== art.id) return undefined;
    return s;
  } catch (err) {
    return undefined;
  }
}

function persistSave(art, s) {
  if (!art) return;
  try {
    localStorage.setItem(SAVE_KEY(art.id), JSON.stringify(s));
  } catch (err) {}
}

function clearSave(artId) {
  try {
    localStorage.removeItem(SAVE_KEY(artId));
  } catch (err) {}
}

function computeRemaining(art, filled) {
  if (!art) return {};
  const map = {};
  for (const p of art.palette) map[p.id] = 0;
  for (const c of art.cells) if (!filled[c.id]) map[c.colorId] = (map[c.colorId] ?? 0) + 1;
  return map;
}

// ---------- App ----------
function App() {
  const initialConfig = useMemo(() => loadConfig(), []);
  const initialArtworksRef = useRef(null);

  if (initialArtworksRef.current === null) {
    initialArtworksRef.current = loadArtworks();
  }

  const [artworks, setArtworks] = useState(initialArtworksRef.current);
  const [activeArtworkId, setActiveArtworkIdState] = useState(() =>
    loadActiveArtworkId(initialArtworksRef.current)
  );
  const [config, setConfig] = useState(initialConfig);
  const isDefaultConfig = useMemo(() => shallowEqual(config, DEFAULT_CONFIG), [config]);

  const art = useMemo(() => {
    const match = artworks.find((entry) => entry.id === activeArtworkId);
    return match ?? artworks[0] ?? null;
  }, [artworks, activeArtworkId]);

  const [filled, setFilled] = useState({});
  const [activeColor, setActiveColor] = useState(art?.palette?.[0]?.id ?? null);
  const [scale, setScale] = useState(0.9);
  const [offset, setOffset] = useState({ x: 50, y: 50 });
  const [lastAction, setLastAction] = useState(null);
  const [hintPulse, setHintPulse] = useState(new Set());
  const [showTests, setShowTests] = useState(initialConfig.enableSmokeHud);
  const [showOptions, setShowOptions] = useState(false);
  const [showLibrary, setShowLibrary] = useState(false);
  const [libraryRevision, setLibraryRevision] = useState(0);

  const selectArtwork = useCallback((id) => {
    setActiveArtworkIdState(id);
    persistActiveArtworkId(id ?? null);
  }, []);

  useEffect(() => {
    persistArtworks(artworks);
  }, [artworks]);

  useEffect(() => {
    if (!artworks.length) {
      selectArtwork(null);
      return;
    }
    if (!artworks.some((entry) => entry.id === activeArtworkId)) {
      selectArtwork(artworks[0].id);
    }
  }, [artworks, activeArtworkId, selectArtwork]);

  useEffect(() => {
    if (!art) {
      setFilled({});
      setActiveColor(null);
      setScale(0.9);
      setOffset({ x: 50, y: 50 });
      setLastAction(null);
      setHintPulse(new Set());
      return;
    }
    const saved = loadSave(art);
    setFilled(saved?.filled ?? {});
    setActiveColor(saved?.activeColor ?? art.palette?.[0]?.id ?? null);
    setScale(saved?.viewport?.scale ?? 0.9);
    setOffset({
      x: saved?.viewport?.x ?? 50,
      y: saved?.viewport?.y ?? 50,
    });
    setLastAction(null);
    setHintPulse(new Set());
  }, [art?.id]);

  const {
    enableAutosave,
    autoAdvanceOnComplete,
    enableHintPulse,
    enableDragFill,
    enableEyedropper,
    enableKeyboardShortcuts,
    showNumberBadges,
    showHeatmapDots,
    enableSmokeHud,
  } = config;

  useEffect(() => {
    if (!enableAutosave || !art) return;
    const t = setTimeout(() => {
      persistSave(art, {
        artworkId: art.id,
        filled,
        activeColor,
        viewport: { scale, x: offset.x, y: offset.y },
        lastSaved: Date.now(),
      });
    }, 800);
    return () => clearTimeout(t);
  }, [art, filled, activeColor, scale, offset, enableAutosave]);

  const remaining = useMemo(() => computeRemaining(art, filled), [art, filled]);
  const totalCells = art?.cells?.length ?? 0;
  const filledCount = Object.values(filled).filter(Boolean).length;
  const progress = totalCells > 0 ? Math.round((filledCount / totalCells) * 100) : 0;

  const libraryProgress = useMemo(() => {
    const map = {};
    artworks.forEach((entry) => {
      if (!entry) return;
      if (art && entry.id === art.id) {
        map[entry.id] = progress;
        return;
      }
      const total = entry.cells?.length ?? 0;
      const saved = loadSave(entry);
      if (!saved) {
        map[entry.id] = 0;
        return;
      }
      const count = Object.values(saved.filled ?? {}).filter(Boolean).length;
      map[entry.id] = total > 0 ? Math.round((count / total) * 100) : 0;
    });
    return map;
  }, [artworks, art?.id, progress, libraryRevision]);

  const handleImportArtwork = useCallback(
    (json) => {
      if (!json || !json.trim()) {
        return { ok: false, error: "Paste artwork JSON first." };
      }
      try {
        const parsed = JSON.parse(json);
        const normalized = normalizeArtwork(parsed);
        if (!normalized) {
          return {
            ok: false,
            error:
              "The JSON is missing required fields (id, title, width, height, palette, cells).",
          };
        }
        const existingIds = new Set(artworks.map((item) => item.id));
        const baseId = normalized.id || `art-${Math.random().toString(36).slice(2, 8)}`;
        let uniqueId = baseId;
        let suffix = 2;
        while (existingIds.has(uniqueId)) {
          uniqueId = `${baseId}-${suffix++}`;
        }
        const finalArtwork = { ...normalized, id: uniqueId };
        setArtworks((prev) => [...prev, finalArtwork]);
        selectArtwork(finalArtwork.id);
        setLibraryRevision((v) => v + 1);
        return { ok: true, artwork: finalArtwork };
      } catch (err) {
        return {
          ok: false,
          error: err instanceof Error ? err.message : "Unable to parse the JSON payload.",
        };
      }
    },
    [artworks, selectArtwork]
  );

  const handleDeleteArtwork = useCallback(
    (id) => {
      setArtworks((prev) => {
        const next = prev.filter((entry) => entry.id !== id);
        if (!next.length) {
          selectArtwork(null);
          return [];
        }
        if (!next.some((entry) => entry.id === activeArtworkId)) {
          selectArtwork(next[0].id);
        }
        return next;
      });
      clearSave(id);
      setLibraryRevision((v) => v + 1);
      if (art && art.id === id) {
        setFilled({});
        setActiveColor(null);
        setScale(0.9);
        setOffset({ x: 50, y: 50 });
        setLastAction(null);
        setHintPulse(new Set());
        setShowLibrary(true);
      }
    },
    [art, activeArtworkId, selectArtwork, setShowLibrary]
  );

  const handleRenameArtwork = useCallback((id, nextTitle) => {
    const title = (nextTitle ?? "").trim() || "Untitled artwork";
    setArtworks((prev) => prev.map((entry) => (entry.id === id ? { ...entry, title } : entry)));
  }, []);

  const handleClearProgress = useCallback(
    (id) => {
      clearSave(id);
      setLibraryRevision((v) => v + 1);
      if (art && art.id === id) {
        setFilled({});
        setActiveColor(art.palette?.[0]?.id ?? null);
        setScale(0.9);
        setOffset({ x: 50, y: 50 });
        setLastAction(null);
        setHintPulse(new Set());
      }
    },
    [art]
  );

  const previousSmokePreferenceRef = useRef(initialConfig.enableSmokeHud);

  useEffect(() => {
    if (!enableSmokeHud) {
      previousSmokePreferenceRef.current = showTests;
      setShowTests(false);
    } else {
      setShowTests((prev) => prev || previousSmokePreferenceRef.current);
    }
  }, [enableSmokeHud, showTests]);

  useEffect(() => {
    if (!showOptions) return;
    function onKeyDown(e) {
      if (e.key === "Escape") setShowOptions(false);
    }
    window.addEventListener("keydown", onKeyDown);
    return () => window.removeEventListener("keydown", onKeyDown);
  }, [showOptions]);

  const svgRef = useRef(null);
  const isPanningRef = useRef(false);
  const isPaintingRef = useRef(false);
  const lastPosRef = useRef(null);
  const movedRef = useRef(0);
  const eyedropCandidateRef = useRef(null);
  const pointersRef = useRef(new Map());
  const pinchRef = useRef(null);

  function cssToArt(svg, clientX, clientY) {
    if (!art) return { pxArt: 0, pyArt: 0 };
    const rect = svg.getBoundingClientRect();
    const sx = art.width / rect.width;
    const sy = art.height / rect.height;
    const pxArt = (clientX - rect.left) * sx;
    const pyArt = (clientY - rect.top) * sy;
    return { pxArt, pyArt };
  }

  function onWheel(e) {
    if (!art) return;
    e.preventDefault();
    const factor = Math.exp(-e.deltaY * 0.0015);
    const newScale = clamp(scale * factor, 0.3, 4);

    const svg = svgRef.current;
    if (svg) {
      const { pxArt, pyArt } = cssToArt(svg, e.clientX, e.clientY);
      const artX = (pxArt - offset.x) / scale;
      const artY = (pyArt - offset.y) / scale;
      setOffset({ x: pxArt - artX * newScale, y: pyArt - artY * newScale });
    }
    setScale(newScale);
  }

  function onPointerDown(e) {
    if (!art) return;
    const svg = svgRef.current;
    svg?.setPointerCapture?.(e.pointerId);
    pointersRef.current.set(e.pointerId, { x: e.clientX, y: e.clientY });

    const target = e.target;
    const cid = target?.dataset?.cellId;
    movedRef.current = 0;

    if (pointersRef.current.size === 2 && !pinchRef.current) {
      const ids = Array.from(pointersRef.current.keys());
      const p1 = pointersRef.current.get(ids[0]);
      const p2 = pointersRef.current.get(ids[1]);
      const d0 = Math.hypot(p2.x - p1.x, p2.y - p1.y);
      const mid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      pinchRef.current = { id1: ids[0], id2: ids[1], d0, s0: scale, mid0: mid };
      isPanningRef.current = false;
      isPaintingRef.current = false;
      eyedropCandidateRef.current = null;
      return;
    }

    if (cid) {
      const already = !!filled[cid];
      if (already) {
        eyedropCandidateRef.current = enableEyedropper ? cid : null;
        isPanningRef.current = true;
        lastPosRef.current = { x: e.clientX, y: e.clientY };
        return;
      }
      isPaintingRef.current = true;
      onCellTap(cid);
      return;
    }
    isPanningRef.current = true;
    lastPosRef.current = { x: e.clientX, y: e.clientY };
  }

  function onPointerMove(e) {
    if (!art) return;
    const svg = svgRef.current;
    pointersRef.current.set(e.pointerId, { x: e.clientX, y: e.clientY });

    if (pinchRef.current) {
      const { id1, id2, d0, s0, mid0 } = pinchRef.current;
      const p1 = pointersRef.current.get(id1);
      const p2 = pointersRef.current.get(id2);
      if (p1 && p2) {
        const d = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        const factor = d0 > 0 ? d / d0 : 1;
        const newScale = clamp(s0 * factor, 0.3, 4);
        const { pxArt, pyArt } = cssToArt(svg, mid0.x, mid0.y);
        const artX = (pxArt - offset.x) / scale;
        const artY = (pyArt - offset.y) / scale;
        setOffset({ x: pxArt - artX * newScale, y: pyArt - artY * newScale });
        setScale(newScale);
      }
      return;
    }

    if (isPaintingRef.current) {
      if (!enableDragFill) return;
      const target = e.target;
      const id = target?.dataset?.cellId;
      if (id) onCellTap(id);
      return;
    }

    if (isPanningRef.current && lastPosRef.current) {
      const rect = svg.getBoundingClientRect();
      const sx = art.width / rect.width;
      const sy = art.height / rect.height;
      const dxPx = e.clientX - lastPosRef.current.x;
      const dyPx = e.clientY - lastPosRef.current.y;
      movedRef.current += Math.hypot(dxPx, dyPx);
      lastPosRef.current = { x: e.clientX, y: e.clientY };
      setOffset((o) => ({ x: o.x + dxPx * sx, y: o.y + dyPx * sy }));
    }
  }

  function onPointerUp(e) {
    if (!art) return;
    const svg = svgRef.current;
    svg?.releasePointerCapture?.(e.pointerId);

    if (enableEyedropper && eyedropCandidateRef.current && movedRef.current < 6) {
      const cell = art.cells.find((c) => c.id === eyedropCandidateRef.current);
      if (cell && (remaining[cell.colorId] ?? 0) > 0) setActiveColor(cell.colorId);
    }

    pointersRef.current.delete(e.pointerId);
    if (pinchRef.current && (e.pointerId === pinchRef.current.id1 || e.pointerId === pinchRef.current.id2)) {
      pinchRef.current = null;
    }

    isPanningRef.current = false;
    isPaintingRef.current = false;
    lastPosRef.current = null;
    eyedropCandidateRef.current = null;
    movedRef.current = 0;
  }

  function onCellTap(cellId) {
    if (!art || activeColor == null) return;
    const cell = art.cells.find((c) => c.id === cellId);
    if (!cell) return;

    if (filled[cellId]) return;

    if (cell.colorId !== activeColor) {
      const el = document.getElementById(cellId);
      if (el) {
        el.setAttribute("stroke", "#d22");
        el.setAttribute("stroke-width", "4");
        setTimeout(() => {
          el.setAttribute("stroke", "#444");
          el.setAttribute("stroke-width", "2");
        }, 220);
      }
      return;
    }

    const willCompleteColor = (remaining[activeColor] ?? 0) === 1;
    setFilled((prev) => ({ ...prev, [cellId]: true }));
    setLastAction(cellId);
    if (willCompleteColor && autoAdvanceOnComplete) nextColor();
  }

  function undo() {
    if (!lastAction) return;
    setFilled((prev) => ({ ...prev, [lastAction]: false }));
    setLastAction(null);
  }

  function hint() {
    if (!enableHintPulse || !art || activeColor == null) return;
    const candidates = art.cells
      .filter((c) => c.colorId === activeColor && !filled[c.id])
      .sort((a, b) => (a.area ?? 0) - (b.area ?? 0))
      .slice(0, 3);
    const ids = new Set(candidates.map((c) => c.id));
    setHintPulse(ids);
    setTimeout(() => setHintPulse(new Set()), 1000);
  }

  function resetView() {
    setScale(0.9);
    setOffset({ x: 50, y: 50 });
  }

  function nextColor() {
    if (!art || activeColor == null) return;
    const order = art.palette.map((p) => p.id);
    const startIdx = order.indexOf(activeColor);
    for (let i = 1; i <= order.length; i++) {
      const id = order[(startIdx + i) % order.length];
      if ((remaining[id] ?? 0) > 0) {
        setActiveColor(id);
        return;
      }
    }
  }

  function handleConfigChange(key, value) {
    setConfig((prev) => {
      if (prev[key] === value) return prev;
      const next = { ...prev, [key]: value };
      persistConfig(next);
      return next;
    });
  }

  function handleConfigReset() {
    setConfig((prev) => {
      if (shallowEqual(prev, DEFAULT_CONFIG)) return prev;
      persistConfig(DEFAULT_CONFIG);
      return DEFAULT_CONFIG;
    });
    previousSmokePreferenceRef.current = DEFAULT_CONFIG.enableSmokeHud;
    setShowTests(DEFAULT_CONFIG.enableSmokeHud);
  }

  useEffect(() => {
    if (!enableKeyboardShortcuts) return;
    function onKey(e) {
      const lower = e.key.toLowerCase();
      if (e.key === "0") resetView();
      if (e.key === "+" || e.key === "=") setScale((s) => clamp(s * 1.1, 0.3, 4));
      if (e.key === "-" || e.key === "_") setScale((s) => clamp(s / 1.1, 0.3, 4));
      if (lower === "h") hint();
      if (lower === "n") nextColor();
      if (lower === "u") undo();
      if (lower === "t" && enableSmokeHud) setShowTests((v) => !v);
      if (e.key === "Escape") {
        if (showOptions) setShowOptions(false);
        if (showLibrary) setShowLibrary(false);
      }
      if (!art) return;
      const panStep = 80 / (scale || 1);
      if (lower === "w" || e.key === "ArrowUp") {
        e.preventDefault();
        setOffset((prev) => ({ ...prev, y: prev.y + panStep }));
      }
      if (lower === "s" || e.key === "ArrowDown") {
        e.preventDefault();
        setOffset((prev) => ({ ...prev, y: prev.y - panStep }));
      }
      if (lower === "a" || e.key === "ArrowLeft") {
        e.preventDefault();
        setOffset((prev) => ({ ...prev, x: prev.x + panStep }));
      }
      if (lower === "d" || e.key === "ArrowRight") {
        e.preventDefault();
        setOffset((prev) => ({ ...prev, x: prev.x - panStep }));
      }
    }
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [art, enableKeyboardShortcuts, enableSmokeHud, showOptions, showLibrary, scale]);
  return (
    React.createElement(
      "div",
      { style: styles.app },
      showLibrary &&
        React.createElement(ArtLibrary, {
          artworks: artworks,
          activeArtworkId: activeArtworkId,
          progressMap: libraryProgress,
          onSelect: (id) => {
            selectArtwork(id);
            setShowLibrary(false);
          },
          onClose: () => setShowLibrary(false),
          onImport: handleImportArtwork,
          onDelete: handleDeleteArtwork,
          onRename: handleRenameArtwork,
          onClearProgress: handleClearProgress,
        }),
      showOptions &&
        React.createElement(OptionsPanel, {
          config: config,
          onToggle: handleConfigChange,
          canReset: !isDefaultConfig,
          onReset: handleConfigReset,
          onClose: () => setShowOptions(false),
        }),
      art
        ? React.createElement(
            "div",
            { style: styles.canvas },
            React.createElement(
              "svg",
              {
                ref: svgRef,
                width: "100%",
                height: "100%",
                viewBox: `0 0 ${art.width} ${art.height}`,
                style: { background: "#0f172a", touchAction: "none" },
                onWheel: onWheel,
                onPointerDown: onPointerDown,
                onPointerMove: onPointerMove,
                onPointerUp: onPointerUp,
              },
              React.createElement(
                "g",
                { transform: `translate(${offset.x} ${offset.y}) scale(${scale})` },
                React.createElement("rect", {
                  x: 0,
                  y: 0,
                  width: art.width,
                  height: art.height,
                  fill: "#0f172a",
                  stroke: "#1e293b",
                }),
                art.cells.map((c) => {
                  const isFilled = !!filled[c.id];
                  const pal = art.palette.find((p) => p.id === c.colorId);
                  const showPulse = hintPulse.has(c.id);
                  return React.createElement(
                    "g",
                    { key: c.id },
                    isFilled &&
                      React.createElement("path", {
                        d: c.d,
                        fill: pal?.rgba,
                        pointerEvents: "none",
                      }),
                    React.createElement("path", {
                      id: c.id,
                      "data-cell-id": c.id,
                      "data-color-id": c.colorId,
                      d: c.d,
                      fill: isFilled ? "transparent" : "#0f172a",
                      stroke: showPulse ? "#f2c200" : "#334155",
                      strokeWidth: showPulse ? 4 : 2,
                      style: {
                        cursor: isFilled ? "grab" : "pointer",
                        opacity: isFilled ? 0.35 : 1,
                      },
                      "aria-label": `Cell ${c.id}. Target color ${c.colorId}. ${isFilled ? "Filled" : "Unfilled"}`,
                    }),
                    !isFilled && showNumberBadges && scale >= 0.6 &&
                      React.createElement(NumberLabel, { d: c.d, text: `${c.colorId}` }),
                    !isFilled && showHeatmapDots && scale < 0.6 &&
                      React.createElement(HeatDot, { d: c.d })
                  );
                })
              )
            )
          )
        : React.createElement(
            "div",
            { style: styles.emptyState },
            "Import or add an artwork in the library to start painting."
          ),
      art &&
        enableSmokeHud &&
        showTests &&
        React.createElement(SmokeTests, { art: art, filled: filled }),
      art &&
        React.createElement(
          "header",
          { style: styles.topBar, role: "banner" },
          React.createElement(
            "div",
            { style: styles.topContext },
            React.createElement("span", { style: styles.topTitle }, art.title),
            React.createElement(
              "span",
              {
                style: styles.topProgress,
                "data-testid": "progress-indicator",
                title: `${progress}% complete`,
                "aria-label": `${progress}% complete`,
                "aria-live": "polite",
                "aria-atomic": "true",
              },
              `${progress}%`
            )
          ),
          React.createElement(
            "nav",
            { style: styles.topActions, "aria-label": "Canvas controls" },
            React.createElement(
              "button",
              {
                type: "button",
                style: styles.controlButton,
                onClick: () => setShowLibrary(true),
                title: "Open art library",
                "aria-label": "Open art library",
              },
              "Library"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: styles.controlButton,
                onClick: () => setShowOptions(true),
                title: "Adjust options",
                "aria-label": "Adjust options",
                "aria-haspopup": "dialog",
                "aria-expanded": showOptions,
              },
              "Options"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: styles.controlButton,
                onClick: resetView,
                title: "Reset view",
                "aria-label": "Reset view",
              },
              "Reset"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: styles.controlButton,
                onClick: undo,
                title: "Undo last fill",
                "aria-label": "Undo last fill",
              },
              "Undo"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: {
                  ...styles.controlButton,
                  opacity: enableHintPulse ? 1 : 0.45,
                  cursor: enableHintPulse ? "pointer" : "not-allowed",
                },
                onClick: hint,
                title: "Highlight a suggested cell",
                disabled: !enableHintPulse,
                "aria-label": "Highlight a suggested cell",
              },
              "Hint"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: styles.controlButton,
                onClick: nextColor,
                title: "Jump to the next color",
                "aria-label": "Jump to the next color",
              },
              "Next"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: {
                  ...styles.controlButton,
                  opacity: enableSmokeHud ? 1 : 0.45,
                  cursor: enableSmokeHud ? "pointer" : "not-allowed",
                },
                onClick: () => enableSmokeHud && setShowTests((v) => !v),
                title: "Toggle the smoke test HUD",
                disabled: !enableSmokeHud,
                "aria-pressed": showTests,
                "aria-label": "Toggle the smoke test HUD",
              },
              "Tests"
            )
          )
        ),
      art &&
        React.createElement(
          "div",
          { style: styles.paletteDock, "data-testid": "palette-dock" },
          React.createElement(Palette, {
            palette: art.palette,
            remaining: remaining,
            activeColor: activeColor,
            onSelect: setActiveColor,
          })
        )
    )
  );
}

// ---------- Helpers: Number label & heat dot ----------
function centroidFromPath(d) {
  const tokens = d.split(/[ ,]/).filter(Boolean);
  const pts = [];
  for (let i = 0; i < tokens.length; i++) {
    const t = tokens[i];
    if (t === "M" || t === "L" || t === "Z") continue;
    const n = Number(t);
    if (!Number.isNaN(n)) pts.push(n);
  }
  const xy = [];
  for (let i = 0; i + 1 < pts.length; i += 2) xy.push([pts[i], pts[i + 1]]);
  let cx = 0,
    cy = 0,
    a = 0;
  for (let i = 0; i < xy.length; i++) {
    const [x1, y1] = xy[i];
    const [x2, y2] = xy[(i + 1) % xy.length];
    const cross = x1 * y2 - x2 * y1;
    a += cross;
    cx += (x1 + x2) * cross;
    cy += (y1 + y2) * cross;
  }
  a *= 0.5;
  if (Math.abs(a) < 1e-5) return { x: xy[0]?.[0] ?? 0, y: xy[0]?.[1] ?? 0 };
  return { x: cx / (6 * a), y: cy / (6 * a) };
}

function NumberLabel({ d, text }) {
  const { x, y } = centroidFromPath(d);
  return React.createElement(
    "g",
    { pointerEvents: "none" },
    React.createElement("circle", { cx: x, cy: y, r: 16, fill: "rgba(15, 23, 42, 0.9)" }),
    React.createElement(
      "text",
      {
        x,
        y: y + 5,
        fontSize: 24,
        textAnchor: "middle",
        fill: "#e2e8f0",
        fontFamily: "ui-sans-serif, system-ui",
      },
      text
    )
  );
}

function HeatDot({ d }) {
  const { x, y } = centroidFromPath(d);
  return React.createElement("circle", { pointerEvents: "none", cx: x, cy: y, r: 6, fill: "#94a3b8" });
}

// ---------- Palette ----------
function Palette({ palette, remaining, activeColor, onSelect }) {
  return React.createElement(
    "div",
    { style: styles.paletteWrap },
    palette.map((p) => {
      const left = remaining[p.id] ?? 0;
      const isActive = p.id === activeColor;
      return React.createElement(
        "button",
        {
          key: p.id,
          onClick: () => onSelect(p.id),
          disabled: left === 0 && !isActive,
          "aria-pressed": isActive,
          "aria-label": `${p.name ?? "Color"} #${p.id}. ${left} cells remaining`,
          title: `${p.name ?? "Color"} #${p.id} - Remaining ${left}`,
          style: {
            ...styles.swatch,
            background: p.rgba,
            border: isActive
              ? "2px solid rgba(248, 250, 252, 0.85)"
              : "2px solid rgba(15, 23, 42, 0.6)",
            boxShadow: isActive
              ? "0 0 0 4px rgba(148, 163, 184, 0.45), 0 10px 24px rgba(2, 6, 23, 0.55)"
              : "0 8px 18px rgba(2, 6, 23, 0.45)",
            opacity: left === 0 && !isActive ? 0.35 : 1,
          },
        },
        React.createElement("span", { style: styles.swatchNumber }, p.id)
      );
    })
  );
}

function ArtLibrary({
  artworks,
  activeArtworkId,
  progressMap,
  onSelect,
  onClose,
  onImport,
  onDelete,
  onRename,
  onClearProgress,
}) {
  const [draft, setDraft] = useState("");
  const [feedback, setFeedback] = useState(null);
  const [editingId, setEditingId] = useState(null);
  const [titleDraft, setTitleDraft] = useState("");
  const [promptStatus, setPromptStatus] = useState(null);
  const promptTimerRef = useRef(null);

  const sorted = useMemo(
    () => [...artworks].sort((a, b) => a.title.localeCompare(b.title)),
    [artworks]
  );

  useEffect(() => {
    function handleKey(e) {
      if (e.key === "Escape") onClose();
    }
    window.addEventListener("keydown", handleKey);
    return () => window.removeEventListener("keydown", handleKey);
  }, [onClose]);

  useEffect(() => {
    return () => {
      if (promptTimerRef.current) clearTimeout(promptTimerRef.current);
    };
  }, []);

  const promptText = `You are an SVG color-by-number generator. Produce JSON with keys: id (short slug), title, width, height, palette (array of { id, name, rgba }), and cells (array of { id, colorId, d } path commands using only M/L/Z). Ensure 40-80 cells and 6-12 palette entries. Colors should be polished and themed. Return JSON only.`;

  function schedulePromptStatus(status) {
    setPromptStatus(status);
    if (promptTimerRef.current) {
      clearTimeout(promptTimerRef.current);
    }
    promptTimerRef.current = setTimeout(() => setPromptStatus(null), 2500);
  }

  function handleCopyPrompt() {
    const clipboard = navigator?.clipboard;
    if (clipboard?.writeText) {
      clipboard
        .writeText(promptText)
        .then(() =>
          schedulePromptStatus({ type: "success", message: "Prompt copied to clipboard." })
        )
        .catch(() =>
          schedulePromptStatus({
            type: "error",
            message: "Clipboard copy failed. Copy manually below.",
          })
        );
      return;
    }

    try {
      const textarea = document.createElement("textarea");
      textarea.value = promptText;
      textarea.setAttribute("readonly", "true");
      textarea.style.position = "absolute";
      textarea.style.left = "-9999px";
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand("copy");
      document.body.removeChild(textarea);
      schedulePromptStatus({ type: "success", message: "Prompt copied to clipboard." });
    } catch (err) {
      schedulePromptStatus({ type: "error", message: "Clipboard copy failed. Copy manually below." });
    }
  }

  function handleImportSubmit(e) {
    e?.preventDefault?.();
    const result = onImport(draft);
    if (result?.ok) {
      setDraft("");
      setFeedback({ type: "success", message: `Imported "${result.artwork.title}".` });
      setEditingId(null);
      setTitleDraft("");
    } else if (result?.error) {
      setFeedback({ type: "error", message: result.error });
    } else {
      setFeedback({ type: "error", message: "Unable to import artwork." });
    }
  }

  function startEditing(art) {
    setEditingId(art.id);
    setTitleDraft(art.title);
  }

  function saveEdit() {
    onRename(editingId, titleDraft);
    setEditingId(null);
    setTitleDraft("");
  }

  function cancelEdit() {
    setEditingId(null);
    setTitleDraft("");
  }

  const list = sorted.length
    ? sorted.map((art) => {
        const isActive = art.id === activeArtworkId;
        const isEditing = editingId === art.id;
        const progress = progressMap?.[art.id] ?? 0;
        return React.createElement(
          "div",
          {
            key: art.id,
            style: {
              ...styles.libraryItem,
              ...(isActive ? styles.libraryItemActive : {}),
            },
          },
          React.createElement(
            "div",
            { style: styles.libraryItemHeader },
            isEditing
              ? React.createElement("input", {
                  style: styles.libraryTitleInput,
                  value: titleDraft,
                  onChange: (e) => setTitleDraft(e.target.value),
                  autoFocus: true,
                })
              : React.createElement("div", { style: styles.libraryItemTitle }, art.title),
            React.createElement(
              "span",
              {
                style: {
                  ...styles.libraryBadge,
                  ...(isActive ? styles.libraryBadgeActive : {}),
                },
              },
              isActive ? "Active" : `${progress}%`
            )
          ),
          React.createElement(
            "div",
            { style: styles.libraryMeta },
            `Progress: ${progress}% - ${art.palette.length} colors - ${art.cells.length} cells`
          ),
          React.createElement(
            "div",
            { style: styles.libraryButtons },
            isEditing
              ? [
                  React.createElement(
                    "button",
                    {
                      key: "save",
                      type: "button",
                      style: styles.libraryPrimaryButton,
                      onClick: saveEdit,
                    },
                    "Save"
                  ),
                  React.createElement(
                    "button",
                    {
                      key: "cancel",
                      type: "button",
                      style: styles.libraryButton,
                      onClick: cancelEdit,
                    },
                    "Cancel"
                  ),
                ]
              : [
                  React.createElement(
                    "button",
                    {
                      key: "load",
                      type: "button",
                      style: styles.libraryPrimaryButton,
                      onClick: () => onSelect(art.id),
                    },
                    isActive ? "Resume" : "Load"
                  ),
                  React.createElement(
                    "button",
                    {
                      key: "rename",
                      type: "button",
                      style: styles.libraryButton,
                      onClick: () => startEditing(art),
                    },
                    "Rename"
                  ),
                  React.createElement(
                    "button",
                    {
                      key: "clear",
                      type: "button",
                      style: styles.libraryButton,
                      onClick: () => onClearProgress(art.id),
                    },
                    "Clear progress"
                  ),
                  React.createElement(
                    "button",
                    {
                      key: "delete",
                      type: "button",
                      style: styles.libraryDangerButton,
                      onClick: () => onDelete(art.id),
                    },
                    "Delete"
                  ),
                ]
          )
        );
      })
    : React.createElement("div", { style: styles.libraryEmpty }, "No artworks saved yet.");

  return React.createElement(
    "div",
    { style: styles.libraryOverlay, onClick: onClose },
    React.createElement(
      "aside",
      {
        style: styles.libraryPanel,
        role: "dialog",
        "aria-modal": true,
        "aria-label": "Artwork library",
        onClick: (e) => e.stopPropagation(),
      },
      React.createElement(
        "div",
        { style: styles.libraryHeader },
        React.createElement("div", { style: styles.libraryTitle }, "Art Library"),
        React.createElement(
          "button",
          { style: styles.libraryClose, onClick: onClose, "aria-label": "Close art library" },
          "\u2715"
        )
      ),
      React.createElement("div", { style: styles.libraryList }, list),
      React.createElement(
        "section",
        { style: styles.libraryPromptSection },
        React.createElement("h3", { style: styles.libraryPromptTitle }, "ChatGPT prompt"),
        React.createElement(
          "p",
          { style: styles.libraryPromptBody },
          "Use this prompt with ChatGPT to produce a new color-by-number JSON file."
        ),
        React.createElement(
          "div",
          { style: styles.libraryPromptActions },
          React.createElement(
            "button",
            { type: "button", style: styles.libraryPrimaryButton, onClick: handleCopyPrompt },
            "Copy prompt"
          ),
          promptStatus &&
            React.createElement(
              "span",
              {
                style: {
                  ...styles.libraryPromptStatus,
                  color: promptStatus.type === "error" ? "#f87171" : "#22c55e",
                },
              },
              promptStatus.message
            )
        ),
        React.createElement(
          "pre",
          { style: styles.libraryPromptPre },
          promptText
        )
      ),
      React.createElement(
        "form",
        { style: styles.libraryImport, onSubmit: handleImportSubmit },
        React.createElement("label", { style: styles.libraryLabel }, "Import artwork JSON"),
        React.createElement("textarea", {
          style: styles.libraryTextarea,
          value: draft,
          onChange: (e) => setDraft(e.target.value),
          placeholder: "{ \"id\": \"my-art\", ... }",
          rows: 6,
        }),
        React.createElement(
          "div",
          { style: styles.libraryImportActions },
          React.createElement(
            "button",
            { type: "submit", style: styles.libraryPrimaryButton },
            "Add artwork"
          ),
          React.createElement(
            "button",
            {
              type: "button",
              style: styles.libraryButton,
              onClick: () => {
                setDraft("");
                setFeedback(null);
              },
            },
            "Clear"
          )
        ),
        feedback &&
          React.createElement(
            "div",
            {
              style: {
                ...styles.libraryFeedback,
                color: feedback.type === "error" ? "#f87171" : "#22c55e",
              },
            },
            feedback.message
          )
      )
    )
  );
}

function OptionsPanel({ config, onToggle, canReset, onReset, onClose }) {
  const options = [
    {
      key: "enableAutosave",
      label: "Autosave progress",
      description: "Persist the fill state and viewport to localStorage after each change.",
    },
    {
      key: "autoAdvanceOnComplete",
      label: "Auto-advance color",
      description: "Jump to the next color when the active color has no unfilled cells remaining.",
    },
    {
      key: "enableHintPulse",
      label: "Hint pulses",
      description: "Allow the Hint control to highlight the smallest unfilled cells in the active color.",
    },
    {
      key: "enableDragFill",
      label: "Drag-to-fill",
      description: "While painting, drag across adjacent cells to fill them without additional taps.",
    },
    {
      key: "enableEyedropper",
      label: "Eyedropper",
      description: "Tap a filled cell without moving to reselect its color.",
    },
    {
      key: "enableKeyboardShortcuts",
      label: "Keyboard shortcuts",
      description: "Use H, N, U, T, +/-, and 0 to control hints, color cycling, undo, tests, zoom, and fitting.",
    },
    {
      key: "showNumberBadges",
      label: "Number badges",
      description: "Show numbered overlays for unfilled cells when zoomed in.",
    },
    {
      key: "showHeatmapDots",
      label: "Heat-map dots",
      description: "Show locator dots for tiny cells when zoomed out.",
    },
    {
      key: "enableSmokeHud",
      label: "Smoke-test HUD",
      description: "Allow the debugging overlay that summarizes automated checks.",
    },
  ];

  const surfaces = [
    {
      title: "Root layout",
      body: "Dark-mode experience with a full-viewport canvas and floating header/footer controls.",
    },
    {
      title: "Header bar",
      body: "Back affordance, artwork title, progress text, and utility buttons for fit, undo, hint, next color, tests, and options.",
    },
    {
      title: "Canvas frame",
      body: "Fullscreen SVG stage with pan/zoom transforms, strokes, badges, and heat-map dots as you zoom.",
    },
    {
      title: "Smoke Tests HUD",
      body: "Optional floating card that reports automated sanity checks and can be hidden with the toolbar or T shortcut.",
    },
    {
      title: "Palette footer",
      body: "Scrollable row of numbered swatches with remaining counts, highlighting the active color and disabling completed ones.",
    },
  ];

  return React.createElement(
    "div",
    { style: styles.optionsOverlay, onClick: onClose },
    React.createElement(
      "aside",
      {
        style: styles.optionsCard,
        role: "dialog",
        "aria-modal": true,
        "aria-label": "Options and configuration",
        onClick: (e) => e.stopPropagation(),
      },
      React.createElement(
        "div",
        { style: styles.optionsHeader },
        React.createElement("div", { style: styles.optionsTitle }, "Options"),
        React.createElement(
          "button",
          { style: styles.optionsClose, onClick: onClose, "aria-label": "Close options" },
          "\u2715"
        )
      ),
      React.createElement(
        "p",
        { style: styles.optionsAbout },
        "The project is a single-page React 18 color-by-number demo that boots entirely from index.html, pulling React, ReactDOM, and Babel from CDNs so the JSX logic can run in the browser without a build step. It loads a predefined "Capybara Forest Retreat" scene inspired by a detailed 960x600 SVG reference (art/capybara-forest.svg) with 26 labeled, non-overlapping regions and an 11-color palette, then tracks each cell's fill state so players can match colors to numbers."
      ),
      React.createElement("div", { style: styles.optionsSectionTitle }, "UI surfaces"),
      React.createElement(
        "ul",
        { style: styles.optionsUiList },
        surfaces.map((s) =>
          React.createElement(
            "li",
            { key: s.title },
            React.createElement("strong", null, s.title, ": "),
            s.body
          )
        )
      ),
      React.createElement("div", { style: styles.optionsSectionTitle }, "Configuration"),
      React.createElement(
        "div",
        { style: styles.optionsList },
        options.map((opt) =>
          React.createElement(
            "label",
            { key: opt.key, style: styles.optionRow },
            React.createElement("input", {
              type: "checkbox",
              checked: !!config[opt.key],
              onChange: (e) => onToggle(opt.key, e.target.checked),
              style: styles.optionCheckbox,
            }),
            React.createElement(
              "div",
              null,
              React.createElement("div", { style: styles.optionLabel }, opt.label),
              React.createElement("div", { style: styles.optionDescription }, opt.description)
            )
          )
        )
      ),
      React.createElement("div", { style: styles.optionsSectionTitle }, "Current values"),
      React.createElement(
        "pre",
        { style: styles.optionsConfigPre },
        JSON.stringify(config, null, 2)
      ),
      React.createElement(
        "div",
        { style: styles.optionsFooter },
        React.createElement(
          "button",
          {
            style: {
              ...styles.optionsReset,
              opacity: canReset ? 1 : 0.5,
              cursor: canReset ? "pointer" : "not-allowed",
            },
            type: "button",
            onClick: canReset ? onReset : undefined,
            disabled: !canReset,
          },
          "Reset to defaults"
        )
      )
    )
  );
}

// ---------- Smoke Tests HUD ----------
function SmokeTests({ art, filled }) {
  const results = useMemo(() => runSmokeTests(art, filled), [art, filled]);
  const allPass = results.every((r) => r.pass);
  if (allPass) return null;
  return React.createElement(
    "div",
    {
      style: {
        position: "absolute",
        left: 16,
        bottom: 180,
        background: "rgba(248, 113, 113, 0.12)",
        border: "1px solid #f87171",
        borderRadius: 12,
        padding: 12,
        boxShadow: "0 12px 40px rgba(15, 23, 42, 0.35)",
        maxWidth: 360,
        fontSize: 12,
        backdropFilter: "blur(12px)",
      },
    },
    React.createElement(
      "div",
      { style: { fontWeight: 700, marginBottom: 8 } },
      "Smoke tests failed"
    ),
    React.createElement(
      "ul",
      { style: { margin: 0, paddingLeft: 18 } },
      results.map((r) => {
        const status = r.pass ? "[pass]" : "[fail]";
        const details = r.msg ? ` - ${r.msg}` : "";
        return React.createElement(
          "li",
          { key: r.name, style: { color: r.pass ? "#4ade80" : "#fca5a5" } },
          `${status} ${r.name}${details}`
        );
      })
    ),
    React.createElement(
      "div",
      { style: { marginTop: 8, color: "#94a3b8" } },
      "Press T to hide/show."
    )
  );
}

function runSmokeTests(art, filled) {
  const tests = [];
  const rem = computeRemaining(art, filled);
  const sum = Object.values(rem).reduce((a, b) => a + b, 0);
  const expected = art.cells.filter((c) => !filled[c.id]).length;
  tests.push({ name: "Remaining matches unfilled count", pass: sum === expected, msg: `${sum}/${expected}` });
  const c0 = art.cells[0];
  const { x, y } = centroidFromPath(c0.d);
  tests.push({ name: "Centroid in bounds", pass: x >= 0 && y >= 0 && x <= art.width && y <= art.height });
  const ids = new Set(art.palette.map((p) => p.id));
  tests.push({ name: "Palette IDs unique", pass: ids.size === art.palette.length });
  return tests;
}

// ---------- Styles ----------
const styles = {
  app: {
    width: "100vw",
    height: "100vh",
    position: "relative",
    overflow: "hidden",
    fontFamily: "'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui",
    color: "#f8fafc",
    background: "radial-gradient(circle at top, rgba(56, 189, 248, 0.12), #030712)",
  },
  canvas: {
    position: "absolute",
    inset: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
  },
  topBar: {
    position: "fixed",
    top: 16,
    left: "50%",
    transform: "translateX(-50%)",
    width: "min(880px, calc(100% - 28px))",
    display: "flex",
    flexWrap: "nowrap",
    justifyContent: "space-between",
    alignItems: "center",
    gap: 12,
    padding: "8px 14px",
    borderRadius: 16,
    background: "rgba(15, 23, 42, 0.82)",
    border: "1px solid rgba(148, 163, 184, 0.26)",
    boxShadow: "0 18px 36px rgba(2, 6, 23, 0.55)",
    backdropFilter: "blur(14px)",
    zIndex: 20,
  },
  topContext: {
    display: "flex",
    alignItems: "center",
    gap: 10,
    minWidth: 0,
    flex: "0 1 auto",
    overflow: "hidden",
  },
  topTitle: {
    fontSize: 16,
    fontWeight: 600,
    color: "#f8fafc",
    letterSpacing: 0.3,
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
  },
  topProgress: {
    fontSize: 12,
    fontWeight: 600,
    padding: "2px 10px",
    borderRadius: 999,
    background: "rgba(30, 41, 59, 0.7)",
    border: "1px solid rgba(148, 163, 184, 0.26)",
    color: "#d3defe",
    whiteSpace: "nowrap",
  },
  topActions: {
    display: "flex",
    flexWrap: "nowrap",
    justifyContent: "flex-end",
    gap: 6,
    flex: "1 1 auto",
    overflowX: "auto",
  },
  controlButton: {
    borderRadius: 10,
    border: "1px solid rgba(148, 163, 184, 0.28)",
    background: "linear-gradient(180deg, rgba(51, 65, 85, 0.55), rgba(15, 23, 42, 0.9))",
    color: "#f8fafc",
    fontSize: 12,
    fontWeight: 600,
    letterSpacing: 0.2,
    padding: "6px 12px",
    minHeight: 34,
    minWidth: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    gap: 6,
    cursor: "pointer",
    boxShadow: "0 12px 28px rgba(2, 6, 23, 0.45)",
    transition: "transform 0.15s ease, box-shadow 0.2s ease, background 0.2s ease",
    textTransform: "none",
    whiteSpace: "nowrap",
    lineHeight: 1.2,
  },
  paletteDock: {
    position: "fixed",
    left: "50%",
    bottom: 24,
    transform: "translateX(-50%)",
    width: "min(920px, calc(100% - 24px))",
    background: "rgba(15, 23, 42, 0.82)",
    borderRadius: 18,
    border: "1px solid rgba(148, 163, 184, 0.28)",
    padding: "10px 14px",
    boxShadow: "0 24px 50px rgba(2, 6, 23, 0.6)",
    zIndex: 11,
    overflow: "hidden",
    backdropFilter: "blur(16px)",
  },
  emptyState: {
    position: "absolute",
    inset: 0,
    display: "grid",
    placeItems: "center",
    padding: 24,
    color: "#94a3b8",
    fontSize: 18,
    textAlign: "center",
  },
  paletteWrap: {
    display: "flex",
    flexDirection: "row",
    flexWrap: "nowrap",
    gap: 10,
    width: "100%",
    overflowX: "auto",
    paddingBottom: 4,
    scrollSnapType: "x proximity",
  },
  swatch: {
    height: 38,
    borderRadius: 12,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    transition: "transform 0.12s ease, box-shadow 0.2s ease",
    cursor: "pointer",
    color: "#f8fafc",
    flex: "0 0 clamp(88px, 12vw, 132px)",
    scrollSnapAlign: "center",
  },
  swatchNumber: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    width: 20,
    height: 20,
    borderRadius: "50%",
    background: "rgba(15, 23, 42, 0.52)",
    color: "#f8fafc",
    fontSize: 10,
    fontWeight: 700,
    letterSpacing: 0.4,
  },
  libraryOverlay: {
    position: "fixed",
    inset: 0,
    background: "rgba(2, 6, 23, 0.7)",
    backdropFilter: "blur(12px)",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    padding: "24px",
    zIndex: 60,
  },
  libraryPanel: {
    width: "min(560px, 100%)",
    maxHeight: "calc(100vh - 48px)",
    overflowY: "auto",
    background: "rgba(15, 23, 42, 0.96)",
    borderRadius: 24,
    padding: 24,
    boxShadow: "0 24px 60px rgba(2, 6, 23, 0.7)",
    border: "1px solid rgba(148, 163, 184, 0.3)",
    color: "#e2e8f0",
    display: "grid",
    gap: 20,
  },
  libraryHeader: {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
  },
  libraryTitle: {
    fontSize: 20,
    fontWeight: 700,
  },
  libraryClose: {
    width: 36,
    height: 36,
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.8)",
    color: "#cbd5f5",
    cursor: "pointer",
  },
  libraryList: {
    display: "grid",
    gap: 12,
  },
  libraryItem: {
    border: "1px solid rgba(148, 163, 184, 0.2)",
    borderRadius: 16,
    padding: 16,
    background: "rgba(15, 23, 42, 0.7)",
    display: "grid",
    gap: 12,
  },
  libraryItemActive: {
    borderColor: "rgba(56, 189, 248, 0.6)",
    boxShadow: "0 0 0 1px rgba(56, 189, 248, 0.4)",
  },
  libraryItemHeader: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
  },
  libraryItemTitle: {
    fontWeight: 600,
    fontSize: 16,
  },
  libraryTitleInput: {
    width: "100%",
    padding: "6px 10px",
    borderRadius: 10,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.85)",
    color: "#e2e8f0",
  },
  libraryBadge: {
    padding: "4px 10px",
    borderRadius: 999,
    fontSize: 12,
    background: "rgba(148, 163, 184, 0.2)",
    color: "#cbd5f5",
  },
  libraryBadgeActive: {
    background: "rgba(56, 189, 248, 0.2)",
    color: "#38bdf8",
  },
  libraryMeta: {
    fontSize: 13,
    color: "#94a3b8",
  },
  libraryButtons: {
    display: "flex",
    flexWrap: "wrap",
    gap: 8,
  },
  libraryButton: {
    padding: "8px 12px",
    borderRadius: 10,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(30, 41, 59, 0.6)",
    color: "#cbd5f5",
    cursor: "pointer",
  },
  libraryPrimaryButton: {
    padding: "8px 12px",
    borderRadius: 10,
    border: "1px solid rgba(56, 189, 248, 0.5)",
    background: "rgba(56, 189, 248, 0.2)",
    color: "#38bdf8",
    cursor: "pointer",
  },
  libraryDangerButton: {
    padding: "8px 12px",
    borderRadius: 10,
    border: "1px solid rgba(248, 113, 113, 0.5)",
    background: "rgba(248, 113, 113, 0.15)",
    color: "#fca5a5",
    cursor: "pointer",
  },
  libraryEmpty: {
    padding: 16,
    textAlign: "center",
    color: "#94a3b8",
    border: "1px dashed rgba(148, 163, 184, 0.3)",
    borderRadius: 16,
  },
  libraryPromptSection: {
    border: "1px solid rgba(148, 163, 184, 0.25)",
    borderRadius: 16,
    padding: 16,
    background: "rgba(15, 23, 42, 0.7)",
    display: "grid",
    gap: 12,
  },
  libraryPromptTitle: {
    margin: 0,
    fontSize: 15,
    fontWeight: 600,
  },
  libraryPromptBody: {
    margin: 0,
    fontSize: 13,
    color: "#94a3b8",
  },
  libraryPromptActions: {
    display: "flex",
    alignItems: "center",
    gap: 12,
  },
  libraryPromptStatus: {
    fontSize: 12,
  },
  libraryPromptPre: {
    margin: 0,
    padding: 12,
    background: "rgba(15, 23, 42, 0.85)",
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.2)",
    fontSize: 12,
    color: "#cbd5f5",
    overflowX: "auto",
    whiteSpace: "pre-wrap",
    fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
  },
  libraryImport: {
    display: "grid",
    gap: 12,
  },
  libraryLabel: {
    fontSize: 13,
    fontWeight: 600,
    color: "#cbd5f5",
  },
  libraryTextarea: {
    width: "100%",
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.8)",
    color: "#e2e8f0",
    padding: 12,
    fontSize: 13,
    fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
  },
  libraryImportActions: {
    display: "flex",
    gap: 12,
    flexWrap: "wrap",
  },
  libraryFeedback: {
    fontSize: 12,
  },
  optionsOverlay: {
    position: "fixed",
    inset: 0,
    background: "rgba(2, 6, 23, 0.6)",
    backdropFilter: "blur(8px)",
    display: "flex",
    justifyContent: "flex-end",
    alignItems: "center",
    padding: "24px 32px",
    zIndex: 50,
  },
  optionsCard: {
    width: "min(420px, 100%)",
    maxHeight: "calc(100vh - 48px)",
    overflowY: "auto",
    background: "rgba(15, 23, 42, 0.96)",
    borderRadius: 24,
    padding: 24,
    boxShadow: "0 24px 60px rgba(2, 6, 23, 0.65)",
    border: "1px solid rgba(148, 163, 184, 0.25)",
    color: "#e2e8f0",
  },
  optionsHeader: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 12,
  },
  optionsTitle: {
    fontSize: 20,
    fontWeight: 700,
  },
  optionsClose: {
    width: 32,
    height: 32,
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.8)",
    color: "#cbd5f5",
    cursor: "pointer",
  },
  optionsAbout: {
    fontSize: 13,
    lineHeight: 1.6,
    color: "#cbd5f5",
    marginTop: 0,
    marginBottom: 16,
  },
  optionsSectionTitle: {
    fontSize: 11,
    textTransform: "uppercase",
    letterSpacing: 1,
    color: "#64748b",
    margin: "20px 0 10px",
  },
  optionsUiList: {
    margin: 0,
    paddingLeft: 18,
    display: "grid",
    gap: 8,
    fontSize: 13,
    color: "#d0def5",
  },
  optionsList: {
    display: "grid",
    gap: 12,
  },
  optionRow: {
    display: "grid",
    gridTemplateColumns: "auto 1fr",
    gap: 12,
    alignItems: "start",
    background: "rgba(15, 23, 42, 0.7)",
    padding: 12,
    borderRadius: 16,
    border: "1px solid rgba(148, 163, 184, 0.15)",
  },
  optionCheckbox: {
    width: 18,
    height: 18,
    marginTop: 4,
  },
  optionLabel: {
    fontWeight: 600,
    color: "#e2e8f0",
  },
  optionDescription: {
    fontSize: 12,
    color: "#94a3b8",
    marginTop: 4,
  },
  optionsConfigPre: {
    margin: 0,
    padding: 12,
    background: "rgba(15, 23, 42, 0.7)",
    borderRadius: 16,
    border: "1px solid rgba(148, 163, 184, 0.15)",
    fontSize: 12,
    color: "#f8fafc",
    overflowX: "auto",
  },
  optionsFooter: {
    marginTop: 16,
    display: "flex",
    justifyContent: "flex-end",
  },
  optionsReset: {
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(51, 65, 85, 0.4)",
    color: "#e2e8f0",
    padding: "10px 16px",
    cursor: "pointer",
    fontWeight: 600,
  },
};

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(React.createElement(App));
    </script>
  </body>
</html>


