<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Color-by-Number Demo</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "Inter", "Segoe UI", -apple-system, BlinkMacSystemFont, system-ui,
          sans-serif;
        background-color: #030712;
        color: #e2e8f0;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, rgba(56, 189, 248, 0.08), transparent),
          #030712;
        color: inherit;
      }

      #root {
        min-height: 100vh;
      }

      button {
        font: inherit;
      }

      svg {
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <div id="root" role="application" aria-label="Color-by-number painting app"></div>

    <script src="./vendor/react.development.js"></script>
    <script src="./vendor/react-dom.development.js"></script>
    <script src="./vendor/babel.min.js"></script>
    <script type="text/babel">
const { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } = React;

const pathBoxCache = new Map();
const pathAreaCache = new Map();
const interiorPointCache = new Map();
const SVG_NS = "http://www.w3.org/2000/svg";
let measureSvgEl = null;
let measureCanvasCtx = null;

// Capybooper Web Game - MVP single-file React app (patched)
// Fixes: correct zoom/pan math, pan over filled cells, pinch zoom, tap-to-fill,
// eyedropper, auto-advance, hint stroke highlight, smoke-test HUD.
// No external libs. LocalStorage autosave. Keyboard support.

// ---------- Types ----------
/** @typedef {number} ColorId */

/**
 * @typedef PaletteItem
 * @property {ColorId} id
 * @property {string=} name
 * @property {string} rgba
 */

/**
 * @typedef Cell
 * @property {string} id
 * @property {ColorId} colorId
 * @property {string} d
 * @property {number=} area
 */

/**
 * @typedef Artwork
 * @property {string} id
 * @property {string} title
 * @property {number} width
 * @property {number} height
 * @property {PaletteItem[]} palette
 * @property {Cell[]} cells
 */

/**
 * @typedef SaveState
 * @property {string} artworkId
 * @property {Record<string, boolean>} filled
 * @property {ColorId=} activeColor
 * @property {{ scale: number; x: number; y: number }=} viewport
 * @property {number} lastSaved
 */

// ---------- Sample Artwork ----------
const DEMO_ART = {
  id: "demo-capybara-forest",
  title: "Capybara Forest Retreat",
  width: 960,
  height: 600,
  palette: [
    { id: 1, name: "Sky Mist", rgba: "#86c5ff" },
    { id: 2, name: "Sky Veil", rgba: "#e6f0ff" },
    { id: 3, name: "Dawn Glow", rgba: "#fef6e4" },
    { id: 4, name: "Distant Hills", rgba: "#b7d1a7" },
    { id: 5, name: "Pine Canopy", rgba: "#2f7a33" },
    { id: 6, name: "Pine Shadow", rgba: "#255f27" },
    { id: 7, name: "Pond Light", rgba: "#7fd5ef" },
    { id: 8, name: "Meadow Moss", rgba: "#3b7b46" },
    { id: 9, name: "Capybara Fur", rgba: "#8e5b3a" },
    { id: 10, name: "Capybara Shade", rgba: "#5a3d2a" },
    { id: 11, name: "Forest Accent", rgba: "#2c6e49" },
  ],
  cells: [
    { id: "c1", colorId: 1, d: "M0 0 L960 0 L960 140 C 860 150 760 150 660 140 C 560 130 480 130 400 140 C 280 155 160 150 0 130 Z" },
    { id: "c2", colorId: 3, d: "M0 130 C 160 150 320 160 480 160 L480 210 C 320 205 160 200 0 190 Z" },
    { id: "c3", colorId: 2, d: "M480 160 C 640 170 800 160 960 140 L960 210 C 800 215 640 215 480 210 Z" },
    { id: "c4", colorId: 4, d: "M0 190 C 120 210 240 220 360 220 C 400 220 420 218 420 218 L420 260 L0 260 Z" },
    { id: "c5", colorId: 4, d: "M420 218 C 560 210 700 210 840 205 C 900 202 940 200 960 205 L960 260 L420 260 Z" },
    { id: "c6", colorId: 5, d: "M0 260 C 100 300 220 320 300 330 C 220 340 140 350 40 340 C 20 330 0 300 0 260 Z" },
    { id: "c7", colorId: 6, d: "M300 330 C 380 300 500 290 620 300 C 680 310 740 330 780 360 L780 360 L300 360 Z" },
    { id: "c8", colorId: 5, d: "M780 360 C 820 320 880 300 960 290 L960 360 L780 360 Z" },
    { id: "c9", colorId: 6, d: "M0 360 C 120 380 240 390 360 390 C 480 390 600 370 720 360 C 820 350 900 350 960 360 L960 420 C 860 430 760 430 660 420 C 560 410 460 410 360 420 C 240 430 120 420 0 400 Z" },
    { id: "c10", colorId: 2, d: "M0 420 C 160 440 320 450 480 445 C 640 440 800 430 960 420 L960 460 C 800 480 640 490 480 485 C 320 480 160 470 0 450 Z" },
    { id: "c11", colorId: 7, d: "M0 460 C 160 480 320 495 480 490 C 640 485 800 470 960 460 L960 500 L0 500 Z" },
    { id: "c12", colorId: 8, d: "M0 500 L170 508 L170 560 L0 560 Z" },
    { id: "c13", colorId: 8, d: "M240 508 L320 515 L320 560 L240 560 Z" },
    { id: "c14", colorId: 8, d: "M320 515 L360 518 L360 560 L320 560 Z" },
    { id: "c15", colorId: 8, d: "M680 515 L720 518 L720 560 L680 560 Z" },
    { id: "c16", colorId: 3, d: "M168 500 L240 504 L240 540 C 224 548 204 552 176 554 L168 554 Z" },
    { id: "c17", colorId: 11, d: "M160 540 C 188 518 216 518 240 540 L240 560 L160 560 Z" },
    { id: "c18", colorId: 9, d: "M360 540 L360 508 C 380 472 430 450 500 444 C 580 438 650 456 680 496 L680 540 Z" },
    { id: "c19", colorId: 10, d: "M360 540 L680 540 L680 560 C 620 576 540 582 460 576 C 400 572 372 562 360 552 Z" },
    { id: "c20", colorId: 8, d: "M720 518 L736 516 L736 560 L720 560 Z" },
    { id: "c21", colorId: 3, d: "M736 500 L792 504 L792 540 C 780 546 766 550 744 552 L736 552 Z" },
    { id: "c22", colorId: 11, d: "M724 540 C 752 520 788 520 820 540 L820 560 L724 560 Z" },
    { id: "c23", colorId: 8, d: "M792 504 L820 502 L820 540 L792 540 Z" },
    { id: "c24", colorId: 8, d: "M820 502 L880 500 L880 560 L820 560 Z" },
    { id: "c25", colorId: 8, d: "M880 500 L960 500 L960 560 L880 560 Z" },
    { id: "c26", colorId: 8, d: "M0 560 C 200 580 400 590 600 585 C 760 580 880 570 960 575 L960 600 L0 600 Z" },
  ].map((c) => ({ ...c, area: estimatePathArea(c.d) })),
};

const LAGOON_ART = {
  id: "demo-capybara-lagoon",
  title: "Capybara Lagoon Sunrise",
  width: 960,
  height: 600,
  palette: [
    { id: 1, name: "Sunrise Sky", rgba: "#f6bf60" },
    { id: 2, name: "Amber Drift", rgba: "#f4994c" },
    { id: 3, name: "Violet Ridge", rgba: "#9a6bb3" },
    { id: 4, name: "Forest Ridge", rgba: "#5d7a76" },
    { id: 5, name: "Lagoon Light", rgba: "#76c7d6" },
    { id: 6, name: "Lagoon Depth", rgba: "#1c6f8c" },
    { id: 7, name: "Shore Left", rgba: "#4f7d5c" },
    { id: 8, name: "Shore Middle", rgba: "#6b9358" },
    { id: 9, name: "Capy Body", rgba: "#7d5735" },
    { id: 10, name: "Capy Head", rgba: "#5e3b24" },
    { id: 11, name: "Shore Right", rgba: "#3f5b3b" },
  ],
  cells: [
    {
      id: "c1",
      colorId: 1,
      d: "M0 0 L960 0 L960 160 C 760 150 600 150 480 155 C 320 160 160 165 0 160 Z",
    },
    {
      id: "c2",
      colorId: 2,
      d: "M0 160 C 160 170 320 190 480 190 C 640 190 800 170 960 160 L960 220 C 800 230 640 240 480 240 C 320 240 160 230 0 220 Z",
    },
    {
      id: "c3",
      colorId: 3,
      d: "M0 220 L120 200 L240 230 L360 210 L480 235 L600 205 L720 230 L840 215 L960 240 L960 300 L0 300 Z",
    },
    {
      id: "c4",
      colorId: 4,
      d: "M0 300 C 160 280 320 310 480 295 C 640 280 800 310 960 290 L960 360 L0 360 Z",
    },
    {
      id: "c5",
      colorId: 5,
      d: "M0 360 C 180 380 360 390 540 380 C 720 370 840 360 960 365 L960 440 L0 440 Z",
    },
    {
      id: "c6",
      colorId: 6,
      d: "M0 440 C 200 460 380 470 560 465 C 740 460 860 450 960 455 L960 520 L0 520 Z",
    },
    {
      id: "c7",
      colorId: 7,
      d: "M0 520 C 150 540 260 545 320 548 L320 600 L0 600 Z",
    },
    {
      id: "c8",
      colorId: 8,
      d: "M320 548 C 380 552 450 552 520 545 L520 600 L320 600 Z",
    },
    {
      id: "c9",
      colorId: 9,
      d: "M520 545 C 540 500 600 470 680 470 C 740 470 780 495 790 530 L790 600 L520 600 Z",
    },
    {
      id: "c10",
      colorId: 10,
      d: "M790 530 C 810 500 850 500 870 520 C 890 540 890 570 870 585 C 850 600 810 595 795 570 Z",
    },
    {
      id: "c11",
      colorId: 11,
      d: "M870 585 C 900 570 930 562 960 565 L960 600 L870 600 Z",
    },
  ].map((c) => ({ ...c, area: estimatePathArea(c.d) })),
};

const TWILIGHT_ART = {
  id: "demo-capybara-twilight",
  title: "Twilight Marsh Study",
  width: 960,
  height: 600,
  palette: [
    { id: 1, name: "Evening Sky", rgba: "#f7c59f" },
    { id: 2, name: "Glow Band", rgba: "#f27d72" },
    { id: 3, name: "Distant Ridge", rgba: "#8c5fa6" },
    { id: 4, name: "Low Ridge", rgba: "#546d7a" },
    { id: 5, name: "River Mirror", rgba: "#4f9fc6" },
    { id: 6, name: "River Depth", rgba: "#1f6b8f" },
    { id: 7, name: "Shore Glow", rgba: "#5d8f63" },
    { id: 8, name: "Shore Shadow", rgba: "#2f4c45" },
  ],
  cells: [
    {
      id: "c1",
      colorId: 1,
      d: "M0 0 L960 0 L960 160 C 640 150 320 150 0 160 Z",
    },
    {
      id: "c2",
      colorId: 2,
      d: "M0 160 C 160 180 320 180 480 185 C 640 190 800 180 960 170 L960 230 C 640 240 320 240 0 230 Z",
    },
    {
      id: "c3",
      colorId: 3,
      d: "M0 230 C 200 260 400 250 600 270 C 800 290 880 270 960 280 L960 340 L0 340 Z",
    },
    {
      id: "c4",
      colorId: 4,
      d: "M0 340 C 200 360 400 360 600 355 C 800 350 880 350 960 355 L960 420 L0 420 Z",
    },
    {
      id: "c5",
      colorId: 5,
      d: "M0 420 C 220 440 440 450 660 440 C 800 434 880 430 960 432 L960 490 L0 490 Z",
    },
    {
      id: "c6",
      colorId: 6,
      d: "M0 490 C 200 510 400 520 600 515 C 800 510 880 508 960 510 L960 555 L0 555 Z",
    },
    {
      id: "c7",
      colorId: 7,
      d: "M0 555 C 180 570 360 580 540 575 L540 600 L0 600 Z",
    },
    {
      id: "c8",
      colorId: 8,
      d: "M540 575 C 700 570 840 565 960 570 L960 600 L540 600 Z",
    },
  ].map((c) => ({ ...c, area: estimatePathArea(c.d) })),
};
function cloneArtwork(art) {
  return {
    ...art,
    palette: (art.palette ?? []).map((p) => ({ ...p })),
    cells: (art.cells ?? []).map((c) => ({ ...c })),
  };
}

function getStarterArtworks() {
  return [
    cloneArtwork(DEMO_ART),
    cloneArtwork(LAGOON_ART),
    cloneArtwork(TWILIGHT_ART),
  ];
}

// Estimate area for heuristics using DOM sampling with a polygon fallback.
function estimatePathArea(d) {
  const bbox = measurePathBox(d);
  const measured = measurePathArea(d, bbox);
  if (typeof measured === "number" && measured > 0) {
    return measured;
  }

  try {
    const tokens = d.split(/[ ,]/).filter(Boolean);
    const pts = [];
    for (let i = 0; i < tokens.length; i++) {
      const t = tokens[i];
      if (t === "M" || t === "L" || t === "Z") continue;
      const n = Number(t);
      if (!Number.isNaN(n)) pts.push(n);
    }
    const xy = [];
    for (let i = 0; i + 1 < pts.length; i += 2) xy.push([pts[i], pts[i + 1]]);
    let area = 0;
    for (let i = 0; i < xy.length; i++) {
      const [x1, y1] = xy[i];
      const [x2, y2] = xy[(i + 1) % xy.length];
      area += x1 * y2 - x2 * y1;
    }
    return Math.abs(area / 2) || 1000;
  } catch (err) {
    return 1000;
  }
}

// ---------- Utilities ----------
const SAVE_KEY = (artId) => `capybooper_save_${artId}`;
const ARTWORKS_KEY = "capybooper_artworks_v1";
const ACTIVE_ART_KEY = "capybooper_active_art";

function normalizeArtwork(raw) {
  if (!raw) return null;
  try {
    const width = Number(raw.width);
    const height = Number(raw.height);
    if (!Number.isFinite(width) || width <= 0) return null;
    if (!Number.isFinite(height) || height <= 0) return null;
    const palette = Array.isArray(raw.palette)
      ? raw.palette
          .map((item) => ({
            id: item.id,
            name: item.name ?? undefined,
            rgba: item.rgba,
          }))
          .filter((item) => item.id !== undefined && typeof item.rgba === "string")
      : [];
    const cells = Array.isArray(raw.cells)
      ? raw.cells
          .map((cell) => ({
            id: cell.id,
            colorId: cell.colorId,
            d: cell.d,
            area: cell.area ?? estimatePathArea(cell.d ?? ""),
          }))
          .filter(
            (cell) =>
              typeof cell.id === "string" &&
              cell.id.length > 0 &&
              typeof cell.d === "string" &&
              cell.d.length > 0 &&
              cell.colorId !== undefined
          )
      : [];
    const title = (raw.title ?? "").trim();
    let id = (raw.id ?? "").toString().trim();
    if (!title || !palette.length || !cells.length) return null;
    if (!id) {
      const slug = title
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "");
      id = slug || `art-${Math.random().toString(36).slice(2, 8)}`;
    }
    return {
      id,
      title,
      width,
      height,
      palette,
      cells,
    };
  } catch (err) {
    return null;
  }
}

function parseDimension(value) {
  if (value === null || value === undefined) return null;
  const num = Number.parseFloat(value);
  return Number.isFinite(num) && num > 0 ? num : null;
}

function coerceId(value) {
  if (value === null || value === undefined) return undefined;
  if (typeof value === "number") return value;
  const trimmed = value.toString().trim();
  if (!trimmed) return undefined;
  if (/^-?\d+(?:\.\d+)?$/.test(trimmed) && !/^0\d+/.test(trimmed)) {
    const num = Number(trimmed);
    if (Number.isFinite(num)) return num;
  }
  return trimmed;
}

function parseSvgArtwork(raw, meta = {}) {
  try {
    const parser = new DOMParser();
    const doc = parser.parseFromString(raw, "image/svg+xml");
    if (!doc) {
      return { ok: false, error: "Unable to parse the SVG markup." };
    }
    if (doc.querySelector("parsererror")) {
      return { ok: false, error: "The SVG markup contains syntax errors." };
    }
    const svgEl = doc.querySelector("svg");
    if (!svgEl) {
      return { ok: false, error: "The SVG is missing a <svg> root element." };
    }

    let width = parseDimension(svgEl.getAttribute("width"));
    let height = parseDimension(svgEl.getAttribute("height"));
    const viewBox = svgEl.getAttribute("viewBox");
    if ((!width || !height) && viewBox) {
      const parts = viewBox
        .trim()
        .split(/[ ,]+/)
        .map((v) => Number.parseFloat(v))
        .filter((v) => Number.isFinite(v));
      if (parts.length >= 4) {
        width = width || parts[2];
        height = height || parts[3];
      }
    }
    if (!width || !height) {
      return { ok: false, error: "The SVG must include width/height or a valid viewBox." };
    }

    const rawNodes = Array.from(svgEl.querySelectorAll("[data-cell-id]"));
    const nodes = rawNodes.filter((node) => {
      const parent = node.parentElement?.closest?.("[data-cell-id]");
      return !parent;
    });
    if (!nodes.length) {
      return {
        ok: false,
        error:
          "No paintable regions were found. Each region needs a data-cell-id attribute.",
      };
    }

    const paletteMap = new Map();
    const cells = [];

    nodes.forEach((node, index) => {
      const cellId = (node.getAttribute("data-cell-id") || "").trim() || `c${index + 1}`;
      const colorSource = node.getAttribute("data-color-id") ?? node.getAttribute("data-color");
      const resolvedColorId = coerceId(colorSource ?? index + 1) ?? index + 1;
      const paletteKey = String(resolvedColorId);

      const pathNodes = [];
      if (node.tagName && node.tagName.toLowerCase() === "path") {
        pathNodes.push(node);
      }
      node.querySelectorAll?.("path").forEach((el) => {
        pathNodes.push(el);
      });

      const segments = pathNodes
        .map((el) => (el.getAttribute("d") || "").trim())
        .filter((d) => d.length > 0);
      if (!segments.length) {
        throw new Error(`Region ${cellId} is missing path data.`);
      }
      const d = segments.join(" ");

      let colorValue =
        node.getAttribute("data-color-hex") ||
        node.getAttribute("data-color-rgba") ||
        node.getAttribute("data-color") ||
        node.getAttribute("fill");
      if ((!colorValue || !colorValue.trim()) && pathNodes.length) {
        for (const path of pathNodes) {
          const fill = path.getAttribute("fill");
          if (fill && fill.trim()) {
            colorValue = fill.trim();
            break;
          }
        }
      }
      const paletteName = (node.getAttribute("data-color-name") || "").trim();

      const existing = paletteMap.get(paletteKey);
      if (existing) {
        if (!existing.name && paletteName) existing.name = paletteName;
        if (!existing.rgba && colorValue) existing.rgba = colorValue;
      } else {
        paletteMap.set(paletteKey, {
          id: resolvedColorId,
          name: paletteName || undefined,
          rgba: (colorValue && colorValue.trim()) || undefined,
        });
      }

      cells.push({
        id: cellId,
        colorId: paletteMap.get(paletteKey).id,
        d,
      });
    });

    const palette = Array.from(paletteMap.values()).map((entry) => ({
      id: entry.id,
      name: entry.name || `Color ${entry.id}`,
      rgba: entry.rgba || "#94a3b8",
    }));
    palette.sort((a, b) => {
      const aNum = typeof a.id === "number" ? a.id : Number.NaN;
      const bNum = typeof b.id === "number" ? b.id : Number.NaN;
      if (Number.isFinite(aNum) && Number.isFinite(bNum)) return aNum - bNum;
      return a.id.toString().localeCompare(b.id.toString());
    });

    const filename = (meta?.filename || "").replace(/\.[^./]+$/, "");
    const rawTitle =
      svgEl.getAttribute("data-title") ||
      svgEl.getAttribute("title") ||
      doc.querySelector("title")?.textContent ||
      filename ||
      "Imported artwork";
    const title = rawTitle.toString().trim() || "Imported artwork";
    const rawId =
      svgEl.getAttribute("data-art-id") ||
      svgEl.getAttribute("id") ||
      (filename || "").trim();
    let id = (rawId || "").toString().trim();
    if (!id) {
      id = title
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "");
    }

    const normalized = normalizeArtwork({
      id,
      title,
      width,
      height,
      palette,
      cells,
    });
    if (!normalized) {
      return { ok: false, error: "The SVG is missing required artwork metadata." };
    }
    return { ok: true, artwork: normalized };
  } catch (err) {
    return {
      ok: false,
      error:
        err instanceof Error ? err.message : "Unable to convert the SVG into artwork data.",
    };
  }
}

function parseArtworkPayload(raw, meta = {}) {
  const text = typeof raw === "string" ? raw.trim() : "";
  if (!text) {
    return { ok: false, error: "Paste artwork JSON or SVG first." };
  }
  if (text.startsWith("<")) {
    return parseSvgArtwork(text, meta);
  }
  try {
    const parsed = JSON.parse(text);
    let candidate = parsed;
    if (Array.isArray(candidate)) {
      candidate = candidate[0];
    }
    if (candidate && typeof candidate === "object" && candidate.artwork) {
      candidate = candidate.artwork;
    }
    const normalized = normalizeArtwork(candidate);
    if (!normalized) {
      return {
        ok: false,
        error:
          "The JSON is missing required fields (id, title, width, height, palette, cells).",
      };
    }
    return { ok: true, artwork: normalized };
  } catch (err) {
    return {
      ok: false,
      error: err instanceof Error ? err.message : "Unable to parse the JSON payload.",
    };
  }
}

function loadArtworks() {
  try {
    const raw = localStorage.getItem(ARTWORKS_KEY);
    if (!raw) return getStarterArtworks();
    const parsed = JSON.parse(raw);
    const normalized = (Array.isArray(parsed) ? parsed : [])
      .map((art) => normalizeArtwork(art))
      .filter(Boolean);
    return normalized.length ? normalized : getStarterArtworks();
  } catch (err) {
    return getStarterArtworks();
  }
}

function persistArtworks(list) {
  try {
    localStorage.setItem(ARTWORKS_KEY, JSON.stringify(list));
  } catch (err) {}
}

function loadActiveArtworkId(artworks) {
  try {
    const stored = localStorage.getItem(ACTIVE_ART_KEY);
    if (!stored) return artworks?.[0]?.id ?? null;
    return artworks?.some((art) => art.id === stored) ? stored : artworks?.[0]?.id ?? null;
  } catch (err) {
    return artworks?.[0]?.id ?? null;
  }
}

function persistActiveArtworkId(id) {
  try {
    if (id) {
      localStorage.setItem(ACTIVE_ART_KEY, id);
    } else {
      localStorage.removeItem(ACTIVE_ART_KEY);
    }
  } catch (err) {}
}

const DEFAULT_CONFIG = {
  enableAutosave: true,
  autoAdvanceOnComplete: true,
  enableHintPulse: true,
  enableEyedropper: true,
  enableKeyboardShortcuts: true,
  showNumberBadges: true,
  showHeatmapDots: true,
  enableSmokeHud: true,
  showColorLabels: true,
  showRemainingCounts: true,
  peekHoldToReveal: true,
};

const CONFIG_KEY = "capybooper_config";

function loadConfig() {
  try {
    const raw = localStorage.getItem(CONFIG_KEY);
    if (!raw) return DEFAULT_CONFIG;
    const parsed = JSON.parse(raw);
    return { ...DEFAULT_CONFIG, ...parsed };
  } catch (err) {
    return DEFAULT_CONFIG;
  }
}

function persistConfig(next) {
  try {
    localStorage.setItem(CONFIG_KEY, JSON.stringify(next));
  } catch (err) {}
}

function shallowEqual(a, b) {
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) return false;
  for (const key of keysA) if (a[key] !== b[key]) return false;
  return true;
}

function loadSave(art) {
  if (!art) return undefined;
  try {
    const raw = localStorage.getItem(SAVE_KEY(art.id));
    if (!raw) return undefined;
    const s = JSON.parse(raw);
    if (s.artworkId !== art.id) return undefined;
    return s;
  } catch (err) {
    return undefined;
  }
}

function persistSave(art, s) {
  if (!art) return;
  try {
    localStorage.setItem(SAVE_KEY(art.id), JSON.stringify(s));
  } catch (err) {}
}

function clearSave(artId) {
  try {
    localStorage.removeItem(SAVE_KEY(artId));
  } catch (err) {}
}

function computeRemaining(art, filled) {
  if (!art) return {};
  const map = {};
  for (const p of art.palette) map[p.id] = 0;
  for (const c of art.cells) if (!filled[c.id]) map[c.colorId] = (map[c.colorId] ?? 0) + 1;
  return map;
}

// ---------- App ----------
function App() {
  const initialConfig = useMemo(() => loadConfig(), []);
  const initialArtworksRef = useRef(null);

  if (initialArtworksRef.current === null) {
    initialArtworksRef.current = loadArtworks();
  }

  const [artworks, setArtworks] = useState(initialArtworksRef.current);
  const [activeArtworkId, setActiveArtworkIdState] = useState(() =>
    loadActiveArtworkId(initialArtworksRef.current)
  );
  const [config, setConfig] = useState(initialConfig);
  const isDefaultConfig = useMemo(() => shallowEqual(config, DEFAULT_CONFIG), [config]);

  const art = useMemo(() => {
    const match = artworks.find((entry) => entry.id === activeArtworkId);
    return match ?? artworks[0] ?? null;
  }, [artworks, activeArtworkId]);

  const [filled, setFilled] = useState({});
  const [activeColor, setActiveColor] = useState(art?.palette?.[0]?.id ?? null);
  const [scale, setScale] = useState(0.9);
  const [offset, setOffset] = useState({ x: 50, y: 50 });
  const [lastAction, setLastAction] = useState(null);
  const [hintPulse, setHintPulse] = useState(new Set());
  const [showTests, setShowTests] = useState(initialConfig.enableSmokeHud);
  const [showOptions, setShowOptions] = useState(false);
  const [showHelp, setShowHelp] = useState(false);
  const [isPeekActive, setIsPeekActive] = useState(false);
  const [showLibrary, setShowLibrary] = useState(false);
  const [libraryRevision, setLibraryRevision] = useState(0);

  const selectArtwork = useCallback((id) => {
    setActiveArtworkIdState(id);
    persistActiveArtworkId(id ?? null);
  }, []);

  useEffect(() => {
    persistArtworks(artworks);
  }, [artworks]);

  useEffect(() => {
    if (!artworks.length) {
      selectArtwork(null);
      return;
    }
    if (!artworks.some((entry) => entry.id === activeArtworkId)) {
      selectArtwork(artworks[0].id);
    }
  }, [artworks, activeArtworkId, selectArtwork]);

  useEffect(() => {
    if (!art) {
      setFilled({});
      setActiveColor(null);
      setScale(0.9);
      setOffset({ x: 50, y: 50 });
      setLastAction(null);
      setHintPulse(new Set());
      setIsPeekActive(false);
      return;
    }
    const saved = loadSave(art);
    setFilled(saved?.filled ?? {});
    setActiveColor(saved?.activeColor ?? art.palette?.[0]?.id ?? null);
    setScale(saved?.viewport?.scale ?? 0.9);
    setOffset({
      x: saved?.viewport?.x ?? 50,
      y: saved?.viewport?.y ?? 50,
    });
    setLastAction(null);
    setHintPulse(new Set());
    setIsPeekActive(false);
  }, [art?.id]);

  const {
    enableAutosave,
    autoAdvanceOnComplete,
    enableHintPulse,
    enableEyedropper,
    enableKeyboardShortcuts,
    showNumberBadges,
    showHeatmapDots,
    enableSmokeHud,
    showColorLabels,
    showRemainingCounts,
    peekHoldToReveal,
  } = config;

  useEffect(() => {
    if (peekHoldToReveal) setIsPeekActive(false);
  }, [peekHoldToReveal]);

  useEffect(() => {
    if (isPeekActive) {
      pendingPaintRef.current = null;
      dragIntentRef.current = "idle";
    }
  }, [isPeekActive]);

  useEffect(() => {
    if (!enableAutosave || !art) return;
    const t = setTimeout(() => {
      persistSave(art, {
        artworkId: art.id,
        filled,
        activeColor,
        viewport: { scale, x: offset.x, y: offset.y },
        lastSaved: Date.now(),
      });
    }, 800);
    return () => clearTimeout(t);
  }, [art, filled, activeColor, scale, offset, enableAutosave]);

  const remaining = useMemo(() => computeRemaining(art, filled), [art, filled]);
  const totalCells = art?.cells?.length ?? 0;
  const filledCount = Object.values(filled).filter(Boolean).length;
  const progress = totalCells > 0 ? Math.round((filledCount / totalCells) * 100) : 0;

  const libraryProgress = useMemo(() => {
    const map = {};
    artworks.forEach((entry) => {
      if (!entry) return;
      if (art && entry.id === art.id) {
        map[entry.id] = progress;
        return;
      }
      const total = entry.cells?.length ?? 0;
      const saved = loadSave(entry);
      if (!saved) {
        map[entry.id] = 0;
        return;
      }
      const count = Object.values(saved.filled ?? {}).filter(Boolean).length;
      map[entry.id] = total > 0 ? Math.round((count / total) * 100) : 0;
    });
    return map;
  }, [artworks, art?.id, progress, libraryRevision]);


  const peekHoldMode = peekHoldToReveal;
  const startPeek = useCallback(() => setIsPeekActive(true), []);
  const stopPeek = useCallback(() => setIsPeekActive(false), []);
  const togglePeek = useCallback(() => setIsPeekActive((prev) => !prev), []);

  const peekButtonTitle = peekHoldMode
    ? "Hold to peek at the completed painting"
    : isPeekActive
    ? "Hide the completed painting preview"
    : "Show the completed painting preview";

  const peekButtonHandlers = peekHoldMode
    ? {
        onPointerDown: (e) => {
          if (e.pointerType === "mouse" && e.button !== 0) return;
          e.preventDefault();
          e.currentTarget.setPointerCapture?.(e.pointerId);
          startPeek();
        },
        onPointerUp: (e) => {
          e.currentTarget.releasePointerCapture?.(e.pointerId);
          stopPeek();
        },
        onPointerLeave: () => stopPeek(),
        onPointerCancel: () => stopPeek(),
        onBlur: () => stopPeek(),
        onKeyDown: (e) => {
          if (e.key === " " || e.key === "Enter") {
            e.preventDefault();
            startPeek();
          }
        },
        onKeyUp: (e) => {
          if (e.key === " " || e.key === "Enter") {
            e.preventDefault();
            stopPeek();
          }
        },
      }
    : {
        onClick: () => togglePeek(),
      };

  const peekButtonProps = Object.assign(
    {
      type: "button",
      style: {
        ...styles.controlButton,
        ...(isPeekActive ? styles.controlButtonActive : {}),
      },
      title: peekButtonTitle,
      "aria-label": peekButtonTitle,
    },
    peekHoldMode ? {} : { "aria-pressed": isPeekActive },
    peekButtonHandlers
  );

  const handleImportArtwork = useCallback(
    (raw, meta = {}) => {
      const result = parseArtworkPayload(typeof raw === "string" ? raw : "", meta);
      if (!result.ok || !result.artwork) {
        return result;
      }
      const normalized = result.artwork;
      const existingIds = new Set(artworks.map((item) => item.id));
      const baseId = normalized.id || `art-${Math.random().toString(36).slice(2, 8)}`;
      let uniqueId = baseId;
      let suffix = 2;
      while (existingIds.has(uniqueId)) {
        uniqueId = `${baseId}-${suffix++}`;
      }
      const finalArtwork = cloneArtwork({ ...normalized, id: uniqueId });
      setArtworks((prev) => [...prev, finalArtwork]);
      selectArtwork(finalArtwork.id);
      setLibraryRevision((v) => v + 1);
      return { ok: true, artwork: finalArtwork };
    },
    [artworks, selectArtwork]
  );

  const handleDeleteArtwork = useCallback(
    (id) => {
      setArtworks((prev) => {
        const next = prev.filter((entry) => entry.id !== id);
        if (!next.length) {
          selectArtwork(null);
          return [];
        }
        if (!next.some((entry) => entry.id === activeArtworkId)) {
          selectArtwork(next[0].id);
        }
        return next;
      });
      clearSave(id);
      setLibraryRevision((v) => v + 1);
      if (art && art.id === id) {
        setFilled({});
        setActiveColor(null);
        setScale(0.9);
        setOffset({ x: 50, y: 50 });
        setLastAction(null);
        setHintPulse(new Set());
        setShowLibrary(true);
      }
    },
    [art, activeArtworkId, selectArtwork, setShowLibrary]
  );

  const handleRenameArtwork = useCallback((id, nextTitle) => {
    const title = (nextTitle ?? "").trim() || "Untitled artwork";
    setArtworks((prev) => prev.map((entry) => (entry.id === id ? { ...entry, title } : entry)));
  }, []);

  const handleClearProgress = useCallback(
    (id) => {
      clearSave(id);
      setLibraryRevision((v) => v + 1);
      if (art && art.id === id) {
        setFilled({});
        setActiveColor(art.palette?.[0]?.id ?? null);
        setScale(0.9);
        setOffset({ x: 50, y: 50 });
        setLastAction(null);
        setHintPulse(new Set());
      }
    },
    [art]
  );

  const previousSmokePreferenceRef = useRef(initialConfig.enableSmokeHud);

  useEffect(() => {
    if (!enableSmokeHud) {
      previousSmokePreferenceRef.current = showTests;
      setShowTests(false);
    } else {
      setShowTests((prev) => prev || previousSmokePreferenceRef.current);
    }
  }, [enableSmokeHud, showTests]);

  useEffect(() => {
    if (!showOptions) return;
    function onKeyDown(e) {
      if (e.key === "Escape") setShowOptions(false);
    }
    window.addEventListener("keydown", onKeyDown);
    return () => window.removeEventListener("keydown", onKeyDown);
  }, [showOptions]);

  const svgRef = useRef(null);
  const isPanningRef = useRef(false);
  const lastPosRef = useRef(null);
  const movedRef = useRef(0);
  const eyedropCandidateRef = useRef(null);
  const pointersRef = useRef(new Map());
  const pinchRef = useRef(null);
  const zoomAnimRef = useRef(null);
  const dragIntentRef = useRef("idle");
  const pendingPaintRef = useRef(null);
  const pointerOriginRef = useRef(null);
  const PAN_DRAG_THRESHOLD = 8;

  function beginPan(clientX, clientY) {
    pendingPaintRef.current = null;
    dragIntentRef.current = "pan";
    isPanningRef.current = true;
    lastPosRef.current = { x: clientX, y: clientY };
    pointerOriginRef.current = null;
  }

  const cancelZoomAnimation = useCallback(() => {
    if (zoomAnimRef.current) {
      cancelAnimationFrame(zoomAnimRef.current);
      zoomAnimRef.current = null;
    }
  }, []);

  const smoothZoomTo = useCallback(
    (targetScale, clientX, clientY) => {
      if (!art) return;
      const svg = svgRef.current;
      if (!svg) return;
      const { pxArt, pyArt } = cssToArt(svg, clientX, clientY);
      const artX = (pxArt - offset.x) / scale;
      const artY = (pyArt - offset.y) / scale;
      const clamped = clamp(targetScale, 0.3, 4);
      const targetOffset = {
        x: pxArt - artX * clamped,
        y: pyArt - artY * clamped,
      };
      cancelZoomAnimation();
      const duration = 180;
      const start = performance.now();
      const startScale = scale;
      const startOffset = { x: offset.x, y: offset.y };

      function step(now) {
        const t = Math.min((now - start) / duration, 1);
        const eased = 1 - Math.pow(1 - t, 3);
        const nextScale = startScale + (clamped - startScale) * eased;
        const nextOffset = {
          x: startOffset.x + (targetOffset.x - startOffset.x) * eased,
          y: startOffset.y + (targetOffset.y - startOffset.y) * eased,
        };
        setScale(nextScale);
        setOffset(nextOffset);
        if (t < 1) {
          zoomAnimRef.current = requestAnimationFrame(step);
        } else {
          zoomAnimRef.current = null;
        }
      }

      if (Math.abs(clamped - startScale) < 1e-3) {
        setScale(clamped);
        setOffset(targetOffset);
        return;
      }

      zoomAnimRef.current = requestAnimationFrame(step);
    },
    [art, cancelZoomAnimation, offset.x, offset.y, scale]
  );

  useEffect(() => {
    return () => cancelZoomAnimation();
  }, [cancelZoomAnimation]);

  function cssToArt(svg, clientX, clientY) {
    if (!art) return { pxArt: 0, pyArt: 0 };
    const rect = svg.getBoundingClientRect();
    const sx = art.width / rect.width;
    const sy = art.height / rect.height;
    const pxArt = (clientX - rect.left) * sx;
    const pyArt = (clientY - rect.top) * sy;
    return { pxArt, pyArt };
  }

  function onWheel(e) {
    if (!art) return;
    e.preventDefault();
    const svg = svgRef.current;
    if (!svg) return;
    let delta = e.deltaY;
    if (e.deltaMode === 1) delta *= 16;
    if (e.deltaMode === 2) delta *= 240;
    const factor = Math.exp(-delta * 0.0012);
    const targetScale = clamp(scale * factor, 0.2, 6);
    smoothZoomTo(targetScale, e.clientX, e.clientY);
  }

  function onPointerDown(e) {
    if (!art) return;
    if (isPeekActive) {
      e.preventDefault?.();
      return;
    }
    const svg = svgRef.current;
    svg?.setPointerCapture?.(e.pointerId);
    pointersRef.current.set(e.pointerId, { x: e.clientX, y: e.clientY });

    dragIntentRef.current = "idle";
    pendingPaintRef.current = null;
    pointerOriginRef.current = { x: e.clientX, y: e.clientY };
    movedRef.current = 0;
    eyedropCandidateRef.current = null;

    const target = e.target;
    const cid = target?.dataset?.cellId;

    if (e.pointerType === "mouse" && (e.button === 2 || e.button === 1 || e.ctrlKey)) {
      e.preventDefault();
      cancelZoomAnimation();
      beginPan(e.clientX, e.clientY);
      return;
    }

    if (pointersRef.current.size === 2 && !pinchRef.current) {
      cancelZoomAnimation();
      const ids = Array.from(pointersRef.current.keys());
      const p1 = pointersRef.current.get(ids[0]);
      const p2 = pointersRef.current.get(ids[1]);
      const d0 = Math.hypot(p2.x - p1.x, p2.y - p1.y);
      const mid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      pinchRef.current = { id1: ids[0], id2: ids[1], d0, s0: scale, mid0: mid };
      dragIntentRef.current = "pinch";
      isPanningRef.current = false;
      pointerOriginRef.current = null;
      return;
    }

    if (cid) {
      cancelZoomAnimation();
      const already = !!filled[cid];
      if (already) {
        eyedropCandidateRef.current = enableEyedropper ? cid : null;
        beginPan(e.clientX, e.clientY);
        return;
      }
      dragIntentRef.current = "pending-paint";
      pendingPaintRef.current = cid;
      isPanningRef.current = false;
      return;
    }
    cancelZoomAnimation();
    beginPan(e.clientX, e.clientY);
  }

  function onPointerMove(e) {
    if (!art) return;
    if (isPeekActive) return;
    const svg = svgRef.current;
    pointersRef.current.set(e.pointerId, { x: e.clientX, y: e.clientY });

    if (dragIntentRef.current === "pending-paint" && pointerOriginRef.current) {
      const dx = e.clientX - pointerOriginRef.current.x;
      const dy = e.clientY - pointerOriginRef.current.y;
      if (Math.hypot(dx, dy) > PAN_DRAG_THRESHOLD) beginPan(e.clientX, e.clientY);
    }

    if (pinchRef.current) {
      const { id1, id2, d0, s0, mid0 } = pinchRef.current;
      const p1 = pointersRef.current.get(id1);
      const p2 = pointersRef.current.get(id2);
      if (p1 && p2) {
        const d = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        const factor = d0 > 0 ? d / d0 : 1;
        const newScale = clamp(s0 * factor, 0.3, 4);
        const { pxArt, pyArt } = cssToArt(svg, mid0.x, mid0.y);
        const artX = (pxArt - offset.x) / scale;
        const artY = (pyArt - offset.y) / scale;
        setOffset({ x: pxArt - artX * newScale, y: pyArt - artY * newScale });
        setScale(newScale);
      }
      return;
    }

    if (isPanningRef.current && lastPosRef.current) {
      const rect = svg.getBoundingClientRect();
      const sx = art.width / rect.width;
      const sy = art.height / rect.height;
      const dxPx = e.clientX - lastPosRef.current.x;
      const dyPx = e.clientY - lastPosRef.current.y;
      movedRef.current += Math.hypot(dxPx, dyPx);
      lastPosRef.current = { x: e.clientX, y: e.clientY };
      setOffset((o) => ({ x: o.x + dxPx * sx, y: o.y + dyPx * sy }));
    }
  }

  function onPointerUp(e) {
    if (!art) return;
    if (isPeekActive) return;
    const svg = svgRef.current;
    svg?.releasePointerCapture?.(e.pointerId);

    if (pendingPaintRef.current && dragIntentRef.current === "pending-paint") {
      onCellTap(pendingPaintRef.current);
    }

    if (enableEyedropper && eyedropCandidateRef.current && movedRef.current < 6) {
      const cell = art.cells.find((c) => c.id === eyedropCandidateRef.current);
      if (cell && (remaining[cell.colorId] ?? 0) > 0) setActiveColor(cell.colorId);
    }

    pointersRef.current.delete(e.pointerId);
    if (pinchRef.current && (e.pointerId === pinchRef.current.id1 || e.pointerId === pinchRef.current.id2)) {
      pinchRef.current = null;
    }

    dragIntentRef.current = "idle";
    pendingPaintRef.current = null;
    pointerOriginRef.current = null;
    isPanningRef.current = false;
    lastPosRef.current = null;
    eyedropCandidateRef.current = null;
    movedRef.current = 0;
  }

  function onCellTap(cellId) {
    if (!art || activeColor == null) return;
    const cell = art.cells.find((c) => c.id === cellId);
    if (!cell) return;

    if (filled[cellId]) return;

    if (cell.colorId !== activeColor) {
      const el = document.getElementById(cellId);
      if (el) {
        el.setAttribute("stroke", "#d22");
        el.setAttribute("stroke-width", "4");
        setTimeout(() => {
          el.setAttribute("stroke", "#444");
          el.setAttribute("stroke-width", "2");
        }, 220);
      }
      return;
    }

    const willCompleteColor = (remaining[activeColor] ?? 0) === 1;
    setFilled((prev) => ({ ...prev, [cellId]: true }));
    setLastAction(cellId);
    if (willCompleteColor && autoAdvanceOnComplete) nextColor();
  }

  function undo() {
    if (!lastAction) return;
    setFilled((prev) => ({ ...prev, [lastAction]: false }));
    setLastAction(null);
  }

  function hint() {
    if (!enableHintPulse || !art || activeColor == null) return;
    const candidates = art.cells
      .filter((c) => c.colorId === activeColor && !filled[c.id])
      .sort((a, b) => (a.area ?? 0) - (b.area ?? 0))
      .slice(0, 3);
    const ids = new Set(candidates.map((c) => c.id));
    setHintPulse(ids);
    setTimeout(() => setHintPulse(new Set()), 1000);
  }

  function resetView() {
    setScale(0.9);
    setOffset({ x: 50, y: 50 });
  }

  function nextColor() {
    if (!art || activeColor == null) return;
    const order = art.palette.map((p) => p.id);
    const startIdx = order.indexOf(activeColor);
    for (let i = 1; i <= order.length; i++) {
      const id = order[(startIdx + i) % order.length];
      if ((remaining[id] ?? 0) > 0) {
        setActiveColor(id);
        return;
      }
    }
  }

  function handleConfigChange(key, value) {
    setConfig((prev) => {
      if (prev[key] === value) return prev;
      const next = { ...prev, [key]: value };
      persistConfig(next);
      return next;
    });
  }

  function handleConfigReset() {
    setConfig((prev) => {
      if (shallowEqual(prev, DEFAULT_CONFIG)) return prev;
      persistConfig(DEFAULT_CONFIG);
      return DEFAULT_CONFIG;
    });
    previousSmokePreferenceRef.current = DEFAULT_CONFIG.enableSmokeHud;
    setShowTests(DEFAULT_CONFIG.enableSmokeHud);
  }

  useEffect(() => {
    if (!enableKeyboardShortcuts) return;
    function onKey(e) {
      const lower = e.key.toLowerCase();
      if (e.key === "0") resetView();
      if (e.key === "+" || e.key === "=") setScale((s) => clamp(s * 1.1, 0.3, 4));
      if (e.key === "-" || e.key === "_") setScale((s) => clamp(s / 1.1, 0.3, 4));
      if (lower === "h") hint();
      if (lower === "n") nextColor();
      if (lower === "u") undo();
      if (lower === "t" && enableSmokeHud) setShowTests((v) => !v);
      if (e.key === "Escape") {
        if (showOptions) setShowOptions(false);
        if (showHelp) setShowHelp(false);
        if (showLibrary) setShowLibrary(false);
      }
      if (!art) return;
      const panStep = 80 / (scale || 1);
      if (lower === "w" || e.key === "ArrowUp") {
        e.preventDefault();
        setOffset((prev) => ({ ...prev, y: prev.y + panStep }));
      }
      if (lower === "s" || e.key === "ArrowDown") {
        e.preventDefault();
        setOffset((prev) => ({ ...prev, y: prev.y - panStep }));
      }
      if (lower === "a" || e.key === "ArrowLeft") {
        e.preventDefault();
        setOffset((prev) => ({ ...prev, x: prev.x + panStep }));
      }
      if (lower === "d" || e.key === "ArrowRight") {
        e.preventDefault();
        setOffset((prev) => ({ ...prev, x: prev.x - panStep }));
      }
    }
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [art, enableKeyboardShortcuts, enableSmokeHud, showOptions, showHelp, showLibrary, scale]);
  return (
    React.createElement(
      "div",
      { style: styles.app },
      showLibrary &&
        React.createElement(ArtLibrary, {
          artworks: artworks,
          activeArtworkId: activeArtworkId,
          progressMap: libraryProgress,
          onSelect: (id) => {
            selectArtwork(id);
            setShowLibrary(false);
          },
          onClose: () => setShowLibrary(false),
          onImport: handleImportArtwork,
          onDelete: handleDeleteArtwork,
          onRename: handleRenameArtwork,
          onClearProgress: handleClearProgress,
        }),
      showHelp &&
        React.createElement(HelpPanel, {
          art: art,
          progress: progress,
          activeColor: activeColor,
          filled: filled,
          onClose: () => setShowHelp(false),
        }),
      showOptions &&
        React.createElement(OptionsPanel, {
          config: config,
          onToggle: handleConfigChange,
          canReset: !isDefaultConfig,
          onReset: handleConfigReset,
          onClose: () => setShowOptions(false),
        }),
      art
        ? React.createElement(
            "div",
            { style: styles.canvas },
            React.createElement(
              "svg",
              {
                ref: svgRef,
                width: "100%",
                height: "100%",
                viewBox: `0 0 ${art.width} ${art.height}`,
                style: {
                  background: "#0f172a",
                  touchAction: "none",
                  userSelect: "none",
                  WebkitUserSelect: "none",
                },
                onWheel: onWheel,
                onPointerDown: onPointerDown,
                onPointerMove: onPointerMove,
                onPointerUp: onPointerUp,
                onContextMenu: (e) => e.preventDefault(),
              },
              React.createElement(
                "g",
                { transform: `translate(${offset.x} ${offset.y}) scale(${scale})` },
                React.createElement("rect", {
                  x: 0,
                  y: 0,
                  width: art.width,
                  height: art.height,
                  fill: "#0f172a",
                  stroke: "#1e293b",
                }),
                art.cells.map((c) => {
                  const isFilled = !!filled[c.id];
                  const pal = art.palette.find((p) => p.id === c.colorId);
                  const showPulse = hintPulse.has(c.id);
                  const shouldShowFill = isFilled || isPeekActive;
                  const fillOpacity = isFilled ? 1 : 0.75;
                  const strokeColor = showPulse
                    ? "#f2c200"
                    : isPeekActive
                    ? "rgba(148, 163, 184, 0.6)"
                    : "#334155";
                  const strokeWidth = showPulse ? 4 : isPeekActive ? 1.6 : 2;
                  const baseFill = isFilled
                    ? "transparent"
                    : isPeekActive
                    ? "rgba(15, 23, 42, 0.2)"
                    : "#0f172a";
                  return React.createElement(
                    "g",
                    { key: c.id },
                    React.createElement(
                      "title",
                      null,
                      `Region ${c.id} - Color #${c.colorId}${pal?.name ? ` (${pal.name})` : ""}`
                    ),
                    shouldShowFill &&
                      React.createElement("path", {
                        d: c.d,
                        fill: pal?.rgba,
                        pointerEvents: "none",
                        opacity: fillOpacity,
                      }),
                    React.createElement("path", {
                      id: c.id,
                      "data-cell-id": c.id,
                      "data-color-id": c.colorId,
                      d: c.d,
                      fill: baseFill,
                      stroke: strokeColor,
                      strokeWidth: strokeWidth,
                      style: {
                        cursor: isFilled ? "grab" : "pointer",
                        opacity: isFilled ? 0.35 : 1,
                      },
                      "aria-label": `Cell ${c.id}. Target color ${c.colorId}. ${isFilled ? "Filled" : "Unfilled"}`,
                    }),
                    !isPeekActive &&
                      !isFilled &&
                      showNumberBadges &&
                      scale >= 0.6 &&
                      React.createElement(NumberLabel, {
                        d: c.d,
                        text: `${c.colorId}`,
                        area: c.area,
                      }),
                    !isPeekActive &&
                      !isFilled &&
                      showHeatmapDots &&
                      scale < 0.6 &&
                      React.createElement(HeatDot, { d: c.d })
                  );
                })
              )
            )
          )
        : React.createElement(
            "div",
            { style: styles.emptyState },
            "Import or add an artwork in the library to start painting."
          ),
      art &&
        enableSmokeHud &&
        showTests &&
        React.createElement(SmokeTests, { art: art, filled: filled }),
      art &&
        React.createElement(
          "header",
          { style: styles.topBar, role: "banner" },
          React.createElement(
            "div",
            { style: styles.topContext },
            React.createElement("span", { style: styles.topTitle }, art.title),
            React.createElement(
              "span",
              {
                style: styles.topProgress,
                "data-testid": "progress-indicator",
                title: `${progress}% complete`,
                "aria-label": `${progress}% complete`,
                "aria-live": "polite",
              },
              `${progress}%`
            )
          ),
          React.createElement(
            "nav",
            { style: styles.topActions, "aria-label": "Canvas controls" },
            React.createElement(
              "button",
              {
                type: "button",
                style: styles.controlButton,
                onClick: () => {
                  setShowHelp(false);
                  setShowOptions(false);
                  setShowLibrary(true);
                },
                title: "Open art library",
                "aria-label": "Open art library",
                "data-testid": "open-art-library",
              },
              "Library"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: styles.controlButton,
                onClick: () => {
                  setShowHelp(false);
                  setShowOptions(true);
                },
                title: "Adjust options",
                "aria-label": "Adjust options",
              },
              "Options"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: styles.controlButton,
                onClick: () => {
                  setShowOptions(false);
                  setShowHelp(true);
                },
                title: "Open help",
                "aria-label": "Open help",
              },
              "Help"
            ),
            React.createElement("button", peekButtonProps, "Peek"),
            React.createElement(
              "button",
              {
                type: "button",
                style: styles.controlButton,
                onClick: resetView,
                title: "Reset view",
                "aria-label": "Reset view",
              },
              "Reset"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: styles.controlButton,
                onClick: undo,
                title: "Undo last fill",
                "aria-label": "Undo last fill",
              },
              "Undo"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: {
                  ...styles.controlButton,
                  opacity: enableHintPulse ? 1 : 0.45,
                  cursor: enableHintPulse ? "pointer" : "not-allowed",
                },
                onClick: hint,
                title: "Highlight a suggested cell",
                disabled: !enableHintPulse,
                "aria-label": "Highlight a suggested cell",
              },
              "Hint"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: styles.controlButton,
                onClick: nextColor,
                title: "Jump to the next color",
                "aria-label": "Jump to the next color",
              },
              "Next"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: {
                  ...styles.controlButton,
                  opacity: enableSmokeHud ? 1 : 0.45,
                  cursor: enableSmokeHud ? "pointer" : "not-allowed",
                },
                onClick: () => enableSmokeHud && setShowTests((v) => !v),
                title: "Toggle the smoke test HUD",
                disabled: !enableSmokeHud,
                "aria-pressed": showTests,
                "aria-label": "Toggle the smoke test HUD",
              },
              "Tests"
            )
          )
        ),
      art &&
        React.createElement(
          "div",
          { style: styles.paletteDock, "data-testid": "palette-dock" },
          React.createElement(Palette, {
            palette: art.palette,
            remaining: remaining,
            activeColor: activeColor,
            onSelect: setActiveColor,
            showLabels: showColorLabels,
            showRemaining: showRemainingCounts,
          })
        )
    )
  );
}

// ---------- Helpers: Number label & heat dot ----------

function ensureMeasureSvg() {
  if (typeof document === "undefined") return null;
  if (!measureSvgEl) {
    const svg = document.createElementNS(SVG_NS, "svg");
    svg.setAttribute("aria-hidden", "true");
    svg.setAttribute("width", "0");
    svg.setAttribute("height", "0");
    svg.style.position = "absolute";
    svg.style.width = "0";
    svg.style.height = "0";
    svg.style.opacity = "0";
    svg.style.pointerEvents = "none";
    document.body.appendChild(svg);
    measureSvgEl = svg;
  }
  return measureSvgEl;
}

function ensureMeasureContext() {
  if (typeof document === "undefined") return null;
  if (!measureCanvasCtx) {
    const canvas = document.createElement("canvas");
    canvas.width = canvas.height = 1;
    measureCanvasCtx = canvas.getContext("2d");
  }
  return measureCanvasCtx;
}

function measurePathBox(d) {
  if (pathBoxCache.has(d)) return pathBoxCache.get(d);
  const host = ensureMeasureSvg();
  if (!host) return null;
  try {
    const path = document.createElementNS(SVG_NS, "path");
    path.setAttribute("d", d);
    host.appendChild(path);
    const box = path.getBBox();
    host.removeChild(path);
    pathBoxCache.set(d, box);
    return box;
  } catch (err) {
    return null;
  }
}

function measurePathArea(d, bbox) {
  if (pathAreaCache.has(d)) return pathAreaCache.get(d);
  const ctx = ensureMeasureContext();
  if (!ctx || !bbox) return null;
  if (typeof Path2D === "undefined") return null;
  let path;
  try {
    path = new Path2D(d);
  } catch (err) {
    return null;
  }

  const longest = Math.max(bbox.width, bbox.height);
  const steps = Math.max(12, Math.min(80, Math.ceil(longest / 8)));
  if (!Number.isFinite(steps) || steps <= 0) return null;

  const stepX = bbox.width / steps;
  const stepY = bbox.height / steps;
  if (!Number.isFinite(stepX) || !Number.isFinite(stepY)) return null;

  let inside = 0;
  const total = steps * steps;
  const originX = bbox.x + stepX / 2;
  const originY = bbox.y + stepY / 2;

  for (let ix = 0; ix < steps; ix++) {
    const x = originX + ix * stepX;
    for (let iy = 0; iy < steps; iy++) {
      const y = originY + iy * stepY;
      if (ctx.isPointInPath(path, x, y)) inside++;
    }
  }

  if (inside === 0) return null;
  const area = (inside / total) * bbox.width * bbox.height;
  pathAreaCache.set(d, area);
  return area;
}

function findInteriorPoint(d, fallback, bbox) {
  const ctx = ensureMeasureContext();
  if (!ctx) return fallback;
  if (typeof Path2D === "undefined") return fallback;
  let path;
  try {
    path = new Path2D(d);
  } catch (err) {
    return fallback;
  }

  const cached = interiorPointCache.get(d);
  if (cached && ctx.isPointInPath(path, cached.x, cached.y)) {
    return cached;
  }

  const center = bbox
    ? { x: bbox.x + bbox.width / 2, y: bbox.y + bbox.height / 2 }
    : fallback;
  const candidates = [fallback];
  if (bbox) {
    candidates.push(
      center,
      { x: bbox.x + bbox.width * 0.3, y: bbox.y + bbox.height * 0.5 },
      { x: bbox.x + bbox.width * 0.7, y: bbox.y + bbox.height * 0.5 },
      { x: bbox.x + bbox.width * 0.5, y: bbox.y + bbox.height * 0.3 },
      { x: bbox.x + bbox.width * 0.5, y: bbox.y + bbox.height * 0.7 }
    );
  }

  for (const candidate of candidates) {
    if (!candidate) continue;
    if (ctx.isPointInPath(path, candidate.x, candidate.y)) return candidate;
  }

  if (!bbox) return fallback;

  const centerX = bbox.x + bbox.width / 2;
  const centerY = bbox.y + bbox.height / 2;
  const longest = Math.max(bbox.width, bbox.height);
  const steps = Math.max(6, Math.ceil(longest / 60));
  const stepX = bbox.width / (steps + 1);
  const stepY = bbox.height / (steps + 1);

  let best = null;
  let bestScore = -Infinity;

  for (let i = 0; i <= steps; i++) {
    for (let j = 0; j <= steps; j++) {
      const x = bbox.x + (i + 0.5) * stepX;
      const y = bbox.y + (j + 0.5) * stepY;
      if (!ctx.isPointInPath(path, x, y)) continue;
      const dx = x - centerX;
      const dy = y - centerY;
      const score = -(dx * dx + dy * dy);
      if (score > bestScore) {
        best = { x, y };
        bestScore = score;
      }
    }
  }

  if (best) {
    interiorPointCache.set(d, best);
    return best;
  }

  const maxRadius = Math.hypot(bbox.width, bbox.height) / 2;
  const rings = Math.max(3, Math.ceil(longest / 45));
  const samplesPerRing = Math.max(12, Math.ceil(longest / 30));

  for (let r = 1; r <= rings; r++) {
    const radius = (r / rings) * maxRadius;
    for (let i = 0; i < samplesPerRing; i++) {
      const angle = (i / samplesPerRing) * Math.PI * 2;
      const x = centerX + Math.cos(angle) * radius;
      const y = centerY + Math.sin(angle) * radius;
      if (ctx.isPointInPath(path, x, y)) {
        const point = { x, y };
        interiorPointCache.set(d, point);
        return point;
      }
    }
  }

  if (fallback && ctx.isPointInPath(path, fallback.x, fallback.y)) {
    interiorPointCache.set(d, fallback);
  }
  return best ?? fallback;
}

function computeLabelMetrics(bbox, area) {
  const defaults = { radius: 16, fontSize: 24, showBubble: true };
  if (!bbox) return defaults;

  const minSide = Math.max(0, Math.min(bbox.width, bbox.height));
  if (minSide === 0) return defaults;

  const areaRadius = area && area > 0 ? Math.sqrt(area) / 14 : 0;
  let radius = Math.max(6, Math.min(18, Math.max(minSide / 2.6, areaRadius)));
  const maxRadius = Math.max(4, minSide / 2 - 1);
  radius = Math.min(radius, maxRadius);
  if (!Number.isFinite(radius) || radius <= 0) {
    radius = 10;
  }

  const showBubble = radius >= 6 && minSide >= 14;
  if (!showBubble) {
    const fontSize = Math.max(9, Math.min(16, minSide * 0.9));
    return { radius: 0, fontSize, showBubble };
  }

  const fontSize = Math.max(10, Math.min(20, radius * 1.35));
  return { radius, fontSize, showBubble };
}
function centroidFromPath(d) {
  const tokens = d.split(/[ ,]/).filter(Boolean);
  const pts = [];
  for (let i = 0; i < tokens.length; i++) {
    const t = tokens[i];
    if (t === "M" || t === "L" || t === "Z") continue;
    const n = Number(t);
    if (!Number.isNaN(n)) pts.push(n);
  }
  const xy = [];
  for (let i = 0; i + 1 < pts.length; i += 2) xy.push([pts[i], pts[i + 1]]);
  let cx = 0,
    cy = 0,
    a = 0;
  for (let i = 0; i < xy.length; i++) {
    const [x1, y1] = xy[i];
    const [x2, y2] = xy[(i + 1) % xy.length];
    const cross = x1 * y2 - x2 * y1;
    a += cross;
    cx += (x1 + x2) * cross;
    cy += (y1 + y2) * cross;
  }
  a *= 0.5;
  if (Math.abs(a) < 1e-5) return { x: xy[0]?.[0] ?? 0, y: xy[0]?.[1] ?? 0 };
  return { x: cx / (6 * a), y: cy / (6 * a) };
}

const pointAlmostEqual = (a, b) =>
  a === b || (a && b && Math.abs(a.x - b.x) < 0.01 && Math.abs(a.y - b.y) < 0.01);

const metricsAlmostEqual = (a, b) =>
  a === b ||
  (a &&
    b &&
    Math.abs(a.radius - b.radius) < 0.01 &&
    Math.abs(a.fontSize - b.fontSize) < 0.01 &&
    a.showBubble === b.showBubble);

function NumberLabel({ d, text, area }) {
  const fallback = useMemo(() => centroidFromPath(d), [d]);
  const [position, setPosition] = useState(fallback);
  const [metrics, setMetrics] = useState(() => ({ radius: 16, fontSize: 24, showBubble: true }));

  useLayoutEffect(() => {
    if (typeof document === "undefined") return;
    const bbox = measurePathBox(d);
    const nextPoint = findInteriorPoint(d, fallback, bbox);
    setPosition((prev) => (pointAlmostEqual(prev, nextPoint) ? prev : nextPoint));
    const measuredArea = measurePathArea(d, bbox);
    const areaHint = measuredArea ?? area;
    const nextMetrics = computeLabelMetrics(bbox, areaHint);
    setMetrics((prev) => (metricsAlmostEqual(prev, nextMetrics) ? prev : nextMetrics));
  }, [d, area, fallback.x, fallback.y]);

  const { x, y } = position;
  const { radius, fontSize, showBubble } = metrics;

  const textProps = {
    x,
    y,
    fontSize,
    textAnchor: "middle",
    dominantBaseline: "middle",
    fill: "#e2e8f0",
    fontFamily: "ui-sans-serif, system-ui",
  };

  if (!showBubble) {
    textProps.style = {
      paintOrder: "stroke",
      stroke: "rgba(15, 23, 42, 0.9)",
      strokeWidth: 3,
    };
  }

  return React.createElement(
    "g",
    { pointerEvents: "none" },
    showBubble &&
      React.createElement("circle", { cx: x, cy: y, r: radius, fill: "rgba(15, 23, 42, 0.9)" }),
    React.createElement("text", textProps, text)
  );
}

function HeatDot({ d }) {
  const { x, y } = centroidFromPath(d);
  return React.createElement("circle", { pointerEvents: "none", cx: x, cy: y, r: 6, fill: "#94a3b8" });
}

// ---------- Palette ----------
function Palette({
  palette,
  remaining,
  activeColor,
  onSelect,
  showLabels,
  showRemaining,
}) {
  return React.createElement(
    "div",
    { style: styles.paletteWrap },
    palette.map((p) => {
      const left = remaining[p.id] ?? 0;
      const isActive = p.id === activeColor;
      const label = p.name ?? `Color ${p.id}`;
      const statusText = left === 0 ? "Complete" : `${left} left`;
      const buttonStyle = {
        ...styles.swatch,
        background: p.rgba,
        border: isActive
          ? "2px solid rgba(248, 250, 252, 0.85)"
          : "2px solid rgba(15, 23, 42, 0.6)",
        boxShadow: isActive
          ? "0 0 0 4px rgba(148, 163, 184, 0.45), 0 10px 24px rgba(2, 6, 23, 0.55)"
          : "0 8px 18px rgba(2, 6, 23, 0.45)",
        opacity: left === 0 && !isActive ? 0.35 : 1,
      };
      return React.createElement(
        "div",
        { key: p.id, style: styles.swatchItem },
        React.createElement(
          "button",
          {
            type: "button",
            onClick: () => onSelect(p.id),
            disabled: left === 0 && !isActive,
            "aria-pressed": isActive,
            "aria-label": `${label}. ${statusText}`,
            title: `${label} - ${statusText}`,
            style: buttonStyle,
          },
          React.createElement("span", { style: styles.swatchNumber }, p.id)
        ),
        showLabels &&
          React.createElement("span", { style: styles.swatchName }, label),
        showRemaining &&
          React.createElement(
            "span",
            { style: styles.swatchRemaining },
            statusText
          )
      );
    })
  );
}

function ArtworkPreviewCard({ art, progress, isActive, onSelect }) {
  const paletteLookup = useMemo(() => {
    const map = new Map();
    (art.palette ?? []).forEach((entry) => {
      map.set(entry.id, entry.rgba || "#64748b");
    });
    return map;
  }, [art]);
  const handleSelect = useCallback(() => onSelect(art.id), [art.id, onSelect]);
  return React.createElement(
    "button",
    {
      type: "button",
      style: {
        ...styles.libraryCard,
        ...(isActive ? styles.libraryCardActive : {}),
      },
      onClick: handleSelect,
      title: isActive ? `${art.title} (active)` : `Load ${art.title}`,
      "aria-label": isActive ? `${art.title} (active)` : `Load ${art.title}`,
      "aria-pressed": isActive,
      "data-testid": "art-library-card",
      "data-artwork-id": art.id,
    },
    React.createElement(
      "div",
      { style: styles.libraryCardPreview },
      React.createElement(
        "svg",
        {
          viewBox: `0 0 ${art.width} ${art.height}`,
          style: styles.libraryCardSvg,
          role: "presentation",
          focusable: "false",
        },
        React.createElement("rect", {
          x: 0,
          y: 0,
          width: art.width,
          height: art.height,
          fill: "#0f172a",
          stroke: "rgba(148, 163, 184, 0.35)",
          strokeWidth: 2,
        }),
        art.cells.map((cell) =>
          React.createElement("path", {
            key: cell.id,
            d: cell.d,
            fill: paletteLookup.get(cell.colorId) || "#1e293b",
            stroke: "rgba(15, 23, 42, 0.55)",
            strokeWidth: 1.4,
          })
        )
      )
    ),
    React.createElement(
      "div",
      { style: styles.libraryCardBody },
      React.createElement("div", { style: styles.libraryCardTitle }, art.title),
      React.createElement(
        "div",
        { style: styles.libraryCardMeta },
        `${progress}% complete • ${art.palette.length} colors`
      )
    )
  );
}

function ArtLibrary({
  artworks,
  activeArtworkId,
  progressMap,
  onSelect,
  onClose,
  onImport,
  onDelete,
  onRename,
  onClearProgress,
}) {
  const [draft, setDraft] = useState("");
  const [feedback, setFeedback] = useState(null);
  const [editingId, setEditingId] = useState(null);
  const [titleDraft, setTitleDraft] = useState("");
  const [promptStatus, setPromptStatus] = useState(null);
  const promptTimerRef = useRef(null);

  const sorted = useMemo(
    () => [...artworks].sort((a, b) => a.title.localeCompare(b.title)),
    [artworks]
  );
  const hasArtworks = sorted.length > 0;

  useEffect(() => {
    function handleKey(e) {
      if (e.key === "Escape") onClose();
    }
    window.addEventListener("keydown", handleKey);
    return () => window.removeEventListener("keydown", handleKey);
  }, [onClose]);

  useEffect(() => {
    return () => {
      if (promptTimerRef.current) clearTimeout(promptTimerRef.current);
    };
  }, []);

  const promptText = `You are an SVG color-by-number generator. Produce JSON with keys: id (short slug), title, width, height, palette (array of { id, name, rgba }), and cells (array of { id, colorId, d } path commands using only M/L/Z). Ensure 40-80 cells and 6-12 palette entries. Colors should be polished and themed. Return JSON only.`;

  function schedulePromptStatus(status) {
    setPromptStatus(status);
    if (promptTimerRef.current) {
      clearTimeout(promptTimerRef.current);
    }
    promptTimerRef.current = setTimeout(() => setPromptStatus(null), 2500);
  }

  function handleCopyPrompt() {
    const clipboard = navigator?.clipboard;
    if (clipboard?.writeText) {
      clipboard
        .writeText(promptText)
        .then(() =>
          schedulePromptStatus({ type: "success", message: "Prompt copied to clipboard." })
        )
        .catch(() =>
          schedulePromptStatus({
            type: "error",
            message: "Clipboard copy failed. Copy manually below.",
          })
        );
      return;
    }

    try {
      const textarea = document.createElement("textarea");
      textarea.value = promptText;
      textarea.setAttribute("readonly", "true");
      textarea.style.position = "absolute";
      textarea.style.left = "-9999px";
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand("copy");
      document.body.removeChild(textarea);
      schedulePromptStatus({ type: "success", message: "Prompt copied to clipboard." });
    } catch (err) {
      schedulePromptStatus({ type: "error", message: "Clipboard copy failed. Copy manually below." });
    }
  }

  function applyImportResult(result, sourceLabel) {
    if (result?.ok && result.artwork) {
      setDraft("");
      setFeedback({
        type: "success",
        message: `Imported "${result.artwork.title}"${sourceLabel ? ` from ${sourceLabel}` : ""}.`,
      });
      setEditingId(null);
      setTitleDraft("");
      return;
    }
    if (result?.error) {
      setFeedback({ type: "error", message: result.error });
      return;
    }
    setFeedback({ type: "error", message: "Unable to import artwork." });
  }

  function handleImportSubmit(e) {
    e?.preventDefault?.();
    const result = onImport(draft, { source: "textarea" });
    applyImportResult(result);
  }

  function handleFileUpload(e) {
    const file = e?.target?.files?.[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      const text = typeof reader.result === "string" ? reader.result : "";
      const outcome = onImport(text, { filename: file.name, type: file.type });
      applyImportResult(outcome, file.name);
    };
    reader.onerror = () => {
      setFeedback({ type: "error", message: `Unable to read ${file.name}.` });
    };
    reader.readAsText(file);
    if (e.target) e.target.value = "";
  }

  function startEditing(art) {
    setEditingId(art.id);
    setTitleDraft(art.title);
  }

  function saveEdit() {
    onRename(editingId, titleDraft);
    setEditingId(null);
    setTitleDraft("");
  }

  function cancelEdit() {
    setEditingId(null);
    setTitleDraft("");
  }

  const pickerContent = hasArtworks
    ? React.createElement(
      "div",
      { style: styles.libraryPickerGrid },
      sorted.map((art) =>
        React.createElement(ArtworkPreviewCard, {
          key: art.id,
          art: art,
          progress: progressMap?.[art.id] ?? 0,
          isActive: art.id === activeArtworkId,
          onSelect: onSelect,
        })
      )
    )
    : React.createElement(
      "div",
      { style: styles.libraryPickerEmpty },
      "Add an artwork to see selectable previews."
    );

  const list = hasArtworks
    ? sorted.map((art) => {
        const isActive = art.id === activeArtworkId;
        const isEditing = editingId === art.id;
        const progress = progressMap?.[art.id] ?? 0;
        return React.createElement(
          "div",
          {
            key: art.id,
            style: {
              ...styles.libraryItem,
              ...(isActive ? styles.libraryItemActive : {}),
            },
          },
          React.createElement(
            "div",
            { style: styles.libraryItemHeader },
            isEditing
              ? React.createElement("input", {
                  style: styles.libraryTitleInput,
                  value: titleDraft,
                  onChange: (e) => setTitleDraft(e.target.value),
                  autoFocus: true,
                })
              : React.createElement("div", { style: styles.libraryItemTitle }, art.title),
            React.createElement(
              "span",
              {
                style: {
                  ...styles.libraryBadge,
                  ...(isActive ? styles.libraryBadgeActive : {}),
                },
              },
              isActive ? "Active" : `${progress}%`
            )
          ),
          React.createElement(
            "div",
            { style: styles.libraryMeta },
            `Progress: ${progress}% - ${art.palette.length} colors - ${art.cells.length} cells`
          ),
          React.createElement(
            "div",
            { style: styles.libraryButtons },
            isEditing
              ? [
                  React.createElement(
                    "button",
                    {
                      key: "save",
                      type: "button",
                      style: styles.libraryPrimaryButton,
                      onClick: saveEdit,
                    },
                    "Save"
                  ),
                  React.createElement(
                    "button",
                    {
                      key: "cancel",
                      type: "button",
                      style: styles.libraryButton,
                      onClick: cancelEdit,
                    },
                    "Cancel"
                  ),
                ]
              : [
                  React.createElement(
                    "button",
                    {
                      key: "load",
                      type: "button",
                      style: styles.libraryPrimaryButton,
                      onClick: () => onSelect(art.id),
                    },
                    isActive ? "Resume" : "Load"
                  ),
                  React.createElement(
                    "button",
                    {
                      key: "rename",
                      type: "button",
                      style: styles.libraryButton,
                      onClick: () => startEditing(art),
                    },
                    "Rename"
                  ),
                  React.createElement(
                    "button",
                    {
                      key: "clear",
                      type: "button",
                      style: styles.libraryButton,
                      onClick: () => onClearProgress(art.id),
                    },
                    "Clear progress"
                  ),
                  React.createElement(
                    "button",
                    {
                      key: "delete",
                      type: "button",
                      style: styles.libraryDangerButton,
                      onClick: () => onDelete(art.id),
                    },
                    "Delete"
                  ),
                ]
          )
        );
      })
    : React.createElement(
        "div",
        { style: styles.libraryEmpty },
        "Import or add an artwork to manage it here."
      );

  return React.createElement(
    "div",
    { style: styles.libraryOverlay, onClick: onClose },
      React.createElement(
        "aside",
        {
          style: styles.libraryPanel,
          role: "dialog",
          "aria-modal": true,
          "aria-label": "Artwork library",
          onClick: (e) => e.stopPropagation(),
          "data-testid": "art-library-dialog",
        },
      React.createElement(
        "div",
        { style: styles.libraryHeader },
        React.createElement("div", { style: styles.libraryTitle }, "Art Library"),
        React.createElement(
          "button",
          {
            style: styles.libraryClose,
            onClick: onClose,
            "aria-label": "Close art library",
            "data-testid": "close-art-library",
          },
          "\u2715"
        )
      ),
      React.createElement(
        "section",
        { style: styles.libraryPickerSection },
        React.createElement(
          "div",
          { style: styles.libraryPickerHeader },
          React.createElement("h3", { style: styles.libraryPickerTitle }, "Art Picker"),
          React.createElement(
            "p",
            { style: styles.libraryPickerHelp },
            "Select a card to load a scene."
          )
        ),
        pickerContent
      ),
      React.createElement("div", { style: styles.libraryList }, list),
      React.createElement(
        "section",
        { style: styles.libraryPromptSection },
        React.createElement("h3", { style: styles.libraryPromptTitle }, "ChatGPT prompt"),
        React.createElement(
          "p",
          { style: styles.libraryPromptBody },
          "Use this prompt with ChatGPT to produce a new color-by-number JSON file."
        ),
        React.createElement(
          "div",
          { style: styles.libraryPromptActions },
          React.createElement(
            "button",
            { type: "button", style: styles.libraryPrimaryButton, onClick: handleCopyPrompt },
            "Copy prompt"
          ),
          promptStatus &&
            React.createElement(
              "span",
              {
                style: {
                  ...styles.libraryPromptStatus,
                  color: promptStatus.type === "error" ? "#f87171" : "#22c55e",
                },
              },
              promptStatus.message
            )
        ),
        React.createElement(
          "pre",
          { style: styles.libraryPromptPre },
          promptText
        )
      ),
      React.createElement(
        "form",
        { style: styles.libraryImport, onSubmit: handleImportSubmit },
        React.createElement("label", { style: styles.libraryLabel }, "Import artwork JSON or SVG"),
        React.createElement(
          "p",
          { style: styles.libraryNote },
          "Paste JSON exported from the app or upload an SVG segmented with data-cell-id/data-color-id attributes."
        ),
        React.createElement("textarea", {
          style: styles.libraryTextarea,
          value: draft,
          onChange: (e) => setDraft(e.target.value),
          placeholder: "{ \"id\": \"my-art\", ... }",
          rows: 6,
        }),
        React.createElement(
          "div",
          { style: styles.libraryFileRow },
          React.createElement("input", {
            type: "file",
            accept: ".json,.svg,application/json,image/svg+xml",
            onChange: handleFileUpload,
            style: styles.libraryFileInput,
          }),
          React.createElement(
            "span",
            { style: styles.libraryFileHint },
            "Choose a file to import annotated SVGs or saved JSON payloads."
          )
        ),
        React.createElement(
          "div",
          { style: styles.libraryImportActions },
          React.createElement(
            "button",
            { type: "submit", style: styles.libraryPrimaryButton },
            "Add artwork"
          ),
          React.createElement(
            "button",
            {
              type: "button",
              style: styles.libraryButton,
              onClick: () => {
                setDraft("");
                setFeedback(null);
              },
            },
            "Clear"
          )
        ),
        feedback &&
          React.createElement(
            "div",
            {
              style: {
                ...styles.libraryFeedback,
                color: feedback.type === "error" ? "#f87171" : "#22c55e",
              },
            },
            feedback.message
          )
      )
    )
  );
}

const OPTION_COPY = {
  enableAutosave: {
    label: "Autosave progress",
    description: "Persist the fill state and viewport to localStorage after each change.",
    group: "gameplay",
  },
  autoAdvanceOnComplete: {
    label: "Auto-advance color",
    description: "Jump to the next color when the active color has no unfilled cells remaining.",
    group: "gameplay",
  },
  enableHintPulse: {
    label: "Hint pulses",
    description: "Allow the Hint control to highlight the smallest unfilled cells in the active color.",
    group: "gameplay",
  },
  enableEyedropper: {
    label: "Eyedropper",
    description: "Tap a filled cell without moving to reselect its color.",
    group: "gameplay",
  },
  enableKeyboardShortcuts: {
    label: "Keyboard shortcuts",
    description: "Use H, N, U, T, +/-, and 0 to control hints, color cycling, undo, tests, zoom, and fitting.",
    group: "gameplay",
  },
  showNumberBadges: {
    label: "Number badges",
    description: "Show numbered overlays for unfilled cells when zoomed in.",
    group: "gameplay",
  },
  showHeatmapDots: {
    label: "Heat-map dots",
    description: "Show locator dots for tiny cells when zoomed out.",
    group: "gameplay",
  },
  enableSmokeHud: {
    label: "Smoke-test HUD",
    description: "Allow the debugging overlay that summarizes automated checks.",
    group: "gameplay",
  },
  showColorLabels: {
    label: "Show color names",
    description: "Display the palette color names beneath each swatch.",
    group: "interface",
  },
  showRemainingCounts: {
    label: "Show remaining counts",
    description: "Keep a caption with how many cells are left for each color.",
    group: "interface",
  },
  peekHoldToReveal: {
    label: "Peek requires hold",
    description: "Hold the Peek button down instead of toggling it on and off.",
    group: "interface",
  },
};

const HELP_SURFACES = [
  {
    title: "Root layout",
    body: "Dark-mode experience with a full-viewport canvas and floating header/footer controls.",
  },
  {
    title: "Header bar",
    body: "Back affordance, artwork title, progress text, and utility buttons for fit, undo, hint, next color, tests, and options.",
  },
  {
    title: "Canvas frame",
    body: "Fullscreen SVG stage with pan/zoom transforms, strokes, badges, and heat-map dots as you zoom.",
  },
  {
    title: "Smoke Tests HUD",
    body: "Optional floating card that reports automated sanity checks and can be hidden with the toolbar or T shortcut.",
  },
  {
    title: "Palette footer",
    body: "Scrollable row of numbered swatches with remaining counts, highlighting the active color and disabling completed ones.",
  },
];

const HELP_SHORTCUTS = [
  { combo: "H", action: "Highlight a hint cell" },
  { combo: "N", action: "Select the next color" },
  { combo: "U", action: "Undo the last paint" },
  { combo: "T", action: "Toggle the smoke-test HUD" },
  { combo: "+ / =", action: "Zoom in" },
  { combo: "- / _", action: "Zoom out" },
  { combo: "0", action: "Reset the view" },
  { combo: "W / A / S / D", action: "Pan across the canvas" },
];

function HelpPanel({ art, progress, activeColor, filled, onClose }) {
  const filledCount = useMemo(() => Object.values(filled ?? {}).filter(Boolean).length, [filled]);
  const todoItems = useMemo(
    () => [
      {
        id: "choose-art",
        label: "Open the library and choose an artwork to paint.",
        done: !!art,
      },
      {
        id: "pick-color",
        label: "Tap a palette color to make it active.",
        done: activeColor != null,
      },
      {
        id: "fill-cell",
        label: "Fill a matching cell to add paint to the scene.",
        done: filledCount > 0,
      },
      {
        id: "finish-scene",
        label: "Color every region to reach 100% completion.",
        done: progress === 100,
      },
    ],
    [art, activeColor, filledCount, progress]
  );

  return React.createElement(
    "div",
    { style: styles.helpOverlay, onClick: onClose },
    React.createElement(
      "aside",
      {
        style: styles.helpCard,
        role: "dialog",
        "aria-modal": true,
        "aria-label": "Help and instructions",
        onClick: (e) => e.stopPropagation(),
      },
      React.createElement(
        "div",
        { style: styles.helpHeader },
        React.createElement("div", { style: styles.helpTitle }, "Help"),
        React.createElement(
          "button",
          { style: styles.helpClose, onClick: onClose, "aria-label": "Close help" },
          "\u2715"
        )
      ),
      React.createElement(
        "section",
        { style: styles.helpSection },
        React.createElement("h3", { style: styles.helpSectionTitle }, "Quick how-to"),
        React.createElement(
          "p",
          { style: styles.helpIntro },
          "Pick a color from the palette, tap the matching cells, and fill every region to finish the scene."
        ),
        React.createElement(
          "ul",
          { style: styles.helpTodoList },
          todoItems.map((item) =>
            React.createElement(
              "li",
              { key: item.id, style: styles.helpTodoItem },
              React.createElement(
                "span",
                { style: styles.helpTodoCheck, "aria-hidden": "true" },
                item.done ? "[x]" : "[ ]"
              ),
              React.createElement("span", { style: styles.helpTodoLabel }, item.label)
            )
          )
        )
      ),
      React.createElement(
        "section",
        { style: styles.helpSection },
        React.createElement("h3", { style: styles.helpSectionTitle }, "What's on screen"),
        React.createElement(
          "ul",
          { style: styles.helpUiList },
          HELP_SURFACES.map((surface) =>
            React.createElement(
              "li",
              { key: surface.title },
              React.createElement("strong", null, surface.title, ": "),
              surface.body
            )
          )
        )
      ),
      React.createElement(
        "section",
        { style: styles.helpSection },
        React.createElement("h3", { style: styles.helpSectionTitle }, "Keyboard shortcuts"),
        React.createElement(
          "ul",
          { style: styles.helpShortcutList },
          HELP_SHORTCUTS.map((shortcut) =>
            React.createElement(
              "li",
              { key: shortcut.combo, style: styles.helpShortcutRow },
              React.createElement("span", { style: styles.helpShortcutKey }, shortcut.combo),
              React.createElement("span", { style: styles.helpShortcutLabel }, shortcut.action)
            )
          )
        )
      ),
      React.createElement("div", { style: styles.helpFooter }, "Need to tweak the experience? Open Options to toggle helpers and accessibility tools.")
    )
  );
}

function OptionsPanel({ config, onToggle, canReset, onReset, onClose }) {
  const humanize = (value) =>
    value
      .replace(/([A-Z])/g, " $1")
      .replace(/[-_]+/g, " ")
      .replace(/^./, (ch) => ch.toUpperCase())
      .trim();

  const optionEntries = Object.keys(DEFAULT_CONFIG).map((key) => {
    const copy = OPTION_COPY[key] || {};
    const label = copy.label || humanize(key);
    const description = copy.description || "";
    const group = copy.group || "gameplay";
    return { key, label, description, group };
  });

  const baseGroups = [
    { key: "gameplay", title: "Game flow & helpers" },
    { key: "interface", title: "Interface & layout" },
  ];

  const grouped = optionEntries.reduce((acc, entry) => {
    const bucket = entry.group || "gameplay";
    if (!acc[bucket]) acc[bucket] = [];
    acc[bucket].push(entry);
    return acc;
  }, {});

  const sections = [
    ...baseGroups
      .map((info) => ({
        key: info.key,
        title: info.title,
        options: grouped[info.key] || [],
      }))
      .filter((section) => section.options.length > 0),
    ...Object.keys(grouped)
      .filter((key) => !baseGroups.some((info) => info.key === key))
      .map((key) => ({
        key,
        title: humanize(key),
        options: grouped[key],
      })),
  ];

  return React.createElement(
    "div",
    { style: styles.optionsOverlay, onClick: onClose },
    React.createElement(
      "aside",
      {
        style: styles.optionsCard,
        role: "dialog",
        "aria-modal": true,
        "aria-label": "Game options",
        onClick: (e) => e.stopPropagation(),
      },
      React.createElement(
        "div",
        { style: styles.optionsHeader },
        React.createElement("div", { style: styles.optionsTitle }, "Options"),
        React.createElement(
          "button",
          { style: styles.optionsClose, onClick: onClose, "aria-label": "Close options" },
          "\u2715"
        )
      ),
      React.createElement(
        "p",
        { style: styles.optionsAbout },
        "Fine-tune gameplay helpers or personalize the interface. Changes save automatically."
      ),
      sections.map((section) =>
        React.createElement(
          React.Fragment,
          { key: section.key },
          React.createElement("div", { style: styles.optionsSectionTitle }, section.title),
          React.createElement(
            "div",
            { style: styles.optionsList },
            section.options.map((opt) =>
              React.createElement(
                "label",
                { key: opt.key, style: styles.optionRow },
                React.createElement("input", {
                  type: "checkbox",
                  checked: !!config[opt.key],
                  onChange: (e) => onToggle(opt.key, e.target.checked),
                  style: styles.optionCheckbox,
                }),
                React.createElement(
                  "div",
                  null,
                  React.createElement("div", { style: styles.optionLabel }, opt.label),
                  opt.description
                    ? React.createElement("div", { style: styles.optionDescription }, opt.description)
                    : null
                )
              )
            )
          )
        )
      ),
      React.createElement("div", { style: styles.optionsSectionTitle }, "Current values"),
      React.createElement(
        "pre",
        { style: styles.optionsConfigPre },
        JSON.stringify(config, null, 2)
      ),
      React.createElement(
        "div",
        { style: styles.optionsFooter },
        React.createElement(
          "button",
          {
            style: {
              ...styles.optionsReset,
              opacity: canReset ? 1 : 0.5,
              cursor: canReset ? "pointer" : "not-allowed",
            },
            type: "button",
            onClick: canReset ? onReset : undefined,
            disabled: !canReset,
          },
          "Reset to defaults"
        )
      )
    )
  );
}

// ---------- Smoke Tests HUD ----------
function SmokeTests({ art, filled }) {
  const results = useMemo(() => runSmokeTests(art, filled), [art, filled]);
  const allPass = results.every((r) => r.pass);
  if (allPass) return null;
  return React.createElement(
    "div",
    {
      style: {
        position: "absolute",
        left: 16,
        bottom: 180,
        background: "rgba(248, 113, 113, 0.12)",
        border: "1px solid #f87171",
        borderRadius: 12,
        padding: 12,
        boxShadow: "0 12px 40px rgba(15, 23, 42, 0.35)",
        maxWidth: 360,
        fontSize: 12,
        backdropFilter: "blur(12px)",
      },
    },
    React.createElement(
      "div",
      { style: { fontWeight: 700, marginBottom: 8 } },
      "Smoke tests failed"
    ),
    React.createElement(
      "ul",
      { style: { margin: 0, paddingLeft: 18 } },
      results.map((r) => {
        const status = r.pass ? "[pass]" : "[fail]";
        const details = r.msg ? ` - ${r.msg}` : "";
        return React.createElement(
          "li",
          { key: r.name, style: { color: r.pass ? "#4ade80" : "#fca5a5" } },
          `${status} ${r.name}${details}`
        );
      })
    ),
    React.createElement(
      "div",
      { style: { marginTop: 8, color: "#94a3b8" } },
      "Press T to hide/show."
    )
  );
}

function runSmokeTests(art, filled) {
  const tests = [];
  const rem = computeRemaining(art, filled);
  const sum = Object.values(rem).reduce((a, b) => a + b, 0);
  const expected = art.cells.filter((c) => !filled[c.id]).length;
  tests.push({ name: "Remaining matches unfilled count", pass: sum === expected, msg: `${sum}/${expected}` });
  const c0 = art.cells[0];
  const { x, y } = centroidFromPath(c0.d);
  tests.push({ name: "Centroid in bounds", pass: x >= 0 && y >= 0 && x <= art.width && y <= art.height });
  const ids = new Set(art.palette.map((p) => p.id));
  tests.push({ name: "Palette IDs unique", pass: ids.size === art.palette.length });
  return tests;
}

// ---------- Styles ----------
const styles = {
  app: {
    width: "100vw",
    height: "100vh",
    position: "relative",
    overflow: "hidden",
    fontFamily: "'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui",
    color: "#f8fafc",
    background: "radial-gradient(circle at top, rgba(56, 189, 248, 0.12), #030712)",
  },
  canvas: {
    position: "absolute",
    inset: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    userSelect: "none",
    WebkitUserSelect: "none",
  },
  topBar: {
    position: "fixed",
    top: 16,
    left: "50%",
    transform: "translateX(-50%)",
    width: "min(880px, calc(100% - 28px))",
    display: "flex",
    flexWrap: "nowrap",
    justifyContent: "space-between",
    alignItems: "center",
    gap: 12,
    padding: "8px 14px",
    borderRadius: 16,
    background: "rgba(15, 23, 42, 0.82)",
    border: "1px solid rgba(148, 163, 184, 0.26)",
    boxShadow: "0 18px 36px rgba(2, 6, 23, 0.55)",
    backdropFilter: "blur(14px)",
    zIndex: 20,
  },
  topContext: {
    display: "flex",
    alignItems: "center",
    gap: 10,
    minWidth: 0,
    flex: "0 1 auto",
    overflow: "hidden",
  },
  topTitle: {
    fontSize: 16,
    fontWeight: 600,
    color: "#f8fafc",
    letterSpacing: 0.3,
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
  },
  topProgress: {
    fontSize: 12,
    fontWeight: 600,
    padding: "2px 10px",
    borderRadius: 999,
    background: "rgba(30, 41, 59, 0.7)",
    border: "1px solid rgba(148, 163, 184, 0.26)",
    color: "#d3defe",
    whiteSpace: "nowrap",
  },
  topActions: {
    display: "flex",
    flexWrap: "nowrap",
    justifyContent: "flex-end",
    gap: 6,
    flex: "1 1 auto",
    overflowX: "auto",
  },
  controlButton: {
    borderRadius: 10,
    border: "1px solid rgba(148, 163, 184, 0.28)",
    background: "linear-gradient(180deg, rgba(51, 65, 85, 0.55), rgba(15, 23, 42, 0.9))",
    color: "#f8fafc",
    fontSize: 12,
    fontWeight: 600,
    letterSpacing: 0.2,
    padding: "6px 12px",
    minHeight: 34,
    minWidth: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    gap: 6,
    cursor: "pointer",
    boxShadow: "0 12px 28px rgba(2, 6, 23, 0.45)",
    transition: "transform 0.15s ease, box-shadow 0.2s ease, background 0.2s ease",
    textTransform: "none",
    whiteSpace: "nowrap",
    lineHeight: 1.2,
  },
  controlButtonActive: {
    border: "1px solid rgba(56, 189, 248, 0.55)",
    boxShadow: "0 0 0 2px rgba(56, 189, 248, 0.35), 0 12px 32px rgba(2, 6, 23, 0.55)",
    color: "#38bdf8",
  },
  paletteDock: {
    position: "fixed",
    left: 0,
    right: 0,
    bottom: 0,
    padding: "10px 18px",
    background: "rgba(15, 23, 42, 0.9)",
    borderRadius: 0,
    border: "none",
    boxShadow: "0 -8px 24px rgba(2, 6, 23, 0.45)",
    zIndex: 11,
    overflow: "hidden",
    backdropFilter: "blur(18px)",
  },
  emptyState: {
    position: "absolute",
    inset: 0,
    display: "grid",
    placeItems: "center",
    padding: 24,
    color: "#94a3b8",
    fontSize: 18,
    textAlign: "center",
  },
  paletteWrap: {
    display: "flex",
    flexDirection: "row",
    flexWrap: "nowrap",
    gap: 14,
    width: "100%",
    overflowX: "auto",
    padding: "4px 4px 2px",
    scrollSnapType: "x proximity",
    alignItems: "flex-start",
  },
  swatch: {
    width: "clamp(52px, 9vw, 72px)",
    height: "clamp(52px, 9vw, 72px)",
    borderRadius: 18,
    display: "grid",
    placeItems: "center",
    position: "relative",
    transition: "transform 0.12s ease, box-shadow 0.2s ease",
    cursor: "pointer",
    color: "#f8fafc",
  },
  swatchNumber: {
    fontSize: 18,
    fontWeight: 700,
    textShadow: "0 1px 4px rgba(15, 23, 42, 0.65)",
  },
  swatchItem: {
    display: "grid",
    gap: 6,
    justifyItems: "center",
    minWidth: 72,
    scrollSnapAlign: "center",
  },
  swatchName: {
    fontSize: 11,
    color: "#dbeafe",
    textAlign: "center",
    maxWidth: 96,
    lineHeight: 1.3,
  },
  swatchRemaining: {
    fontSize: 10,
    color: "#94a3b8",
    textAlign: "center",
  },
  libraryOverlay: {
    position: "fixed",
    inset: 0,
    background: "rgba(2, 6, 23, 0.7)",
    backdropFilter: "blur(12px)",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    padding: "24px",
    zIndex: 60,
  },
  libraryPanel: {
    width: "min(560px, 100%)",
    maxHeight: "calc(100vh - 48px)",
    overflowY: "auto",
    background: "rgba(15, 23, 42, 0.96)",
    borderRadius: 24,
    padding: 24,
    boxShadow: "0 24px 60px rgba(2, 6, 23, 0.7)",
    border: "1px solid rgba(148, 163, 184, 0.3)",
    color: "#e2e8f0",
    display: "grid",
    gap: 20,
  },
  libraryHeader: {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
  },
  libraryTitle: {
    fontSize: 20,
    fontWeight: 700,
  },
  libraryClose: {
    width: 36,
    height: 36,
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.8)",
    color: "#cbd5f5",
    cursor: "pointer",
  },
  libraryList: {
    display: "grid",
    gap: 12,
  },
  libraryPickerSection: {
    border: "1px solid rgba(148, 163, 184, 0.25)",
    borderRadius: 16,
    padding: 16,
    background: "rgba(15, 23, 42, 0.7)",
    display: "grid",
    gap: 12,
  },
  libraryPickerHeader: {
    display: "flex",
    alignItems: "baseline",
    justifyContent: "space-between",
    gap: 12,
    flexWrap: "wrap",
  },
  libraryPickerTitle: {
    fontSize: 16,
    fontWeight: 600,
    margin: 0,
  },
  libraryPickerHelp: {
    margin: 0,
    fontSize: 12,
    color: "#94a3b8",
  },
  libraryPickerGrid: {
    display: "grid",
    gridTemplateColumns: "repeat(auto-fit, minmax(160px, 1fr))",
    gap: 12,
  },
  libraryPickerEmpty: {
    padding: 16,
    textAlign: "center",
    color: "#94a3b8",
    border: "1px dashed rgba(148, 163, 184, 0.3)",
    borderRadius: 16,
  },
  libraryCard: {
    display: "grid",
    gap: 8,
    padding: 12,
    borderRadius: 16,
    border: "1px solid rgba(148, 163, 184, 0.22)",
    background: "rgba(15, 23, 42, 0.72)",
    color: "#e2e8f0",
    cursor: "pointer",
    textAlign: "left",
    width: "100%",
    transition: "transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease",
  },
  libraryCardActive: {
    borderColor: "rgba(56, 189, 248, 0.6)",
    boxShadow: "0 0 0 1px rgba(56, 189, 248, 0.4), 0 12px 30px rgba(2, 6, 23, 0.65)",
    transform: "translateY(-2px)",
  },
  libraryCardPreview: {
    width: "100%",
    aspectRatio: "4 / 3",
    background: "rgba(15, 23, 42, 0.9)",
    borderRadius: 12,
    overflow: "hidden",
  },
  libraryCardSvg: {
    width: "100%",
    height: "100%",
    display: "block",
  },
  libraryCardBody: {
    display: "grid",
    gap: 4,
  },
  libraryCardTitle: {
    fontSize: 14,
    fontWeight: 600,
    lineHeight: 1.3,
  },
  libraryCardMeta: {
    fontSize: 12,
    color: "#94a3b8",
  },
  libraryItem: {
    border: "1px solid rgba(148, 163, 184, 0.2)",
    borderRadius: 16,
    padding: 16,
    background: "rgba(15, 23, 42, 0.7)",
    display: "grid",
    gap: 12,
  },
  libraryItemActive: {
    borderColor: "rgba(56, 189, 248, 0.6)",
    boxShadow: "0 0 0 1px rgba(56, 189, 248, 0.4)",
  },
  libraryItemHeader: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
  },
  libraryItemTitle: {
    fontWeight: 600,
    fontSize: 16,
  },
  libraryTitleInput: {
    width: "100%",
    padding: "6px 10px",
    borderRadius: 10,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.85)",
    color: "#e2e8f0",
  },
  libraryBadge: {
    padding: "4px 10px",
    borderRadius: 999,
    fontSize: 12,
    background: "rgba(148, 163, 184, 0.2)",
    color: "#cbd5f5",
  },
  libraryBadgeActive: {
    background: "rgba(56, 189, 248, 0.2)",
    color: "#38bdf8",
  },
  libraryMeta: {
    fontSize: 13,
    color: "#94a3b8",
  },
  libraryButtons: {
    display: "flex",
    flexWrap: "wrap",
    gap: 8,
  },
  libraryButton: {
    padding: "8px 12px",
    borderRadius: 10,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(30, 41, 59, 0.6)",
    color: "#cbd5f5",
    cursor: "pointer",
  },
  libraryPrimaryButton: {
    padding: "8px 12px",
    borderRadius: 10,
    border: "1px solid rgba(56, 189, 248, 0.5)",
    background: "rgba(56, 189, 248, 0.2)",
    color: "#38bdf8",
    cursor: "pointer",
  },
  libraryDangerButton: {
    padding: "8px 12px",
    borderRadius: 10,
    border: "1px solid rgba(248, 113, 113, 0.5)",
    background: "rgba(248, 113, 113, 0.15)",
    color: "#fca5a5",
    cursor: "pointer",
  },
  libraryEmpty: {
    padding: 16,
    textAlign: "center",
    color: "#94a3b8",
    border: "1px dashed rgba(148, 163, 184, 0.3)",
    borderRadius: 16,
  },
  libraryPromptSection: {
    border: "1px solid rgba(148, 163, 184, 0.25)",
    borderRadius: 16,
    padding: 16,
    background: "rgba(15, 23, 42, 0.7)",
    display: "grid",
    gap: 12,
  },
  libraryPromptTitle: {
    margin: 0,
    fontSize: 15,
    fontWeight: 600,
  },
  libraryPromptBody: {
    margin: 0,
    fontSize: 13,
    color: "#94a3b8",
  },
  libraryPromptActions: {
    display: "flex",
    alignItems: "center",
    gap: 12,
  },
  libraryPromptStatus: {
    fontSize: 12,
  },
  libraryPromptPre: {
    margin: 0,
    padding: 12,
    background: "rgba(15, 23, 42, 0.85)",
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.2)",
    fontSize: 12,
    color: "#cbd5f5",
    overflowX: "auto",
    whiteSpace: "pre-wrap",
    fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
  },
  libraryImport: {
    display: "grid",
    gap: 12,
  },
  libraryLabel: {
    fontSize: 13,
    fontWeight: 600,
    color: "#cbd5f5",
  },
  libraryNote: {
    margin: 0,
    fontSize: 12,
    color: "#94a3b8",
  },
  libraryTextarea: {
    width: "100%",
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.8)",
    color: "#e2e8f0",
    padding: 12,
    fontSize: 13,
    fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
  },
  libraryFileRow: {
    display: "flex",
    flexWrap: "wrap",
    alignItems: "center",
    gap: 12,
  },
  libraryFileInput: {
    color: "#cbd5f5",
    fontSize: 12,
  },
  libraryFileHint: {
    fontSize: 12,
    color: "#94a3b8",
  },
  libraryImportActions: {
    display: "flex",
    gap: 12,
    flexWrap: "wrap",
  },
  libraryFeedback: {
    fontSize: 12,
  },
  helpOverlay: {
    position: "fixed",
    inset: 0,
    background: "rgba(2, 6, 23, 0.6)",
    backdropFilter: "blur(8px)",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    padding: "24px",
    zIndex: 55,
  },
  helpCard: {
    width: "min(520px, 100%)",
    maxHeight: "calc(100vh - 60px)",
    overflowY: "auto",
    background: "rgba(15, 23, 42, 0.96)",
    borderRadius: 24,
    padding: 24,
    boxShadow: "0 24px 60px rgba(2, 6, 23, 0.65)",
    border: "1px solid rgba(148, 163, 184, 0.3)",
    color: "#e2e8f0",
    display: "grid",
    gap: 16,
  },
  helpHeader: {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
  },
  helpTitle: {
    fontSize: 20,
    fontWeight: 700,
  },
  helpClose: {
    width: 32,
    height: 32,
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.8)",
    color: "#cbd5f5",
    cursor: "pointer",
  },
  helpSection: {
    display: "grid",
    gap: 12,
  },
  helpSectionTitle: {
    fontSize: 14,
    fontWeight: 600,
    margin: 0,
  },
  helpIntro: {
    margin: 0,
    fontSize: 13,
    color: "#94a3b8",
  },
  helpTodoList: {
    listStyle: "none",
    margin: 0,
    padding: 0,
    display: "grid",
    gap: 8,
  },
  helpTodoItem: {
    display: "grid",
    gridTemplateColumns: "auto 1fr",
    gap: 12,
    alignItems: "center",
    padding: "8px 12px",
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.18)",
    background: "rgba(15, 23, 42, 0.7)",
  },
  helpTodoCheck: {
    fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
    fontSize: 12,
    color: "#cbd5f5",
  },
  helpTodoLabel: {
    fontSize: 13,
    color: "#e2e8f0",
  },
  helpUiList: {
    margin: 0,
    paddingLeft: 18,
    display: "grid",
    gap: 8,
    fontSize: 13,
    color: "#d0def5",
  },
  helpShortcutList: {
    margin: 0,
    padding: 0,
    listStyle: "none",
    display: "grid",
    gap: 8,
  },
  helpShortcutRow: {
    display: "grid",
    gridTemplateColumns: "auto 1fr",
    gap: 12,
    alignItems: "center",
  },
  helpShortcutKey: {
    padding: "4px 10px",
    borderRadius: 10,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.8)",
    color: "#f8fafc",
    fontSize: 12,
    fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
  },
  helpShortcutLabel: {
    fontSize: 12,
    color: "#94a3b8",
  },
  helpFooter: {
    fontSize: 12,
    color: "#94a3b8",
    background: "rgba(15, 23, 42, 0.7)",
    borderRadius: 12,
    padding: 12,
    border: "1px solid rgba(148, 163, 184, 0.18)",
  },
  optionsOverlay: {
    position: "fixed",
    inset: 0,
    background: "rgba(2, 6, 23, 0.6)",
    backdropFilter: "blur(8px)",
    display: "flex",
    justifyContent: "flex-end",
    alignItems: "center",
    padding: "24px 32px",
    zIndex: 50,
  },
  optionsCard: {
    width: "min(420px, 100%)",
    maxHeight: "calc(100vh - 48px)",
    overflowY: "auto",
    background: "rgba(15, 23, 42, 0.96)",
    borderRadius: 24,
    padding: 24,
    boxShadow: "0 24px 60px rgba(2, 6, 23, 0.65)",
    border: "1px solid rgba(148, 163, 184, 0.25)",
    color: "#e2e8f0",
  },
  optionsHeader: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 12,
  },
  optionsTitle: {
    fontSize: 20,
    fontWeight: 700,
  },
  optionsClose: {
    width: 32,
    height: 32,
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.8)",
    color: "#cbd5f5",
    cursor: "pointer",
  },
  optionsAbout: {
    fontSize: 13,
    lineHeight: 1.6,
    color: "#cbd5f5",
    marginTop: 0,
    marginBottom: 16,
  },
  optionsSectionTitle: {
    fontSize: 11,
    textTransform: "uppercase",
    letterSpacing: 1,
    color: "#64748b",
    margin: "20px 0 10px",
  },
  optionsUiList: {
    margin: 0,
    paddingLeft: 18,
    display: "grid",
    gap: 8,
    fontSize: 13,
    color: "#d0def5",
  },
  optionsList: {
    display: "grid",
    gap: 12,
  },
  optionRow: {
    display: "grid",
    gridTemplateColumns: "auto 1fr",
    gap: 12,
    alignItems: "start",
    background: "rgba(15, 23, 42, 0.7)",
    padding: 12,
    borderRadius: 16,
    border: "1px solid rgba(148, 163, 184, 0.15)",
  },
  optionCheckbox: {
    width: 18,
    height: 18,
    marginTop: 4,
  },
  optionLabel: {
    fontWeight: 600,
    color: "#e2e8f0",
  },
  optionDescription: {
    fontSize: 12,
    color: "#94a3b8",
    marginTop: 4,
  },
  optionsConfigPre: {
    margin: 0,
    padding: 12,
    background: "rgba(15, 23, 42, 0.7)",
    borderRadius: 16,
    border: "1px solid rgba(148, 163, 184, 0.15)",
    fontSize: 12,
    color: "#f8fafc",
    overflowX: "auto",
  },
  optionsFooter: {
    marginTop: 16,
    display: "flex",
    justifyContent: "flex-end",
  },
  optionsReset: {
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(51, 65, 85, 0.4)",
    color: "#e2e8f0",
    padding: "10px 16px",
    cursor: "pointer",
    fontWeight: 600,
  },
};

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(React.createElement(App));
    </script>
  </body>
</html>

