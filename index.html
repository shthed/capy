<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Color-by-Number Demo</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "Inter", "Segoe UI", -apple-system, BlinkMacSystemFont, system-ui,
          sans-serif;
        background-color: #030712;
        color: #e2e8f0;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, rgba(56, 189, 248, 0.08), transparent),
          #030712;
        color: inherit;
      }

      #root {
        min-height: 100vh;
      }

      button {
        font: inherit;
      }

      svg {
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <div id="root" role="application" aria-label="Color-by-number painting app"></div>

    <script src="./vendor/react.development.js"></script>
    <script src="./vendor/react-dom.development.js"></script>
    <script src="./vendor/babel.min.js"></script>
    <script src="./art/starter-fallbacks.js"></script>
    <script type="text/babel">
const { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } = React;

const pathBoxCache = new Map();
const pathAreaCache = new Map();
const interiorPointCache = new Map();
const SVG_NS = "http://www.w3.org/2000/svg";
let measureSvgEl = null;
let measureCanvasCtx = null;

// Capybooper Web Game - MVP single-file React app (patched)
// Fixes: correct zoom/pan math, pan over filled cells, pinch zoom, drag-fill,
// eyedropper, auto-advance, hint stroke highlight, smoke-test HUD.
// No external libs. LocalStorage autosave. Keyboard support.

// ---------- Types ----------
/** @typedef {number} ColorId */

/**
 * @typedef PaletteItem
 * @property {ColorId} id
 * @property {string=} name
 * @property {string} rgba
 */

/**
 * @typedef Cell
 * @property {string} id
 * @property {ColorId} colorId
 * @property {string} d
 * @property {number=} area
 */

/**
 * @typedef Artwork
 * @property {string} id
 * @property {string} title
 * @property {number} width
 * @property {number} height
 * @property {PaletteItem[]} palette
 * @property {Cell[]} cells
 */

/**
 * @typedef SaveState
 * @property {string} artworkId
 * @property {Record<string, boolean>} filled
 * @property {ColorId=} activeColor
 * @property {{ scale: number; x: number; y: number }=} viewport
 * @property {number} lastSaved
 */

const STARTER_SOURCES = [
  {
    id: "starter-capybara-lagoon",
    url: "./art/capybara-lagoon.svg",
    filename: "capybara-lagoon.svg",
    type: "image/svg+xml",
  },
  {
    id: "starter-twilight-marsh",
    url: "./art/capybara-twilight.svg",
    filename: "capybara-twilight.svg",
    type: "image/svg+xml",
  },
  {
    id: "starter-lush-forest",
    url: "./art/lush-green-forest.svg",
    filename: "lush-green-forest.svg",
    type: "image/svg+xml",
  },
];

function getLegacyStarterArtworks() {
  return [];
}

function loadSvgViaObject(url, signal) {
  return new Promise((resolve, reject) => {
    if (signal?.aborted) {
      reject(signal.reason ?? new DOMException('Aborted', 'AbortError'));
      return;
    }

    if (!document?.body) {
      reject(new Error('The document body is unavailable.'));
      return;
    }

    const objectEl = document.createElement('object');
    objectEl.type = 'image/svg+xml';
    objectEl.setAttribute('aria-hidden', 'true');
    objectEl.style.position = 'absolute';
    objectEl.style.width = '0';
    objectEl.style.height = '0';
    objectEl.style.pointerEvents = 'none';
    objectEl.style.opacity = '0';

    const cleanup = () => {
      objectEl.removeEventListener('load', handleLoad);
      objectEl.removeEventListener('error', handleError);
      if (signal) {
        signal.removeEventListener('abort', handleAbort);
      }
      if (objectEl.parentNode) {
        objectEl.parentNode.removeChild(objectEl);
      }
    };

    const handleAbort = () => {
      cleanup();
      reject(signal.reason ?? new DOMException('Aborted', 'AbortError'));
    };

    const handleLoad = () => {
      try {
        const doc = objectEl.contentDocument;
        if (!doc) {
          throw new Error('Unable to access the SVG document.');
        }
        const svgEl = doc.documentElement;
        if (!svgEl) {
          throw new Error('The SVG content is empty.');
        }
        resolve(svgEl.outerHTML);
      } catch (err) {
        reject(err instanceof Error ? err : new Error('Unable to read the SVG content.'));
      } finally {
        cleanup();
      }
    };

    const handleError = () => {
      cleanup();
      reject(new Error('Unable to load the SVG via <object>.'));
    };

    objectEl.addEventListener('load', handleLoad);
    objectEl.addEventListener('error', handleError);
    if (signal) {
      signal.addEventListener('abort', handleAbort, { once: true });
    }
    document.body.appendChild(objectEl);
    try {
      const resolved = new URL(url, window.location.href);
      objectEl.data = resolved.href;
    } catch (err) {
      cleanup();
      reject(err instanceof Error ? err : new Error('Invalid SVG URL.'));
    }
  });
}

function loadSvgViaXhr(url, signal) {
  return new Promise((resolve, reject) => {
    if (signal?.aborted) {
      reject(signal.reason ?? new DOMException('Aborted', 'AbortError'));
      return;
    }

    let aborted = false;
    const xhr = new XMLHttpRequest();
    const cleanup = () => {
      xhr.onerror = null;
      xhr.onreadystatechange = null;
      if (signal) {
        signal.removeEventListener('abort', handleAbort);
      }
    };
    const handleAbort = () => {
      aborted = true;
      xhr.abort();
      cleanup();
      reject(signal.reason ?? new DOMException('Aborted', 'AbortError'));
    };

    xhr.onerror = () => {
      cleanup();
      reject(new Error('Unable to load the SVG via XMLHttpRequest.'));
    };

    xhr.onreadystatechange = () => {
      if (xhr.readyState !== XMLHttpRequest.DONE) return;
      cleanup();
      if (aborted) return;
      const status = xhr.status;
      if (status === 0 || (status >= 200 && status < 300)) {
        resolve(xhr.responseText);
      } else {
        reject(new Error(`XMLHttpRequest failed with status ${status}.`));
      }
    };

    try {
      const resolved = new URL(url, window.location.href);
      xhr.open('GET', resolved.href, true);
      xhr.overrideMimeType('image/svg+xml');
      if (signal) {
        signal.addEventListener('abort', handleAbort, { once: true });
      }
      xhr.send();
    } catch (err) {
      cleanup();
      reject(err instanceof Error ? err : new Error('Unable to resolve the SVG URL.'));
    }
  });
}

async function loadStarterArtworks(signal) {
  const results = [];
  const seenIds = new Set();
  const errors = [];

  const inlineFallbacks =
    typeof window !== "undefined" ? window.__starterSvgFallbacks ?? null : null;
  const isFileProtocol =
    typeof window !== "undefined" && window.location?.protocol === "file:";

  for (const source of STARTER_SOURCES) {
    let candidate = null;

    const failureReasons = [];
    const meta = {
      filename: source.filename ?? source.url?.split("/").pop(),
      type: source.type ?? "image/svg+xml",
      source: "starter",
    };
    const parseSource = (raw) => {
      const parsed = parseArtworkPayload(raw, meta);
      if (parsed.ok && parsed.artwork) {
        return cloneArtwork(parsed.artwork);
      }
      throw new Error(parsed.error ?? "Unable to convert the artwork payload.");
    };

    if (!candidate && source.url) {
      const loaders = [];
      const addLoader = (label, fn) => loaders.push({ label, fn });

      if (isFileProtocol) {
        addLoader("<object>", () => loadSvgViaObject(source.url, signal));
        addLoader("XMLHttpRequest", () => loadSvgViaXhr(source.url, signal));
        addLoader("fetch", async () => {
          const response = await fetch(source.url, { signal });
          if (!response.ok) {
            throw new Error(`Request failed with status ${response.status}`);
          }
          return response.text();
        });
      } else {
        addLoader("fetch", async () => {
          const response = await fetch(source.url, { signal });
          if (!response.ok) {
            throw new Error(`Request failed with status ${response.status}`);
          }
          return response.text();
        });
        addLoader("XMLHttpRequest", () => loadSvgViaXhr(source.url, signal));
        addLoader("<object>", () => loadSvgViaObject(source.url, signal));
      }

      for (const loader of loaders) {
        if (candidate) break;
        try {
          const raw = await loader.fn();
          candidate = parseSource(raw);
          if (candidate) {
            console.info(
              `Loaded starter artwork from ${source.url} via ${loader.label}.`
            );
          }
        } catch (err) {
          const normalized = err instanceof Error ? err : new Error(String(err));
          failureReasons.push(normalized);
          console.warn(
            `Unable to load starter artwork from ${source.url} via ${loader.label}:`,
            normalized
          );
        }
      }
    }

    if (!candidate && inlineFallbacks?.[source.id]) {
      try {
        candidate = parseSource(inlineFallbacks[source.id]);
        if (candidate) {
          console.info(
            `Loaded starter artwork from ${source.url || source.id} via inline fallback.`
          );
        }
      } catch (err) {
        const normalized = err instanceof Error ? err : new Error(String(err));
        failureReasons.push(normalized);
        console.warn(
          `Unable to parse inline fallback for ${source.url || source.id}:`,
          normalized
        );
      }
    }

    if (!candidate) {
      if (failureReasons.length) {
        errors.push(failureReasons[0]);
      } else {
        errors.push(
          new Error(`Unable to load starter artwork from ${source.url || source.id || 'starter art'}.`)
        );
      }
      continue;
    }

    let id = (candidate.id ?? "").toString().trim();
    if (!id) {
      id = source.id || `starter-${Math.random().toString(36).slice(2, 8)}`;
      candidate = { ...candidate, id };
    }

    if (seenIds.has(id)) {
      let suffix = 2;
      let uniqueId = `${id}-${suffix}`;
      while (seenIds.has(uniqueId)) {
        uniqueId = `${id}-${++suffix}`;
      }
      candidate = { ...candidate, id: uniqueId };
      seenIds.add(uniqueId);
    } else {
      seenIds.add(id);
    }

    if (!candidate.title && source.title) {
      candidate = { ...candidate, title: source.title };
    }

    results.push(candidate);
  }

  if (!results.length) {
    return { artworks: getLegacyStarterArtworks(), errors };
  }

  return { artworks: results, errors };
}

// Estimate area for heuristics using DOM sampling with a polygon fallback.
function estimatePathArea(d) {
  const bbox = measurePathBox(d);
  const measured = measurePathArea(d, bbox);
  if (typeof measured === "number" && measured > 0) {
    return measured;
  }

  try {
    const tokens = d.split(/[ ,]/).filter(Boolean);
    const pts = [];
    for (let i = 0; i < tokens.length; i++) {
      const t = tokens[i];
      if (t === "M" || t === "L" || t === "Z") continue;
      const n = Number(t);
      if (!Number.isNaN(n)) pts.push(n);
    }
    const xy = [];
    for (let i = 0; i + 1 < pts.length; i += 2) xy.push([pts[i], pts[i + 1]]);
    let area = 0;
    for (let i = 0; i < xy.length; i++) {
      const [x1, y1] = xy[i];
      const [x2, y2] = xy[(i + 1) % xy.length];
      area += x1 * y2 - x2 * y1;
    }
    return Math.abs(area / 2) || 1000;
  } catch (err) {
    return 1000;
  }
}

// ---------- Utilities ----------
const SAVE_KEY = (artId) => `capybooper_save_${artId}`;
const ARTWORKS_KEY = "capybooper_artworks_v1";
const ACTIVE_ART_KEY = "capybooper_active_art";

function normalizeArtwork(raw) {
  if (!raw) return null;
  try {
    const width = Number(raw.width);
    const height = Number(raw.height);
    if (!Number.isFinite(width) || width <= 0) return null;
    if (!Number.isFinite(height) || height <= 0) return null;
    const palette = Array.isArray(raw.palette)
      ? raw.palette
          .map((item) => ({
            id: item.id,
            name: item.name ?? undefined,
            rgba: item.rgba,
          }))
          .filter((item) => item.id !== undefined && typeof item.rgba === "string")
      : [];
    const cells = Array.isArray(raw.cells)
      ? raw.cells
          .map((cell) => ({
            id: cell.id,
            colorId: cell.colorId,
            d: cell.d,
            area: cell.area ?? estimatePathArea(cell.d ?? ""),
          }))
          .filter(
            (cell) =>
              typeof cell.id === "string" &&
              cell.id.length > 0 &&
              typeof cell.d === "string" &&
              cell.d.length > 0 &&
              cell.colorId !== undefined
          )
      : [];
    const title = (raw.title ?? "").trim();
    let id = (raw.id ?? "").toString().trim();
    if (!title || !palette.length || !cells.length) return null;
    if (!id) {
      const slug = title
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "");
      id = slug || `art-${Math.random().toString(36).slice(2, 8)}`;
    }
    return {
      id,
      title,
      width,
      height,
      palette,
      cells,
    };
  } catch (err) {
    return null;
  }
}

function cloneArtwork(raw) {
  if (!raw || typeof raw !== "object") return null;
  const palette = Array.isArray(raw.palette)
    ? raw.palette.map((item) => ({ ...item }))
    : [];
  const cells = Array.isArray(raw.cells) ? raw.cells.map((cell) => ({ ...cell })) : [];
  return {
    ...raw,
    palette,
    cells,
  };
}

function parseDimension(value) {
  if (value === null || value === undefined) return null;
  const num = Number.parseFloat(value);
  return Number.isFinite(num) && num > 0 ? num : null;
}

function coerceId(value) {
  if (value === null || value === undefined) return undefined;
  if (typeof value === "number") return value;
  const trimmed = value.toString().trim();
  if (!trimmed) return undefined;
  if (/^-?\d+(?:\.\d+)?$/.test(trimmed) && !/^0\d+/.test(trimmed)) {
    const num = Number(trimmed);
    if (Number.isFinite(num)) return num;
  }
  return trimmed;
}

function parseSvgArtwork(raw, meta = {}) {
  try {
    const parser = new DOMParser();
    const doc = parser.parseFromString(raw, "image/svg+xml");
    if (!doc) {
      return { ok: false, error: "Unable to parse the SVG markup." };
    }
    if (doc.querySelector("parsererror")) {
      return { ok: false, error: "The SVG markup contains syntax errors." };
    }
    const svgEl = doc.querySelector("svg");
    if (!svgEl) {
      return { ok: false, error: "The SVG is missing a <svg> root element." };
    }

    let width = parseDimension(svgEl.getAttribute("width"));
    let height = parseDimension(svgEl.getAttribute("height"));
    const viewBox = svgEl.getAttribute("viewBox");
    if ((!width || !height) && viewBox) {
      const parts = viewBox
        .trim()
        .split(/[ ,]+/)
        .map((v) => Number.parseFloat(v))
        .filter((v) => Number.isFinite(v));
      if (parts.length >= 4) {
        width = width || parts[2];
        height = height || parts[3];
      }
    }
    if (!width || !height) {
      return { ok: false, error: "The SVG must include width/height or a valid viewBox." };
    }

    const rawNodes = Array.from(svgEl.querySelectorAll("[data-cell-id]"));
    const nodes = rawNodes.filter((node) => {
      const parent = node.parentElement?.closest?.("[data-cell-id]");
      return !parent;
    });
    if (!nodes.length) {
      return {
        ok: false,
        error:
          "No paintable regions were found. Each region needs a data-cell-id attribute.",
      };
    }

    const paletteMap = new Map();
    const cells = [];

    nodes.forEach((node, index) => {
      const cellId = (node.getAttribute("data-cell-id") || "").trim() || `c${index + 1}`;
      const colorSource = node.getAttribute("data-color-id") ?? node.getAttribute("data-color");
      const resolvedColorId = coerceId(colorSource ?? index + 1) ?? index + 1;
      const paletteKey = String(resolvedColorId);

      const pathNodes = [];
      if (node.tagName && node.tagName.toLowerCase() === "path") {
        pathNodes.push(node);
      }
      node.querySelectorAll?.("path").forEach((el) => {
        pathNodes.push(el);
      });

      const segments = pathNodes
        .map((el) => (el.getAttribute("d") || "").trim())
        .filter((d) => d.length > 0);
      if (!segments.length) {
        throw new Error(`Region ${cellId} is missing path data.`);
      }
      const d = segments.join(" ");

      let colorValue =
        node.getAttribute("data-color-hex") ||
        node.getAttribute("data-color-rgba") ||
        node.getAttribute("data-color") ||
        node.getAttribute("fill");
      if ((!colorValue || !colorValue.trim()) && pathNodes.length) {
        for (const path of pathNodes) {
          const fill = path.getAttribute("fill");
          if (fill && fill.trim()) {
            colorValue = fill.trim();
            break;
          }
        }
      }
      const paletteName = (node.getAttribute("data-color-name") || "").trim();

      const existing = paletteMap.get(paletteKey);
      if (existing) {
        if (!existing.name && paletteName) existing.name = paletteName;
        if (!existing.rgba && colorValue) existing.rgba = colorValue;
      } else {
        paletteMap.set(paletteKey, {
          id: resolvedColorId,
          name: paletteName || undefined,
          rgba: (colorValue && colorValue.trim()) || undefined,
        });
      }

      cells.push({
        id: cellId,
        colorId: paletteMap.get(paletteKey).id,
        d,
      });
    });

    const palette = Array.from(paletteMap.values()).map((entry) => ({
      id: entry.id,
      name: entry.name || `Color ${entry.id}`,
      rgba: entry.rgba || "#94a3b8",
    }));
    palette.sort((a, b) => {
      const aNum = typeof a.id === "number" ? a.id : Number.NaN;
      const bNum = typeof b.id === "number" ? b.id : Number.NaN;
      if (Number.isFinite(aNum) && Number.isFinite(bNum)) return aNum - bNum;
      return a.id.toString().localeCompare(b.id.toString());
    });

    const filename = (meta?.filename || "").replace(/\.[^./]+$/, "");
    const rawTitle =
      svgEl.getAttribute("data-title") ||
      svgEl.getAttribute("title") ||
      doc.querySelector("title")?.textContent ||
      filename ||
      "Imported artwork";
    const title = rawTitle.toString().trim() || "Imported artwork";
    const rawId =
      svgEl.getAttribute("data-art-id") ||
      svgEl.getAttribute("id") ||
      (filename || "").trim();
    let id = (rawId || "").toString().trim();
    if (!id) {
      id = title
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "");
    }

    const normalized = normalizeArtwork({
      id,
      title,
      width,
      height,
      palette,
      cells,
    });
    if (!normalized) {
      return { ok: false, error: "The SVG is missing required artwork metadata." };
    }
    return { ok: true, artwork: normalized };
  } catch (err) {
    return {
      ok: false,
      error:
        err instanceof Error ? err.message : "Unable to convert the SVG into artwork data.",
    };
  }
}

function parseArtworkPayload(raw, meta = {}) {
  const text = typeof raw === "string" ? raw.trim() : "";
  if (!text) {
    return { ok: false, error: "Paste artwork JSON or SVG first." };
  }
  if (text.startsWith("<")) {
    return parseSvgArtwork(text, meta);
  }
  try {
    const parsed = JSON.parse(text);
    let candidate = parsed;
    if (Array.isArray(candidate)) {
      candidate = candidate[0];
    }
    if (candidate && typeof candidate === "object" && candidate.artwork) {
      candidate = candidate.artwork;
    }
    const normalized = normalizeArtwork(candidate);
    if (!normalized) {
      return {
        ok: false,
        error:
          "The JSON is missing required fields (id, title, width, height, palette, cells).",
      };
    }
    return { ok: true, artwork: normalized };
  } catch (err) {
    return {
      ok: false,
      error: err instanceof Error ? err.message : "Unable to parse the JSON payload.",
    };
  }
}

function loadStoredArtworks() {
  try {
    const raw = localStorage.getItem(ARTWORKS_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    const normalized = (Array.isArray(parsed) ? parsed : [])
      .map((art) => normalizeArtwork(art))
      .filter(Boolean);
    return normalized;
  } catch (err) {
    return [];
  }
}

function persistArtworks(list) {
  try {
    localStorage.setItem(ARTWORKS_KEY, JSON.stringify(list));
  } catch (err) {}
}

function loadActiveArtworkId(artworks) {
  try {
    const stored = localStorage.getItem(ACTIVE_ART_KEY);
    if (!stored) return artworks?.[0]?.id ?? null;
    return artworks?.some((art) => art.id === stored) ? stored : artworks?.[0]?.id ?? null;
  } catch (err) {
    return artworks?.[0]?.id ?? null;
  }
}

function persistActiveArtworkId(id) {
  try {
    if (id) {
      localStorage.setItem(ACTIVE_ART_KEY, id);
    } else {
      localStorage.removeItem(ACTIVE_ART_KEY);
    }
  } catch (err) {}
}

const DEFAULT_CONFIG = {
  enableAutosave: true,
  autoAdvanceOnComplete: true,
  enableHintPulse: true,
  enableDragFill: true,
  enableEyedropper: true,
  enableKeyboardShortcuts: true,
  showNumberBadges: true,
  showHeatmapDots: true,
  enableSmokeHud: true,
};

const CONFIG_KEY = "capybooper_config";

function loadConfig() {
  try {
    const raw = localStorage.getItem(CONFIG_KEY);
    if (!raw) return DEFAULT_CONFIG;
    const parsed = JSON.parse(raw);
    return { ...DEFAULT_CONFIG, ...parsed };
  } catch (err) {
    return DEFAULT_CONFIG;
  }
}

function persistConfig(next) {
  try {
    localStorage.setItem(CONFIG_KEY, JSON.stringify(next));
  } catch (err) {}
}

function shallowEqual(a, b) {
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) return false;
  for (const key of keysA) if (a[key] !== b[key]) return false;
  return true;
}

function loadSave(art) {
  if (!art) return undefined;
  try {
    const raw = localStorage.getItem(SAVE_KEY(art.id));
    if (!raw) return undefined;
    const s = JSON.parse(raw);
    if (s.artworkId !== art.id) return undefined;
    return s;
  } catch (err) {
    return undefined;
  }
}

function persistSave(art, s) {
  if (!art) return;
  try {
    localStorage.setItem(SAVE_KEY(art.id), JSON.stringify(s));
  } catch (err) {}
}

function clearSave(artId) {
  try {
    localStorage.removeItem(SAVE_KEY(artId));
  } catch (err) {}
}

function computeRemaining(art, filled) {
  if (!art) return {};
  const map = {};
  for (const p of art.palette) map[p.id] = 0;
  for (const c of art.cells) if (!filled[c.id]) map[c.colorId] = (map[c.colorId] ?? 0) + 1;
  return map;
}

// ---------- App ----------
function App() {
  const initialConfig = useMemo(() => loadConfig(), []);
  const initialArtworksRef = useRef(null);

  if (initialArtworksRef.current === null) {
    initialArtworksRef.current = loadStoredArtworks();
  }

  const [artworks, setArtworks] = useState(initialArtworksRef.current);
  const [activeArtworkId, setActiveArtworkIdState] = useState(() =>
    loadActiveArtworkId(initialArtworksRef.current)
  );
  const [config, setConfig] = useState(initialConfig);
  const isDefaultConfig = useMemo(() => shallowEqual(config, DEFAULT_CONFIG), [config]);

  const art = useMemo(() => {
    const match = artworks.find((entry) => entry.id === activeArtworkId);
    return match ?? artworks[0] ?? null;
  }, [artworks, activeArtworkId]);

  const [filled, setFilled] = useState({});
  const [activeColor, setActiveColor] = useState(art?.palette?.[0]?.id ?? null);
  const [scale, setScale] = useState(0.9);
  const [offset, setOffset] = useState({ x: 50, y: 50 });
  const [lastAction, setLastAction] = useState(null);
  const [hintPulse, setHintPulse] = useState(new Set());
  const [showTests, setShowTests] = useState(initialConfig.enableSmokeHud);
  const [showOptions, setShowOptions] = useState(false);
  const [showLibrary, setShowLibrary] = useState(false);
  const [libraryRevision, setLibraryRevision] = useState(0);
  const [starterStatus, setStarterStatus] = useState(
    initialArtworksRef.current.length
      ? { state: "ready", error: null }
      : { state: "idle", error: null }
  );

  const selectArtwork = useCallback((id) => {
    setActiveArtworkIdState(id);
    persistActiveArtworkId(id ?? null);
  }, []);

  useEffect(() => {
    if (initialArtworksRef.current.length) return;

    let cancelled = false;
    const controller = new AbortController();

    async function bootstrap() {
      setStarterStatus({ state: "loading", error: null });
      try {
        const { artworks: loaded, errors } = await loadStarterArtworks(controller.signal);
        if (cancelled) return;
        initialArtworksRef.current = loaded;
        setArtworks(loaded);
        const nextId = loadActiveArtworkId(loaded);
        if (nextId) {
          selectArtwork(nextId);
        }
        setStarterStatus({
          state: "ready",
          error: errors.length
            ? errors[0] instanceof Error
              ? errors[0].message
              : "Unable to load all starter artworks."
            : null,
        });
      } catch (err) {
        if (cancelled) return;
        const fallback = getLegacyStarterArtworks();
        initialArtworksRef.current = fallback;
        setArtworks(fallback);
        const nextId = loadActiveArtworkId(fallback);
        if (nextId) {
          selectArtwork(nextId);
        }
        setStarterStatus({
          state: "error",
          error: err instanceof Error ? err.message : "Unable to load starter artworks.",
        });
      }
    }

    bootstrap();

    return () => {
      cancelled = true;
      controller.abort();
    };
  }, [selectArtwork]);

  useEffect(() => {
    persistArtworks(artworks);
  }, [artworks]);

  useEffect(() => {
    if (!artworks.length) {
      selectArtwork(null);
      return;
    }
    if (!artworks.some((entry) => entry.id === activeArtworkId)) {
      selectArtwork(artworks[0].id);
    }
  }, [artworks, activeArtworkId, selectArtwork]);

  useEffect(() => {
    if (!art) {
      setFilled({});
      setActiveColor(null);
      setScale(0.9);
      setOffset({ x: 50, y: 50 });
      setLastAction(null);
      setHintPulse(new Set());
      return;
    }
    const saved = loadSave(art);
    setFilled(saved?.filled ?? {});
    setActiveColor(saved?.activeColor ?? art.palette?.[0]?.id ?? null);
    setScale(saved?.viewport?.scale ?? 0.9);
    setOffset({
      x: saved?.viewport?.x ?? 50,
      y: saved?.viewport?.y ?? 50,
    });
    setLastAction(null);
    setHintPulse(new Set());
  }, [art?.id]);

  const {
    enableAutosave,
    autoAdvanceOnComplete,
    enableHintPulse,
    enableDragFill,
    enableEyedropper,
    enableKeyboardShortcuts,
    showNumberBadges,
    showHeatmapDots,
    enableSmokeHud,
  } = config;

  useEffect(() => {
    if (!enableAutosave || !art) return;
    const t = setTimeout(() => {
      persistSave(art, {
        artworkId: art.id,
        filled,
        activeColor,
        viewport: { scale, x: offset.x, y: offset.y },
        lastSaved: Date.now(),
      });
    }, 800);
    return () => clearTimeout(t);
  }, [art, filled, activeColor, scale, offset, enableAutosave]);

  const remaining = useMemo(() => computeRemaining(art, filled), [art, filled]);
  const totalCells = art?.cells?.length ?? 0;
  const filledCount = Object.values(filled).filter(Boolean).length;
  const progress = totalCells > 0 ? Math.round((filledCount / totalCells) * 100) : 0;

  const libraryProgress = useMemo(() => {
    const map = {};
    artworks.forEach((entry) => {
      if (!entry) return;
      if (art && entry.id === art.id) {
        map[entry.id] = progress;
        return;
      }
      const total = entry.cells?.length ?? 0;
      const saved = loadSave(entry);
      if (!saved) {
        map[entry.id] = 0;
        return;
      }
      const count = Object.values(saved.filled ?? {}).filter(Boolean).length;
      map[entry.id] = total > 0 ? Math.round((count / total) * 100) : 0;
    });
    return map;
  }, [artworks, art?.id, progress, libraryRevision]);

  const handleImportArtwork = useCallback(
    (raw, meta = {}) => {
      const result = parseArtworkPayload(typeof raw === "string" ? raw : "", meta);
      if (!result.ok || !result.artwork) {
        return result;
      }
      const normalized = result.artwork;
      const existingIds = new Set(artworks.map((item) => item.id));
      const baseId = normalized.id || `art-${Math.random().toString(36).slice(2, 8)}`;
      let uniqueId = baseId;
      let suffix = 2;
      while (existingIds.has(uniqueId)) {
        uniqueId = `${baseId}-${suffix++}`;
      }
      const finalArtwork = cloneArtwork({ ...normalized, id: uniqueId });
      setArtworks((prev) => [...prev, finalArtwork]);
      selectArtwork(finalArtwork.id);
      setLibraryRevision((v) => v + 1);
      return { ok: true, artwork: finalArtwork };
    },
    [artworks, selectArtwork]
  );

  const handleDeleteArtwork = useCallback(
    (id) => {
      setArtworks((prev) => {
        const next = prev.filter((entry) => entry.id !== id);
        if (!next.length) {
          selectArtwork(null);
          return [];
        }
        if (!next.some((entry) => entry.id === activeArtworkId)) {
          selectArtwork(next[0].id);
        }
        return next;
      });
      clearSave(id);
      setLibraryRevision((v) => v + 1);
      if (art && art.id === id) {
        setFilled({});
        setActiveColor(null);
        setScale(0.9);
        setOffset({ x: 50, y: 50 });
        setLastAction(null);
        setHintPulse(new Set());
        setShowLibrary(true);
      }
    },
    [art, activeArtworkId, selectArtwork, setShowLibrary]
  );

  const handleRenameArtwork = useCallback((id, nextTitle) => {
    const title = (nextTitle ?? "").trim() || "Untitled artwork";
    setArtworks((prev) => prev.map((entry) => (entry.id === id ? { ...entry, title } : entry)));
  }, []);

  const handleClearProgress = useCallback(
    (id) => {
      clearSave(id);
      setLibraryRevision((v) => v + 1);
      if (art && art.id === id) {
        setFilled({});
        setActiveColor(art.palette?.[0]?.id ?? null);
        setScale(0.9);
        setOffset({ x: 50, y: 50 });
        setLastAction(null);
        setHintPulse(new Set());
      }
    },
    [art]
  );

  const previousSmokePreferenceRef = useRef(initialConfig.enableSmokeHud);

  useEffect(() => {
    if (!enableSmokeHud) {
      previousSmokePreferenceRef.current = showTests;
      setShowTests(false);
    } else {
      setShowTests((prev) => prev || previousSmokePreferenceRef.current);
    }
  }, [enableSmokeHud, showTests]);

  useEffect(() => {
    if (!showOptions) return;
    function onKeyDown(e) {
      if (e.key === "Escape") setShowOptions(false);
    }
    window.addEventListener("keydown", onKeyDown);
    return () => window.removeEventListener("keydown", onKeyDown);
  }, [showOptions]);

  const svgRef = useRef(null);
  const isPanningRef = useRef(false);
  const isPaintingRef = useRef(false);
  const lastPosRef = useRef(null);
  const movedRef = useRef(0);
  const eyedropCandidateRef = useRef(null);
  const pointersRef = useRef(new Map());
  const pinchRef = useRef(null);
  const zoomAnimRef = useRef(null);

  const cancelZoomAnimation = useCallback(() => {
    if (zoomAnimRef.current) {
      cancelAnimationFrame(zoomAnimRef.current);
      zoomAnimRef.current = null;
    }
  }, []);

  const smoothZoomTo = useCallback(
    (targetScale, clientX, clientY) => {
      if (!art) return;
      const svg = svgRef.current;
      if (!svg) return;
      const { pxArt, pyArt } = cssToArt(svg, clientX, clientY);
      const artX = (pxArt - offset.x) / scale;
      const artY = (pyArt - offset.y) / scale;
      const clamped = clamp(targetScale, 0.3, 4);
      const targetOffset = {
        x: pxArt - artX * clamped,
        y: pyArt - artY * clamped,
      };
      cancelZoomAnimation();
      const duration = 180;
      const start = performance.now();
      const startScale = scale;
      const startOffset = { x: offset.x, y: offset.y };

      function step(now) {
        const t = Math.min((now - start) / duration, 1);
        const eased = 1 - Math.pow(1 - t, 3);
        const nextScale = startScale + (clamped - startScale) * eased;
        const nextOffset = {
          x: startOffset.x + (targetOffset.x - startOffset.x) * eased,
          y: startOffset.y + (targetOffset.y - startOffset.y) * eased,
        };
        setScale(nextScale);
        setOffset(nextOffset);
        if (t < 1) {
          zoomAnimRef.current = requestAnimationFrame(step);
        } else {
          zoomAnimRef.current = null;
        }
      }

      if (Math.abs(clamped - startScale) < 1e-3) {
        setScale(clamped);
        setOffset(targetOffset);
        return;
      }

      zoomAnimRef.current = requestAnimationFrame(step);
    },
    [art, cancelZoomAnimation, offset.x, offset.y, scale]
  );

  useEffect(() => {
    return () => cancelZoomAnimation();
  }, [cancelZoomAnimation]);

  function cssToArt(svg, clientX, clientY) {
    if (!art) return { pxArt: 0, pyArt: 0 };
    const rect = svg.getBoundingClientRect();
    const sx = art.width / rect.width;
    const sy = art.height / rect.height;
    const pxArt = (clientX - rect.left) * sx;
    const pyArt = (clientY - rect.top) * sy;
    return { pxArt, pyArt };
  }

  function onWheel(e) {
    if (!art) return;
    e.preventDefault();
    const factor = Math.exp(-e.deltaY * 0.0012);
    const proposed = scale * factor;
    smoothZoomTo(proposed, e.clientX, e.clientY);
  }

  function onPointerDown(e) {
    if (!art) return;
    const svg = svgRef.current;
    svg?.setPointerCapture?.(e.pointerId);
    pointersRef.current.set(e.pointerId, { x: e.clientX, y: e.clientY });

    const target = e.target;
    const cid = target?.dataset?.cellId;
    movedRef.current = 0;

    if (e.pointerType === "mouse" && (e.button === 2 || e.button === 1 || e.ctrlKey)) {
      e.preventDefault();
      cancelZoomAnimation();
      isPaintingRef.current = false;
      eyedropCandidateRef.current = null;
      isPanningRef.current = true;
      lastPosRef.current = { x: e.clientX, y: e.clientY };
      return;
    }

    if (pointersRef.current.size === 2 && !pinchRef.current) {
      cancelZoomAnimation();
      const ids = Array.from(pointersRef.current.keys());
      const p1 = pointersRef.current.get(ids[0]);
      const p2 = pointersRef.current.get(ids[1]);
      const d0 = Math.hypot(p2.x - p1.x, p2.y - p1.y);
      const mid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      pinchRef.current = { id1: ids[0], id2: ids[1], d0, s0: scale, mid0: mid };
      isPanningRef.current = false;
      isPaintingRef.current = false;
      eyedropCandidateRef.current = null;
      return;
    }

    if (cid) {
      cancelZoomAnimation();
      const already = !!filled[cid];
      if (already) {
        eyedropCandidateRef.current = enableEyedropper ? cid : null;
        isPanningRef.current = true;
        lastPosRef.current = { x: e.clientX, y: e.clientY };
        return;
      }
      isPaintingRef.current = true;
      onCellTap(cid);
      return;
    }
    cancelZoomAnimation();
    isPanningRef.current = true;
    lastPosRef.current = { x: e.clientX, y: e.clientY };
  }

  function onPointerMove(e) {
    if (!art) return;
    const svg = svgRef.current;
    pointersRef.current.set(e.pointerId, { x: e.clientX, y: e.clientY });

    if (pinchRef.current) {
      const { id1, id2, d0, s0, mid0 } = pinchRef.current;
      const p1 = pointersRef.current.get(id1);
      const p2 = pointersRef.current.get(id2);
      if (p1 && p2) {
        const d = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        const factor = d0 > 0 ? d / d0 : 1;
        const newScale = clamp(s0 * factor, 0.3, 4);
        const { pxArt, pyArt } = cssToArt(svg, mid0.x, mid0.y);
        const artX = (pxArt - offset.x) / scale;
        const artY = (pyArt - offset.y) / scale;
        setOffset({ x: pxArt - artX * newScale, y: pyArt - artY * newScale });
        setScale(newScale);
      }
      return;
    }

    if (isPaintingRef.current) {
      if (!enableDragFill) return;
      const target = e.target;
      const id = target?.dataset?.cellId;
      if (id) onCellTap(id);
      return;
    }

    if (isPanningRef.current && lastPosRef.current) {
      const rect = svg.getBoundingClientRect();
      const sx = art.width / rect.width;
      const sy = art.height / rect.height;
      const dxPx = e.clientX - lastPosRef.current.x;
      const dyPx = e.clientY - lastPosRef.current.y;
      movedRef.current += Math.hypot(dxPx, dyPx);
      lastPosRef.current = { x: e.clientX, y: e.clientY };
      setOffset((o) => ({ x: o.x + dxPx * sx, y: o.y + dyPx * sy }));
    }
  }

  function onPointerUp(e) {
    if (!art) return;
    const svg = svgRef.current;
    svg?.releasePointerCapture?.(e.pointerId);

    if (enableEyedropper && eyedropCandidateRef.current && movedRef.current < 6) {
      const cell = art.cells.find((c) => c.id === eyedropCandidateRef.current);
      if (cell && (remaining[cell.colorId] ?? 0) > 0) setActiveColor(cell.colorId);
    }

    pointersRef.current.delete(e.pointerId);
    if (pinchRef.current && (e.pointerId === pinchRef.current.id1 || e.pointerId === pinchRef.current.id2)) {
      pinchRef.current = null;
    }

    isPanningRef.current = false;
    isPaintingRef.current = false;
    lastPosRef.current = null;
    eyedropCandidateRef.current = null;
    movedRef.current = 0;
  }

  function onCellTap(cellId) {
    if (!art || activeColor == null) return;
    const cell = art.cells.find((c) => c.id === cellId);
    if (!cell) return;

    if (filled[cellId]) return;

    if (cell.colorId !== activeColor) {
      const el = document.getElementById(cellId);
      if (el) {
        el.setAttribute("stroke", "#d22");
        el.setAttribute("stroke-width", "4");
        setTimeout(() => {
          el.setAttribute("stroke", "#444");
          el.setAttribute("stroke-width", "2");
        }, 220);
      }
      return;
    }

    const willCompleteColor = (remaining[activeColor] ?? 0) === 1;
    setFilled((prev) => ({ ...prev, [cellId]: true }));
    setLastAction(cellId);
    if (willCompleteColor && autoAdvanceOnComplete) nextColor();
  }

  function undo() {
    if (!lastAction) return;
    setFilled((prev) => ({ ...prev, [lastAction]: false }));
    setLastAction(null);
  }

  function hint() {
    if (!enableHintPulse || !art || activeColor == null) return;
    const candidates = art.cells
      .filter((c) => c.colorId === activeColor && !filled[c.id])
      .sort((a, b) => (a.area ?? 0) - (b.area ?? 0))
      .slice(0, 3);
    const ids = new Set(candidates.map((c) => c.id));
    setHintPulse(ids);
    setTimeout(() => setHintPulse(new Set()), 1000);
  }

  function resetView() {
    setScale(0.9);
    setOffset({ x: 50, y: 50 });
  }

  function nextColor() {
    if (!art || activeColor == null) return;
    const order = art.palette.map((p) => p.id);
    const startIdx = order.indexOf(activeColor);
    for (let i = 1; i <= order.length; i++) {
      const id = order[(startIdx + i) % order.length];
      if ((remaining[id] ?? 0) > 0) {
        setActiveColor(id);
        return;
      }
    }
  }

  function handleConfigChange(key, value) {
    setConfig((prev) => {
      if (prev[key] === value) return prev;
      const next = { ...prev, [key]: value };
      persistConfig(next);
      return next;
    });
  }

  function handleConfigReset() {
    setConfig((prev) => {
      if (shallowEqual(prev, DEFAULT_CONFIG)) return prev;
      persistConfig(DEFAULT_CONFIG);
      return DEFAULT_CONFIG;
    });
    previousSmokePreferenceRef.current = DEFAULT_CONFIG.enableSmokeHud;
    setShowTests(DEFAULT_CONFIG.enableSmokeHud);
  }

  useEffect(() => {
    if (!enableKeyboardShortcuts) return;
    function onKey(e) {
      const lower = e.key.toLowerCase();
      if (e.key === "0") resetView();
      if (e.key === "+" || e.key === "=") setScale((s) => clamp(s * 1.1, 0.3, 4));
      if (e.key === "-" || e.key === "_") setScale((s) => clamp(s / 1.1, 0.3, 4));
      if (lower === "h") hint();
      if (lower === "n") nextColor();
      if (lower === "u") undo();
      if (lower === "t" && enableSmokeHud) setShowTests((v) => !v);
      if (e.key === "Escape") {
        if (showOptions) setShowOptions(false);
        if (showLibrary) setShowLibrary(false);
      }
      if (!art) return;
      const panStep = 80 / (scale || 1);
      if (lower === "w" || e.key === "ArrowUp") {
        e.preventDefault();
        setOffset((prev) => ({ ...prev, y: prev.y + panStep }));
      }
      if (lower === "s" || e.key === "ArrowDown") {
        e.preventDefault();
        setOffset((prev) => ({ ...prev, y: prev.y - panStep }));
      }
      if (lower === "a" || e.key === "ArrowLeft") {
        e.preventDefault();
        setOffset((prev) => ({ ...prev, x: prev.x + panStep }));
      }
      if (lower === "d" || e.key === "ArrowRight") {
        e.preventDefault();
        setOffset((prev) => ({ ...prev, x: prev.x - panStep }));
      }
    }
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [art, enableKeyboardShortcuts, enableSmokeHud, showOptions, showLibrary, scale]);
  return (
    React.createElement(
      "div",
      { style: styles.app },
      showLibrary &&
        React.createElement(ArtLibrary, {
          artworks: artworks,
          activeArtworkId: activeArtworkId,
          progressMap: libraryProgress,
          onSelect: (id) => {
            selectArtwork(id);
            setShowLibrary(false);
          },
          onClose: () => setShowLibrary(false),
          onImport: handleImportArtwork,
          onDelete: handleDeleteArtwork,
          onRename: handleRenameArtwork,
          onClearProgress: handleClearProgress,
        }),
      showOptions &&
        React.createElement(OptionsPanel, {
          config: config,
          onToggle: handleConfigChange,
          canReset: !isDefaultConfig,
          onReset: handleConfigReset,
          onClose: () => setShowOptions(false),
        }),
      starterStatus.error &&
        art &&
        React.createElement(
          "div",
          { style: styles.bootstrapBanner, role: "status" },
          `Starter art could not be loaded automatically (${starterStatus.error}). Import an SVG from the library to continue.`
        ),
      art
        ? React.createElement(
            "div",
            { style: styles.canvas },
            React.createElement(
              "svg",
              {
                ref: svgRef,
                width: "100%",
                height: "100%",
                viewBox: `0 0 ${art.width} ${art.height}`,
                style: { background: "#0f172a", touchAction: "none" },
                onWheel: onWheel,
                onPointerDown: onPointerDown,
                onPointerMove: onPointerMove,
                onPointerUp: onPointerUp,
                onContextMenu: (e) => e.preventDefault(),
              },
              React.createElement(
                "g",
                { transform: `translate(${offset.x} ${offset.y}) scale(${scale})` },
                React.createElement("rect", {
                  x: 0,
                  y: 0,
                  width: art.width,
                  height: art.height,
                  fill: "#0f172a",
                  stroke: "#1e293b",
                }),
                art.cells.map((c) => {
                  const isFilled = !!filled[c.id];
                  const pal = art.palette.find((p) => p.id === c.colorId);
                  const showPulse = hintPulse.has(c.id);
                  return React.createElement(
                    "g",
                    { key: c.id },
                    React.createElement(
                      "title",
                      null,
                      `Region ${c.id} – Color #${c.colorId}${pal?.name ? ` (${pal.name})` : ""}`
                    ),
                    isFilled &&
                      React.createElement("path", {
                        d: c.d,
                        fill: pal?.rgba,
                        pointerEvents: "none",
                      }),
                    React.createElement("path", {
                      id: c.id,
                      "data-cell-id": c.id,
                      "data-color-id": c.colorId,
                      d: c.d,
                      fill: isFilled ? "transparent" : "#0f172a",
                      stroke: showPulse ? "#f2c200" : "#334155",
                      strokeWidth: showPulse ? 4 : 2,
                      style: {
                        cursor: isFilled ? "grab" : "pointer",
                        opacity: isFilled ? 0.35 : 1,
                      },
                      "aria-label": `Cell ${c.id}. Target color ${c.colorId}. ${isFilled ? "Filled" : "Unfilled"}`,
                    }),
                    !isFilled && showNumberBadges && scale >= 0.6 &&
                      React.createElement(NumberLabel, {
                        d: c.d,
                        text: `${c.colorId}`,
                        area: c.area,
                      }),
                    !isFilled && showHeatmapDots && scale < 0.6 &&
                      React.createElement(HeatDot, { d: c.d })
                  );
                })
              )
            )
          )
        : React.createElement(
            "div",
            { style: styles.emptyState },
            starterStatus.state === "loading"
              ? "Loading starter artwork…"
              : starterStatus.error
              ? `Starter art could not be loaded automatically (${starterStatus.error}). Use the library to import a file.`
              : "Import or add an artwork in the library to start painting."
          ),
      art &&
        enableSmokeHud &&
        showTests &&
        React.createElement(SmokeTests, { art: art, filled: filled }),
      art &&
        React.createElement(
          "header",
          { style: styles.topBar, role: "banner" },
          React.createElement(
            "div",
            { style: styles.topContext },
            React.createElement("span", { style: styles.topTitle }, art.title),
            React.createElement(
              "span",
              {
                style: styles.topProgress,
                "data-testid": "progress-indicator",
                title: `${progress}% complete`,
                "aria-label": `${progress}% complete`,
                "aria-live": "polite",
              },
              `${progress}%`
            )
          ),
          React.createElement(
            "nav",
            { style: styles.topActions, "aria-label": "Canvas controls" },
            React.createElement(
              "button",
              {
                type: "button",
                style: styles.controlButton,
                onClick: () => setShowLibrary(true),
                title: "Open art library",
                "aria-label": "Open art library",
              },
              "Library"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: styles.controlButton,
                onClick: () => setShowOptions(true),
                title: "Adjust options",
                "aria-label": "Adjust options",
              },
              "Options"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: styles.controlButton,
                onClick: resetView,
                title: "Reset view",
                "aria-label": "Reset view",
              },
              "Reset"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: styles.controlButton,
                onClick: undo,
                title: "Undo last fill",
                "aria-label": "Undo last fill",
              },
              "Undo"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: {
                  ...styles.controlButton,
                  opacity: enableHintPulse ? 1 : 0.45,
                  cursor: enableHintPulse ? "pointer" : "not-allowed",
                },
                onClick: hint,
                title: "Highlight a suggested cell",
                disabled: !enableHintPulse,
                "aria-label": "Highlight a suggested cell",
              },
              "Hint"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: styles.controlButton,
                onClick: nextColor,
                title: "Jump to the next color",
                "aria-label": "Jump to the next color",
              },
              "Next"
            ),
            React.createElement(
              "button",
              {
                type: "button",
                style: {
                  ...styles.controlButton,
                  opacity: enableSmokeHud ? 1 : 0.45,
                  cursor: enableSmokeHud ? "pointer" : "not-allowed",
                },
                onClick: () => enableSmokeHud && setShowTests((v) => !v),
                title: "Toggle the smoke test HUD",
                disabled: !enableSmokeHud,
                "aria-pressed": showTests,
                "aria-label": "Toggle the smoke test HUD",
              },
              "Tests"
            )
          )
        ),
      art &&
        React.createElement(
          "div",
          { style: styles.paletteDock, "data-testid": "palette-dock" },
          React.createElement(Palette, {
            palette: art.palette,
            remaining: remaining,
            activeColor: activeColor,
            onSelect: setActiveColor,
          })
        )
    )
  );
}

// ---------- Helpers: Number label & heat dot ----------

function ensureMeasureSvg() {
  if (typeof document === "undefined") return null;
  if (!measureSvgEl) {
    const svg = document.createElementNS(SVG_NS, "svg");
    svg.setAttribute("aria-hidden", "true");
    svg.setAttribute("width", "0");
    svg.setAttribute("height", "0");
    svg.style.position = "absolute";
    svg.style.width = "0";
    svg.style.height = "0";
    svg.style.opacity = "0";
    svg.style.pointerEvents = "none";
    document.body.appendChild(svg);
    measureSvgEl = svg;
  }
  return measureSvgEl;
}

function ensureMeasureContext() {
  if (typeof document === "undefined") return null;
  if (!measureCanvasCtx) {
    const canvas = document.createElement("canvas");
    canvas.width = canvas.height = 1;
    measureCanvasCtx = canvas.getContext("2d");
  }
  return measureCanvasCtx;
}

function measurePathBox(d) {
  if (pathBoxCache.has(d)) return pathBoxCache.get(d);
  const host = ensureMeasureSvg();
  if (!host) return null;
  try {
    const path = document.createElementNS(SVG_NS, "path");
    path.setAttribute("d", d);
    host.appendChild(path);
    const box = path.getBBox();
    host.removeChild(path);
    pathBoxCache.set(d, box);
    return box;
  } catch (err) {
    return null;
  }
}

function measurePathArea(d, bbox) {
  if (pathAreaCache.has(d)) return pathAreaCache.get(d);
  const ctx = ensureMeasureContext();
  if (!ctx || !bbox) return null;
  if (typeof Path2D === "undefined") return null;
  let path;
  try {
    path = new Path2D(d);
  } catch (err) {
    return null;
  }

  const longest = Math.max(bbox.width, bbox.height);
  const steps = Math.max(12, Math.min(80, Math.ceil(longest / 8)));
  if (!Number.isFinite(steps) || steps <= 0) return null;

  const stepX = bbox.width / steps;
  const stepY = bbox.height / steps;
  if (!Number.isFinite(stepX) || !Number.isFinite(stepY)) return null;

  let inside = 0;
  const total = steps * steps;
  const originX = bbox.x + stepX / 2;
  const originY = bbox.y + stepY / 2;

  for (let ix = 0; ix < steps; ix++) {
    const x = originX + ix * stepX;
    for (let iy = 0; iy < steps; iy++) {
      const y = originY + iy * stepY;
      if (ctx.isPointInPath(path, x, y)) inside++;
    }
  }

  if (inside === 0) return null;
  const area = (inside / total) * bbox.width * bbox.height;
  pathAreaCache.set(d, area);
  return area;
}

function findInteriorPoint(d, fallback, bbox) {
  const ctx = ensureMeasureContext();
  if (!ctx) return fallback;
  if (typeof Path2D === "undefined") return fallback;
  let path;
  try {
    path = new Path2D(d);
  } catch (err) {
    return fallback;
  }

  const cached = interiorPointCache.get(d);
  if (cached && ctx.isPointInPath(path, cached.x, cached.y)) {
    return cached;
  }

  const center = bbox
    ? { x: bbox.x + bbox.width / 2, y: bbox.y + bbox.height / 2 }
    : fallback;
  const candidates = [fallback];
  if (bbox) {
    candidates.push(
      center,
      { x: bbox.x + bbox.width * 0.3, y: bbox.y + bbox.height * 0.5 },
      { x: bbox.x + bbox.width * 0.7, y: bbox.y + bbox.height * 0.5 },
      { x: bbox.x + bbox.width * 0.5, y: bbox.y + bbox.height * 0.3 },
      { x: bbox.x + bbox.width * 0.5, y: bbox.y + bbox.height * 0.7 }
    );
  }

  for (const candidate of candidates) {
    if (!candidate) continue;
    if (ctx.isPointInPath(path, candidate.x, candidate.y)) return candidate;
  }

  if (!bbox) return fallback;

  const centerX = bbox.x + bbox.width / 2;
  const centerY = bbox.y + bbox.height / 2;
  const longest = Math.max(bbox.width, bbox.height);
  const steps = Math.max(6, Math.ceil(longest / 60));
  const stepX = bbox.width / (steps + 1);
  const stepY = bbox.height / (steps + 1);

  let best = null;
  let bestScore = -Infinity;

  for (let i = 0; i <= steps; i++) {
    for (let j = 0; j <= steps; j++) {
      const x = bbox.x + (i + 0.5) * stepX;
      const y = bbox.y + (j + 0.5) * stepY;
      if (!ctx.isPointInPath(path, x, y)) continue;
      const dx = x - centerX;
      const dy = y - centerY;
      const score = -(dx * dx + dy * dy);
      if (score > bestScore) {
        best = { x, y };
        bestScore = score;
      }
    }
  }

  if (best) {
    interiorPointCache.set(d, best);
    return best;
  }

  const maxRadius = Math.hypot(bbox.width, bbox.height) / 2;
  const rings = Math.max(3, Math.ceil(longest / 45));
  const samplesPerRing = Math.max(12, Math.ceil(longest / 30));

  for (let r = 1; r <= rings; r++) {
    const radius = (r / rings) * maxRadius;
    for (let i = 0; i < samplesPerRing; i++) {
      const angle = (i / samplesPerRing) * Math.PI * 2;
      const x = centerX + Math.cos(angle) * radius;
      const y = centerY + Math.sin(angle) * radius;
      if (ctx.isPointInPath(path, x, y)) {
        const point = { x, y };
        interiorPointCache.set(d, point);
        return point;
      }
    }
  }

  if (fallback && ctx.isPointInPath(path, fallback.x, fallback.y)) {
    interiorPointCache.set(d, fallback);
  }
  return best ?? fallback;
}

function computeLabelMetrics(bbox, area) {
  const defaults = { radius: 16, fontSize: 24, showBubble: true };
  if (!bbox) return defaults;

  const minSide = Math.max(0, Math.min(bbox.width, bbox.height));
  if (minSide === 0) return defaults;

  const areaRadius = area && area > 0 ? Math.sqrt(area) / 14 : 0;
  let radius = Math.max(6, Math.min(18, Math.max(minSide / 2.6, areaRadius)));
  const maxRadius = Math.max(4, minSide / 2 - 1);
  radius = Math.min(radius, maxRadius);
  if (!Number.isFinite(radius) || radius <= 0) {
    radius = 10;
  }

  const showBubble = radius >= 6 && minSide >= 14;
  if (!showBubble) {
    const fontSize = Math.max(9, Math.min(16, minSide * 0.9));
    return { radius: 0, fontSize, showBubble };
  }

  const fontSize = Math.max(10, Math.min(20, radius * 1.35));
  return { radius, fontSize, showBubble };
}
function centroidFromPath(d) {
  const tokens = d.split(/[ ,]/).filter(Boolean);
  const pts = [];
  for (let i = 0; i < tokens.length; i++) {
    const t = tokens[i];
    if (t === "M" || t === "L" || t === "Z") continue;
    const n = Number(t);
    if (!Number.isNaN(n)) pts.push(n);
  }
  const xy = [];
  for (let i = 0; i + 1 < pts.length; i += 2) xy.push([pts[i], pts[i + 1]]);
  let cx = 0,
    cy = 0,
    a = 0;
  for (let i = 0; i < xy.length; i++) {
    const [x1, y1] = xy[i];
    const [x2, y2] = xy[(i + 1) % xy.length];
    const cross = x1 * y2 - x2 * y1;
    a += cross;
    cx += (x1 + x2) * cross;
    cy += (y1 + y2) * cross;
  }
  a *= 0.5;
  if (Math.abs(a) < 1e-5) return { x: xy[0]?.[0] ?? 0, y: xy[0]?.[1] ?? 0 };
  return { x: cx / (6 * a), y: cy / (6 * a) };
}

const pointAlmostEqual = (a, b) =>
  a === b || (a && b && Math.abs(a.x - b.x) < 0.01 && Math.abs(a.y - b.y) < 0.01);

const metricsAlmostEqual = (a, b) =>
  a === b ||
  (a &&
    b &&
    Math.abs(a.radius - b.radius) < 0.01 &&
    Math.abs(a.fontSize - b.fontSize) < 0.01 &&
    a.showBubble === b.showBubble);

function NumberLabel({ d, text, area }) {
  const fallback = useMemo(() => centroidFromPath(d), [d]);
  const [position, setPosition] = useState(fallback);
  const [metrics, setMetrics] = useState(() => ({ radius: 16, fontSize: 24, showBubble: true }));

  useLayoutEffect(() => {
    if (typeof document === "undefined") return;
    const bbox = measurePathBox(d);
    const nextPoint = findInteriorPoint(d, fallback, bbox);
    setPosition((prev) => (pointAlmostEqual(prev, nextPoint) ? prev : nextPoint));
    const measuredArea = measurePathArea(d, bbox);
    const areaHint = measuredArea ?? area;
    const nextMetrics = computeLabelMetrics(bbox, areaHint);
    setMetrics((prev) => (metricsAlmostEqual(prev, nextMetrics) ? prev : nextMetrics));
  }, [d, area, fallback.x, fallback.y]);

  const { x, y } = position;
  const { radius, fontSize, showBubble } = metrics;

  const textProps = {
    x,
    y,
    fontSize,
    textAnchor: "middle",
    dominantBaseline: "middle",
    fill: "#e2e8f0",
    fontFamily: "ui-sans-serif, system-ui",
  };

  if (!showBubble) {
    textProps.style = {
      paintOrder: "stroke",
      stroke: "rgba(15, 23, 42, 0.9)",
      strokeWidth: 3,
    };
  }

  return React.createElement(
    "g",
    { pointerEvents: "none" },
    showBubble &&
      React.createElement("circle", { cx: x, cy: y, r: radius, fill: "rgba(15, 23, 42, 0.9)" }),
    React.createElement("text", textProps, text)
  );
}

function HeatDot({ d }) {
  const { x, y } = centroidFromPath(d);
  return React.createElement("circle", { pointerEvents: "none", cx: x, cy: y, r: 6, fill: "#94a3b8" });
}

// ---------- Palette ----------
function Palette({ palette, remaining, activeColor, onSelect }) {
  return React.createElement(
    "div",
    { style: styles.paletteWrap },
    palette.map((p) => {
      const left = remaining[p.id] ?? 0;
      const isActive = p.id === activeColor;
      return React.createElement(
        "button",
        {
          key: p.id,
          onClick: () => onSelect(p.id),
          disabled: left === 0 && !isActive,
          "aria-pressed": isActive,
          "aria-label": `${p.name ?? "Color"} #${p.id}. ${left} cells remaining`,
          title: `${p.name ?? "Color"} #${p.id} • Remaining ${left}`,
          style: {
            ...styles.swatch,
            background: p.rgba,
            border: isActive
              ? "2px solid rgba(248, 250, 252, 0.85)"
              : "2px solid rgba(15, 23, 42, 0.6)",
            boxShadow: isActive
              ? "0 0 0 4px rgba(148, 163, 184, 0.45), 0 10px 24px rgba(2, 6, 23, 0.55)"
              : "0 8px 18px rgba(2, 6, 23, 0.45)",
            opacity: left === 0 && !isActive ? 0.35 : 1,
          },
        },
        React.createElement("span", { style: styles.swatchNumber }, p.id)
      );
    })
  );
}

function ArtLibrary({
  artworks,
  activeArtworkId,
  progressMap,
  onSelect,
  onClose,
  onImport,
  onDelete,
  onRename,
  onClearProgress,
}) {
  const [draft, setDraft] = useState("");
  const [feedback, setFeedback] = useState(null);
  const [editingId, setEditingId] = useState(null);
  const [titleDraft, setTitleDraft] = useState("");
  const [promptStatus, setPromptStatus] = useState(null);
  const promptTimerRef = useRef(null);

  const sorted = useMemo(
    () => [...artworks].sort((a, b) => a.title.localeCompare(b.title)),
    [artworks]
  );

  useEffect(() => {
    function handleKey(e) {
      if (e.key === "Escape") onClose();
    }
    window.addEventListener("keydown", handleKey);
    return () => window.removeEventListener("keydown", handleKey);
  }, [onClose]);

  useEffect(() => {
    return () => {
      if (promptTimerRef.current) clearTimeout(promptTimerRef.current);
    };
  }, []);

  const promptText = `You are an SVG color-by-number generator. Produce JSON with keys: id (short slug), title, width, height, palette (array of { id, name, rgba }), and cells (array of { id, colorId, d } path commands using only M/L/Z). Ensure 40-80 cells and 6-12 palette entries. Colors should be polished and themed. Return JSON only.`;

  function schedulePromptStatus(status) {
    setPromptStatus(status);
    if (promptTimerRef.current) {
      clearTimeout(promptTimerRef.current);
    }
    promptTimerRef.current = setTimeout(() => setPromptStatus(null), 2500);
  }

  function handleCopyPrompt() {
    const clipboard = navigator?.clipboard;
    if (clipboard?.writeText) {
      clipboard
        .writeText(promptText)
        .then(() =>
          schedulePromptStatus({ type: "success", message: "Prompt copied to clipboard." })
        )
        .catch(() =>
          schedulePromptStatus({
            type: "error",
            message: "Clipboard copy failed. Copy manually below.",
          })
        );
      return;
    }

    try {
      const textarea = document.createElement("textarea");
      textarea.value = promptText;
      textarea.setAttribute("readonly", "true");
      textarea.style.position = "absolute";
      textarea.style.left = "-9999px";
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand("copy");
      document.body.removeChild(textarea);
      schedulePromptStatus({ type: "success", message: "Prompt copied to clipboard." });
    } catch (err) {
      schedulePromptStatus({ type: "error", message: "Clipboard copy failed. Copy manually below." });
    }
  }

  function applyImportResult(result, sourceLabel) {
    if (result?.ok && result.artwork) {
      setDraft("");
      setFeedback({
        type: "success",
        message: `Imported "${result.artwork.title}"${sourceLabel ? ` from ${sourceLabel}` : ""}.`,
      });
      setEditingId(null);
      setTitleDraft("");
      return;
    }
    if (result?.error) {
      setFeedback({ type: "error", message: result.error });
      return;
    }
    setFeedback({ type: "error", message: "Unable to import artwork." });
  }

  function handleImportSubmit(e) {
    e?.preventDefault?.();
    const result = onImport(draft, { source: "textarea" });
    applyImportResult(result);
  }

  function handleFileUpload(e) {
    const file = e?.target?.files?.[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      const text = typeof reader.result === "string" ? reader.result : "";
      const outcome = onImport(text, { filename: file.name, type: file.type });
      applyImportResult(outcome, file.name);
    };
    reader.onerror = () => {
      setFeedback({ type: "error", message: `Unable to read ${file.name}.` });
    };
    reader.readAsText(file);
    if (e.target) e.target.value = "";
  }

  function startEditing(art) {
    setEditingId(art.id);
    setTitleDraft(art.title);
  }

  function saveEdit() {
    onRename(editingId, titleDraft);
    setEditingId(null);
    setTitleDraft("");
  }

  function cancelEdit() {
    setEditingId(null);
    setTitleDraft("");
  }

  const list = sorted.length
    ? sorted.map((art) => {
        const isActive = art.id === activeArtworkId;
        const isEditing = editingId === art.id;
        const progress = progressMap?.[art.id] ?? 0;
        return React.createElement(
          "div",
          {
            key: art.id,
            style: {
              ...styles.libraryItem,
              ...(isActive ? styles.libraryItemActive : {}),
            },
          },
          React.createElement(
            "div",
            { style: styles.libraryItemHeader },
            isEditing
              ? React.createElement("input", {
                  style: styles.libraryTitleInput,
                  value: titleDraft,
                  onChange: (e) => setTitleDraft(e.target.value),
                  autoFocus: true,
                })
              : React.createElement("div", { style: styles.libraryItemTitle }, art.title),
            React.createElement(
              "span",
              {
                style: {
                  ...styles.libraryBadge,
                  ...(isActive ? styles.libraryBadgeActive : {}),
                },
              },
              isActive ? "Active" : `${progress}%`
            )
          ),
          React.createElement(
            "div",
            { style: styles.libraryMeta },
            `Progress: ${progress}% - ${art.palette.length} colors - ${art.cells.length} cells`
          ),
          React.createElement(
            "div",
            { style: styles.libraryButtons },
            isEditing
              ? [
                  React.createElement(
                    "button",
                    {
                      key: "save",
                      type: "button",
                      style: styles.libraryPrimaryButton,
                      onClick: saveEdit,
                    },
                    "Save"
                  ),
                  React.createElement(
                    "button",
                    {
                      key: "cancel",
                      type: "button",
                      style: styles.libraryButton,
                      onClick: cancelEdit,
                    },
                    "Cancel"
                  ),
                ]
              : [
                  React.createElement(
                    "button",
                    {
                      key: "load",
                      type: "button",
                      style: styles.libraryPrimaryButton,
                      onClick: () => onSelect(art.id),
                    },
                    isActive ? "Resume" : "Load"
                  ),
                  React.createElement(
                    "button",
                    {
                      key: "rename",
                      type: "button",
                      style: styles.libraryButton,
                      onClick: () => startEditing(art),
                    },
                    "Rename"
                  ),
                  React.createElement(
                    "button",
                    {
                      key: "clear",
                      type: "button",
                      style: styles.libraryButton,
                      onClick: () => onClearProgress(art.id),
                    },
                    "Clear progress"
                  ),
                  React.createElement(
                    "button",
                    {
                      key: "delete",
                      type: "button",
                      style: styles.libraryDangerButton,
                      onClick: () => onDelete(art.id),
                    },
                    "Delete"
                  ),
                ]
          )
        );
      })
    : React.createElement("div", { style: styles.libraryEmpty }, "No artworks saved yet.");

  return React.createElement(
    "div",
    { style: styles.libraryOverlay, onClick: onClose },
    React.createElement(
      "aside",
      {
        style: styles.libraryPanel,
        role: "dialog",
        "aria-modal": true,
        "aria-label": "Artwork library",
        onClick: (e) => e.stopPropagation(),
      },
      React.createElement(
        "div",
        { style: styles.libraryHeader },
        React.createElement("div", { style: styles.libraryTitle }, "Art Library"),
        React.createElement(
          "button",
          { style: styles.libraryClose, onClick: onClose, "aria-label": "Close art library" },
          "\u2715"
        )
      ),
      React.createElement("div", { style: styles.libraryList }, list),
      React.createElement(
        "section",
        { style: styles.libraryPromptSection },
        React.createElement("h3", { style: styles.libraryPromptTitle }, "ChatGPT prompt"),
        React.createElement(
          "p",
          { style: styles.libraryPromptBody },
          "Use this prompt with ChatGPT to produce a new color-by-number JSON file."
        ),
        React.createElement(
          "div",
          { style: styles.libraryPromptActions },
          React.createElement(
            "button",
            { type: "button", style: styles.libraryPrimaryButton, onClick: handleCopyPrompt },
            "Copy prompt"
          ),
          promptStatus &&
            React.createElement(
              "span",
              {
                style: {
                  ...styles.libraryPromptStatus,
                  color: promptStatus.type === "error" ? "#f87171" : "#22c55e",
                },
              },
              promptStatus.message
            )
        ),
        React.createElement(
          "pre",
          { style: styles.libraryPromptPre },
          promptText
        )
      ),
      React.createElement(
        "form",
        { style: styles.libraryImport, onSubmit: handleImportSubmit },
        React.createElement("label", { style: styles.libraryLabel }, "Import artwork JSON or SVG"),
        React.createElement(
          "p",
          { style: styles.libraryNote },
          "Paste JSON exported from the app or upload an SVG segmented with data-cell-id/data-color-id attributes."
        ),
        React.createElement("textarea", {
          style: styles.libraryTextarea,
          value: draft,
          onChange: (e) => setDraft(e.target.value),
          placeholder: "{ \"id\": \"my-art\", ... }",
          rows: 6,
        }),
        React.createElement(
          "div",
          { style: styles.libraryFileRow },
          React.createElement("input", {
            type: "file",
            accept: ".json,.svg,application/json,image/svg+xml",
            onChange: handleFileUpload,
            style: styles.libraryFileInput,
          }),
          React.createElement(
            "span",
            { style: styles.libraryFileHint },
            "Choose a file to import annotated SVGs or saved JSON payloads."
          )
        ),
        React.createElement(
          "div",
          { style: styles.libraryImportActions },
          React.createElement(
            "button",
            { type: "submit", style: styles.libraryPrimaryButton },
            "Add artwork"
          ),
          React.createElement(
            "button",
            {
              type: "button",
              style: styles.libraryButton,
              onClick: () => {
                setDraft("");
                setFeedback(null);
              },
            },
            "Clear"
          )
        ),
        feedback &&
          React.createElement(
            "div",
            {
              style: {
                ...styles.libraryFeedback,
                color: feedback.type === "error" ? "#f87171" : "#22c55e",
              },
            },
            feedback.message
          )
      )
    )
  );
}

function OptionsPanel({ config, onToggle, canReset, onReset, onClose }) {
  const options = [
    {
      key: "enableAutosave",
      label: "Autosave progress",
      description: "Persist the fill state and viewport to localStorage after each change.",
    },
    {
      key: "autoAdvanceOnComplete",
      label: "Auto-advance color",
      description: "Jump to the next color when the active color has no unfilled cells remaining.",
    },
    {
      key: "enableHintPulse",
      label: "Hint pulses",
      description: "Allow the Hint control to highlight the smallest unfilled cells in the active color.",
    },
    {
      key: "enableDragFill",
      label: "Drag-to-fill",
      description: "While painting, drag across adjacent cells to fill them without additional taps.",
    },
    {
      key: "enableEyedropper",
      label: "Eyedropper",
      description: "Tap a filled cell without moving to reselect its color.",
    },
    {
      key: "enableKeyboardShortcuts",
      label: "Keyboard shortcuts",
      description: "Use H, N, U, T, +/-, and 0 to control hints, color cycling, undo, tests, zoom, and fitting.",
    },
    {
      key: "showNumberBadges",
      label: "Number badges",
      description: "Show numbered overlays for unfilled cells when zoomed in.",
    },
    {
      key: "showHeatmapDots",
      label: "Heat-map dots",
      description: "Show locator dots for tiny cells when zoomed out.",
    },
    {
      key: "enableSmokeHud",
      label: "Smoke-test HUD",
      description: "Allow the debugging overlay that summarizes automated checks.",
    },
  ];

  const surfaces = [
    {
      title: "Root layout",
      body: "Dark-mode experience with a full-viewport canvas and floating header/footer controls.",
    },
    {
      title: "Header bar",
      body: "Back affordance, artwork title, progress text, and utility buttons for fit, undo, hint, next color, tests, and options.",
    },
    {
      title: "Canvas frame",
      body: "Fullscreen SVG stage with pan/zoom transforms, strokes, badges, and heat-map dots as you zoom.",
    },
    {
      title: "Smoke Tests HUD",
      body: "Optional floating card that reports automated sanity checks and can be hidden with the toolbar or T shortcut.",
    },
    {
      title: "Palette footer",
      body: "Scrollable row of numbered swatches with remaining counts, highlighting the active color and disabling completed ones.",
    },
  ];

  return React.createElement(
    "div",
    { style: styles.optionsOverlay, onClick: onClose },
    React.createElement(
      "aside",
      {
        style: styles.optionsCard,
        role: "dialog",
        "aria-modal": true,
        "aria-label": "Options and configuration",
        onClick: (e) => e.stopPropagation(),
      },
      React.createElement(
        "div",
        { style: styles.optionsHeader },
        React.createElement("div", { style: styles.optionsTitle }, "Options"),
        React.createElement(
          "button",
          { style: styles.optionsClose, onClick: onClose, "aria-label": "Close options" },
          "\u2715"
        )
      ),
      React.createElement(
        "p",
        { style: styles.optionsAbout },
        "The project is a single-page React 18 color-by-number demo that boots entirely from index.html, pulling React, ReactDOM, and Babel from CDNs so the JSX logic can run in the browser without a build step. The art library import accepts JSON exports or annotated SVG files with data-cell-id/data-color-id metadata so new scenes can be added without editing code. It now ships with three sample scenes—“Capybara Lagoon Sunrise,” “Twilight Marsh Study,” and “Lush Green Forest Walk”—plus autosave that tracks each cell’s fill state so players can match colors to numbers."
      ),
      React.createElement("div", { style: styles.optionsSectionTitle }, "UI surfaces"),
      React.createElement(
        "ul",
        { style: styles.optionsUiList },
        surfaces.map((s) =>
          React.createElement(
            "li",
            { key: s.title },
            React.createElement("strong", null, s.title, ": "),
            s.body
          )
        )
      ),
      React.createElement("div", { style: styles.optionsSectionTitle }, "Configuration"),
      React.createElement(
        "div",
        { style: styles.optionsList },
        options.map((opt) =>
          React.createElement(
            "label",
            { key: opt.key, style: styles.optionRow },
            React.createElement("input", {
              type: "checkbox",
              checked: !!config[opt.key],
              onChange: (e) => onToggle(opt.key, e.target.checked),
              style: styles.optionCheckbox,
            }),
            React.createElement(
              "div",
              null,
              React.createElement("div", { style: styles.optionLabel }, opt.label),
              React.createElement("div", { style: styles.optionDescription }, opt.description)
            )
          )
        )
      ),
      React.createElement("div", { style: styles.optionsSectionTitle }, "Current values"),
      React.createElement(
        "pre",
        { style: styles.optionsConfigPre },
        JSON.stringify(config, null, 2)
      ),
      React.createElement(
        "div",
        { style: styles.optionsFooter },
        React.createElement(
          "button",
          {
            style: {
              ...styles.optionsReset,
              opacity: canReset ? 1 : 0.5,
              cursor: canReset ? "pointer" : "not-allowed",
            },
            type: "button",
            onClick: canReset ? onReset : undefined,
            disabled: !canReset,
          },
          "Reset to defaults"
        )
      )
    )
  );
}

// ---------- Smoke Tests HUD ----------
function SmokeTests({ art, filled }) {
  const results = useMemo(() => runSmokeTests(art, filled), [art, filled]);
  const allPass = results.every((r) => r.pass);
  if (allPass) return null;
  return React.createElement(
    "div",
    {
      style: {
        position: "absolute",
        left: 16,
        bottom: 180,
        background: "rgba(248, 113, 113, 0.12)",
        border: "1px solid #f87171",
        borderRadius: 12,
        padding: 12,
        boxShadow: "0 12px 40px rgba(15, 23, 42, 0.35)",
        maxWidth: 360,
        fontSize: 12,
        backdropFilter: "blur(12px)",
      },
    },
    React.createElement(
      "div",
      { style: { fontWeight: 700, marginBottom: 8 } },
      "Smoke tests failed"
    ),
    React.createElement(
      "ul",
      { style: { margin: 0, paddingLeft: 18 } },
      results.map((r) => {
        const status = r.pass ? "[pass]" : "[fail]";
        const details = r.msg ? ` - ${r.msg}` : "";
        return React.createElement(
          "li",
          { key: r.name, style: { color: r.pass ? "#4ade80" : "#fca5a5" } },
          `${status} ${r.name}${details}`
        );
      })
    ),
    React.createElement(
      "div",
      { style: { marginTop: 8, color: "#94a3b8" } },
      "Press T to hide/show."
    )
  );
}

function runSmokeTests(art, filled) {
  const tests = [];
  const rem = computeRemaining(art, filled);
  const sum = Object.values(rem).reduce((a, b) => a + b, 0);
  const expected = art.cells.filter((c) => !filled[c.id]).length;
  tests.push({ name: "Remaining matches unfilled count", pass: sum === expected, msg: `${sum}/${expected}` });
  const c0 = art.cells[0];
  const { x, y } = centroidFromPath(c0.d);
  tests.push({ name: "Centroid in bounds", pass: x >= 0 && y >= 0 && x <= art.width && y <= art.height });
  const ids = new Set(art.palette.map((p) => p.id));
  tests.push({ name: "Palette IDs unique", pass: ids.size === art.palette.length });
  return tests;
}

// ---------- Styles ----------
const styles = {
  app: {
    width: "100vw",
    height: "100vh",
    position: "relative",
    overflow: "hidden",
    fontFamily: "'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui",
    color: "#f8fafc",
    background: "radial-gradient(circle at top, rgba(56, 189, 248, 0.12), #030712)",
  },
  bootstrapBanner: {
    position: "fixed",
    top: 64,
    left: "50%",
    transform: "translateX(-50%)",
    maxWidth: "min(520px, calc(100% - 32px))",
    padding: "10px 16px",
    borderRadius: 14,
    background: "rgba(248, 113, 113, 0.15)",
    border: "1px solid rgba(248, 113, 113, 0.4)",
    color: "#fecaca",
    fontSize: 12,
    textAlign: "center",
    zIndex: 30,
    boxShadow: "0 12px 32px rgba(2, 6, 23, 0.6)",
    backdropFilter: "blur(10px)",
    pointerEvents: "none",
  },
  canvas: {
    position: "absolute",
    inset: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
  },
  topBar: {
    position: "fixed",
    top: 16,
    left: "50%",
    transform: "translateX(-50%)",
    width: "min(880px, calc(100% - 28px))",
    display: "flex",
    flexWrap: "nowrap",
    justifyContent: "space-between",
    alignItems: "center",
    gap: 12,
    padding: "8px 14px",
    borderRadius: 16,
    background: "rgba(15, 23, 42, 0.82)",
    border: "1px solid rgba(148, 163, 184, 0.26)",
    boxShadow: "0 18px 36px rgba(2, 6, 23, 0.55)",
    backdropFilter: "blur(14px)",
    zIndex: 20,
  },
  topContext: {
    display: "flex",
    alignItems: "center",
    gap: 10,
    minWidth: 0,
    flex: "0 1 auto",
    overflow: "hidden",
  },
  topTitle: {
    fontSize: 16,
    fontWeight: 600,
    color: "#f8fafc",
    letterSpacing: 0.3,
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
  },
  topProgress: {
    fontSize: 12,
    fontWeight: 600,
    padding: "2px 10px",
    borderRadius: 999,
    background: "rgba(30, 41, 59, 0.7)",
    border: "1px solid rgba(148, 163, 184, 0.26)",
    color: "#d3defe",
    whiteSpace: "nowrap",
  },
  topActions: {
    display: "flex",
    flexWrap: "nowrap",
    justifyContent: "flex-end",
    gap: 6,
    flex: "1 1 auto",
    overflowX: "auto",
  },
  controlButton: {
    borderRadius: 10,
    border: "1px solid rgba(148, 163, 184, 0.28)",
    background: "linear-gradient(180deg, rgba(51, 65, 85, 0.55), rgba(15, 23, 42, 0.9))",
    color: "#f8fafc",
    fontSize: 12,
    fontWeight: 600,
    letterSpacing: 0.2,
    padding: "6px 12px",
    minHeight: 34,
    minWidth: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    gap: 6,
    cursor: "pointer",
    boxShadow: "0 12px 28px rgba(2, 6, 23, 0.45)",
    transition: "transform 0.15s ease, box-shadow 0.2s ease, background 0.2s ease",
    textTransform: "none",
    whiteSpace: "nowrap",
    lineHeight: 1.2,
  },
  paletteDock: {
    position: "fixed",
    left: "50%",
    bottom: 24,
    transform: "translateX(-50%)",
    width: "min(940px, calc(100% - 24px))",
    background: "rgba(15, 23, 42, 0.82)",
    borderRadius: 18,
    border: "1px solid rgba(148, 163, 184, 0.28)",
    padding: "8px 12px",
    boxShadow: "0 24px 50px rgba(2, 6, 23, 0.6)",
    zIndex: 11,
    overflow: "hidden",
    backdropFilter: "blur(16px)",
  },
  emptyState: {
    position: "absolute",
    inset: 0,
    display: "grid",
    placeItems: "center",
    padding: 24,
    color: "#94a3b8",
    fontSize: 18,
    textAlign: "center",
  },
  paletteWrap: {
    display: "flex",
    flexDirection: "row",
    flexWrap: "nowrap",
    gap: 8,
    width: "100%",
    overflowX: "auto",
    paddingBottom: 4,
    scrollSnapType: "x proximity",
  },
  swatch: {
    height: "clamp(44px, 9vw, 58px)",
    borderRadius: 999,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    transition: "transform 0.12s ease, box-shadow 0.2s ease",
    cursor: "pointer",
    color: "#f8fafc",
    flex: "0 0 clamp(44px, 9vw, 58px)",
    aspectRatio: "1",
    scrollSnapAlign: "center",
  },
  swatchNumber: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    width: 18,
    height: 18,
    borderRadius: "50%",
    background: "rgba(15, 23, 42, 0.52)",
    color: "#f8fafc",
    fontSize: 9,
    fontWeight: 700,
    letterSpacing: 0.4,
  },
  libraryOverlay: {
    position: "fixed",
    inset: 0,
    background: "rgba(2, 6, 23, 0.7)",
    backdropFilter: "blur(12px)",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    padding: "24px",
    zIndex: 60,
  },
  libraryPanel: {
    width: "min(560px, 100%)",
    maxHeight: "calc(100vh - 48px)",
    overflowY: "auto",
    background: "rgba(15, 23, 42, 0.96)",
    borderRadius: 24,
    padding: 24,
    boxShadow: "0 24px 60px rgba(2, 6, 23, 0.7)",
    border: "1px solid rgba(148, 163, 184, 0.3)",
    color: "#e2e8f0",
    display: "grid",
    gap: 20,
  },
  libraryHeader: {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
  },
  libraryTitle: {
    fontSize: 20,
    fontWeight: 700,
  },
  libraryClose: {
    width: 36,
    height: 36,
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.8)",
    color: "#cbd5f5",
    cursor: "pointer",
  },
  libraryList: {
    display: "grid",
    gap: 12,
  },
  libraryItem: {
    border: "1px solid rgba(148, 163, 184, 0.2)",
    borderRadius: 16,
    padding: 16,
    background: "rgba(15, 23, 42, 0.7)",
    display: "grid",
    gap: 12,
  },
  libraryItemActive: {
    borderColor: "rgba(56, 189, 248, 0.6)",
    boxShadow: "0 0 0 1px rgba(56, 189, 248, 0.4)",
  },
  libraryItemHeader: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
  },
  libraryItemTitle: {
    fontWeight: 600,
    fontSize: 16,
  },
  libraryTitleInput: {
    width: "100%",
    padding: "6px 10px",
    borderRadius: 10,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.85)",
    color: "#e2e8f0",
  },
  libraryBadge: {
    padding: "4px 10px",
    borderRadius: 999,
    fontSize: 12,
    background: "rgba(148, 163, 184, 0.2)",
    color: "#cbd5f5",
  },
  libraryBadgeActive: {
    background: "rgba(56, 189, 248, 0.2)",
    color: "#38bdf8",
  },
  libraryMeta: {
    fontSize: 13,
    color: "#94a3b8",
  },
  libraryButtons: {
    display: "flex",
    flexWrap: "wrap",
    gap: 8,
  },
  libraryButton: {
    padding: "8px 12px",
    borderRadius: 10,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(30, 41, 59, 0.6)",
    color: "#cbd5f5",
    cursor: "pointer",
  },
  libraryPrimaryButton: {
    padding: "8px 12px",
    borderRadius: 10,
    border: "1px solid rgba(56, 189, 248, 0.5)",
    background: "rgba(56, 189, 248, 0.2)",
    color: "#38bdf8",
    cursor: "pointer",
  },
  libraryDangerButton: {
    padding: "8px 12px",
    borderRadius: 10,
    border: "1px solid rgba(248, 113, 113, 0.5)",
    background: "rgba(248, 113, 113, 0.15)",
    color: "#fca5a5",
    cursor: "pointer",
  },
  libraryEmpty: {
    padding: 16,
    textAlign: "center",
    color: "#94a3b8",
    border: "1px dashed rgba(148, 163, 184, 0.3)",
    borderRadius: 16,
  },
  libraryPromptSection: {
    border: "1px solid rgba(148, 163, 184, 0.25)",
    borderRadius: 16,
    padding: 16,
    background: "rgba(15, 23, 42, 0.7)",
    display: "grid",
    gap: 12,
  },
  libraryPromptTitle: {
    margin: 0,
    fontSize: 15,
    fontWeight: 600,
  },
  libraryPromptBody: {
    margin: 0,
    fontSize: 13,
    color: "#94a3b8",
  },
  libraryPromptActions: {
    display: "flex",
    alignItems: "center",
    gap: 12,
  },
  libraryPromptStatus: {
    fontSize: 12,
  },
  libraryPromptPre: {
    margin: 0,
    padding: 12,
    background: "rgba(15, 23, 42, 0.85)",
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.2)",
    fontSize: 12,
    color: "#cbd5f5",
    overflowX: "auto",
    whiteSpace: "pre-wrap",
    fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
  },
  libraryImport: {
    display: "grid",
    gap: 12,
  },
  libraryLabel: {
    fontSize: 13,
    fontWeight: 600,
    color: "#cbd5f5",
  },
  libraryNote: {
    margin: 0,
    fontSize: 12,
    color: "#94a3b8",
  },
  libraryTextarea: {
    width: "100%",
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.8)",
    color: "#e2e8f0",
    padding: 12,
    fontSize: 13,
    fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
  },
  libraryFileRow: {
    display: "flex",
    flexWrap: "wrap",
    alignItems: "center",
    gap: 12,
  },
  libraryFileInput: {
    color: "#cbd5f5",
    fontSize: 12,
  },
  libraryFileHint: {
    fontSize: 12,
    color: "#94a3b8",
  },
  libraryImportActions: {
    display: "flex",
    gap: 12,
    flexWrap: "wrap",
  },
  libraryFeedback: {
    fontSize: 12,
  },
  optionsOverlay: {
    position: "fixed",
    inset: 0,
    background: "rgba(2, 6, 23, 0.6)",
    backdropFilter: "blur(8px)",
    display: "flex",
    justifyContent: "flex-end",
    alignItems: "center",
    padding: "24px 32px",
    zIndex: 50,
  },
  optionsCard: {
    width: "min(420px, 100%)",
    maxHeight: "calc(100vh - 48px)",
    overflowY: "auto",
    background: "rgba(15, 23, 42, 0.96)",
    borderRadius: 24,
    padding: 24,
    boxShadow: "0 24px 60px rgba(2, 6, 23, 0.65)",
    border: "1px solid rgba(148, 163, 184, 0.25)",
    color: "#e2e8f0",
  },
  optionsHeader: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 12,
  },
  optionsTitle: {
    fontSize: 20,
    fontWeight: 700,
  },
  optionsClose: {
    width: 32,
    height: 32,
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.8)",
    color: "#cbd5f5",
    cursor: "pointer",
  },
  optionsAbout: {
    fontSize: 13,
    lineHeight: 1.6,
    color: "#cbd5f5",
    marginTop: 0,
    marginBottom: 16,
  },
  optionsSectionTitle: {
    fontSize: 11,
    textTransform: "uppercase",
    letterSpacing: 1,
    color: "#64748b",
    margin: "20px 0 10px",
  },
  optionsUiList: {
    margin: 0,
    paddingLeft: 18,
    display: "grid",
    gap: 8,
    fontSize: 13,
    color: "#d0def5",
  },
  optionsList: {
    display: "grid",
    gap: 12,
  },
  optionRow: {
    display: "grid",
    gridTemplateColumns: "auto 1fr",
    gap: 12,
    alignItems: "start",
    background: "rgba(15, 23, 42, 0.7)",
    padding: 12,
    borderRadius: 16,
    border: "1px solid rgba(148, 163, 184, 0.15)",
  },
  optionCheckbox: {
    width: 18,
    height: 18,
    marginTop: 4,
  },
  optionLabel: {
    fontWeight: 600,
    color: "#e2e8f0",
  },
  optionDescription: {
    fontSize: 12,
    color: "#94a3b8",
    marginTop: 4,
  },
  optionsConfigPre: {
    margin: 0,
    padding: 12,
    background: "rgba(15, 23, 42, 0.7)",
    borderRadius: 16,
    border: "1px solid rgba(148, 163, 184, 0.15)",
    fontSize: 12,
    color: "#f8fafc",
    overflowX: "auto",
  },
  optionsFooter: {
    marginTop: 16,
    display: "flex",
    justifyContent: "flex-end",
  },
  optionsReset: {
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(51, 65, 85, 0.4)",
    color: "#e2e8f0",
    padding: "10px 16px",
    cursor: "pointer",
    fontWeight: 600,
  },
};

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(React.createElement(App));
    </script>
  </body>
</html>


