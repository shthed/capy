<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Image to Color-by-Number</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: "Inter", "Segoe UI", -apple-system, BlinkMacSystemFont, system-ui,
          sans-serif;
        background: #020617;
        color: #e2e8f0;
      }

      * {
        box-sizing: border-box;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        clip-path: inset(50%);
        border: 0;
        white-space: nowrap;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, rgba(59, 130, 246, 0.22), transparent),
          #020617;
        color: inherit;
        overflow: hidden;
      }

      body.dragging {
        cursor: copy;
      }

      #app {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      #app::before {
        content: "";
        position: absolute;
        inset: 24px;
        border-radius: 24px;
        border: 2px dashed rgba(148, 163, 184, 0.35);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.18s ease;
      }

      body.dragging #app::before {
        opacity: 1;
      }

      #stage {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: stretch;
        justify-content: stretch;
        overflow: hidden;
      }

      #canvasViewport {
        position: relative;
        flex: 1;
        overflow: hidden;
        touch-action: none;
        cursor: default;
      }

      #canvasViewport.ready {
        cursor: grab;
      }

      #canvasViewport.panning {
        cursor: grabbing;
      }

      #puzzleCanvas {
        display: block;
        background: #0f172a;
        border-radius: 24px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        box-shadow: 0 40px 80px rgba(8, 47, 73, 0.45);
        image-rendering: pixelated;
        transform-origin: top left;
        will-change: transform;
      }

      #startHint {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        background: rgba(15, 23, 42, 0.85);
        backdrop-filter: blur(18px);
        transition: opacity 0.24s ease;
        z-index: 2;
      }

      #startHint.hidden {
        opacity: 0;
        pointer-events: none;
      }

      #startHint .hint-body {
        pointer-events: auto;
        text-align: center;
        max-width: 360px;
        padding: 32px;
        border-radius: 22px;
        background: rgba(2, 6, 23, 0.78);
        border: 1px solid rgba(59, 130, 246, 0.35);
        box-shadow: 0 20px 60px rgba(15, 23, 42, 0.6);
      }

      #startHint h1 {
        margin: 0 0 12px;
        font-size: clamp(1.8rem, 3vw + 0.5rem, 2.6rem);
      }

      #startHint p {
        margin: 0 0 20px;
        color: rgba(226, 232, 240, 0.82);
        font-size: 1rem;
      }

      button {
        font: inherit;
        border-radius: 999px;
        border: none;
        padding: 10px 22px;
        background: rgba(96, 165, 250, 0.92);
        color: #021027;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
      }

      button:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(37, 99, 235, 0.35);
        background: rgba(147, 197, 253, 0.96);
      }

      button:disabled {
        background: rgba(148, 163, 184, 0.35);
        color: rgba(226, 232, 240, 0.7);
        cursor: not-allowed;
        box-shadow: none;
      }

      #hud {
        position: absolute;
        top: 28px;
        left: 28px;
        display: flex;
        gap: 18px;
        align-items: flex-start;
        z-index: 3;
      }

      #menuToggle {
        width: 46px;
        height: 46px;
        border-radius: 16px;
        padding: 0;
        display: grid;
        place-items: center;
        background: rgba(15, 23, 42, 0.9);
        color: rgba(226, 232, 240, 0.95);
        border: 1px solid rgba(59, 130, 246, 0.5);
        box-shadow: 0 16px 30px rgba(15, 23, 42, 0.45);
      }

      #menuToggle .icon {
        font-size: 1.35rem;
        line-height: 1;
      }

      #statusBar {
        min-width: 260px;
        padding: 14px 18px;
        border-radius: 18px;
        background: rgba(2, 6, 23, 0.82);
        border: 1px solid rgba(148, 163, 184, 0.32);
        box-shadow: 0 18px 40px rgba(2, 6, 23, 0.4);
        display: flex;
        flex-direction: column;
        gap: 4px;
        backdrop-filter: blur(16px);
      }

      #statusMessage {
        font-size: 0.95rem;
      }

      #progressSummary {
        font-size: 0.85rem;
        color: rgba(148, 163, 184, 0.9);
      }

      #paletteDock {
        position: absolute;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 20px 28px 26px;
        background: linear-gradient(to top, rgba(2, 6, 23, 0.88), rgba(2, 6, 23, 0));
        pointer-events: none;
        z-index: 3;
      }

      #paletteScroller {
        pointer-events: auto;
        display: flex;
        gap: 12px;
        overflow-x: auto;
        overflow-y: hidden;
        padding: 10px;
        border-radius: 18px;
        background: rgba(15, 23, 42, 0.78);
        border: 1px solid rgba(59, 130, 246, 0.25);
        box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.35);
        scrollbar-width: thin;
        scroll-behavior: smooth;
        touch-action: pan-x;
        -webkit-overflow-scrolling: touch;
      }

      #paletteScroller::-webkit-scrollbar {
        height: 8px;
      }

      #paletteScroller::-webkit-scrollbar-thumb {
        background: rgba(96, 165, 250, 0.45);
        border-radius: 999px;
      }

      .swatch {
        flex: 0 0 auto;
        display: grid;
        grid-template-columns: 56px 1fr;
        align-items: center;
        gap: 12px;
        min-width: 210px;
        padding: 12px 16px;
        border-radius: 16px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(2, 6, 23, 0.9);
        color: inherit;
        text-align: left;
        cursor: pointer;
        transition: border-color 0.18s ease, box-shadow 0.18s ease, transform 0.18s ease,
          opacity 0.18s ease;
      }

      .swatch:hover {
        transform: translateY(-1px);
      }

      .swatch.active {
        border-color: rgba(96, 165, 250, 0.9);
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.45);
      }

      .swatch .sample {
        width: 56px;
        height: 56px;
        border-radius: 14px;
        border: 1px solid rgba(15, 23, 42, 0.4);
        box-shadow: inset 0 1px 4px rgba(15, 23, 42, 0.6);
      }

      .swatch .info {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 0.82rem;
      }

      .swatch .info strong {
        font-size: 0.95rem;
        letter-spacing: 0.01em;
      }

      .swatch.completed {
        opacity: 0.35;
        pointer-events: auto;
        border-color: rgba(148, 163, 184, 0.2);
      }

      #optionsBackdrop {
        position: fixed;
        inset: 0;
        background: rgba(2, 6, 23, 0.65);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.18s ease;
        z-index: 4;
      }

      #optionsBackdrop.visible {
        opacity: 1;
        pointer-events: auto;
        backdrop-filter: blur(2px);
      }

      #optionsDrawer {
        position: fixed;
        top: 0;
        right: 0;
        width: min(340px, 90vw);
        height: 100vh;
        padding: 28px 26px 32px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        border-radius: 0 0 0 28px;
        background: rgba(2, 6, 23, 0.96);
        border-left: 1px solid rgba(59, 130, 246, 0.3);
        box-shadow: -24px 0 60px rgba(2, 6, 23, 0.6);
        transform: translateX(100%);
        transition: transform 0.22s ease;
        z-index: 5;
      }

      #optionsDrawer.open {
        transform: translateX(0);
      }

      #closeOptions {
        align-self: flex-end;
        border-radius: 14px;
        padding: 6px 12px;
        font-size: 0.85rem;
        background: rgba(15, 23, 42, 0.85);
        color: rgba(226, 232, 240, 0.92);
        border: 1px solid rgba(148, 163, 184, 0.45);
        box-shadow: none;
      }

      #optionsDrawer h2 {
        margin: 0;
        font-size: 1.05rem;
        letter-spacing: 0.02em;
      }

      .panel-section {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .control {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 0.95rem;
      }

      .control > span {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
      }

      .control output {
        font-size: 0.85rem;
        color: rgba(148, 163, 184, 0.9);
      }

      input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        height: 6px;
        border-radius: 999px;
        background: rgba(51, 65, 85, 0.9);
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: rgba(96, 165, 250, 0.95);
        border: none;
        box-shadow: 0 2px 6px rgba(37, 99, 235, 0.4);
        cursor: pointer;
      }

      input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: rgba(96, 165, 250, 0.95);
        border: none;
        box-shadow: 0 2px 6px rgba(37, 99, 235, 0.4);
        cursor: pointer;
      }

      .control-note {
        margin-top: -8px;
        font-size: 0.8rem;
        color: rgba(148, 163, 184, 0.8);
      }

      .panel-actions {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
      }

      .panel-actions button {
        border-radius: 12px;
      }

      #downloadJson {
        width: 100%;
        border-radius: 12px;
        padding: 10px 0;
      }

      #previewCanvas {
        width: 100%;
        height: auto;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.3);
        background: rgba(15, 23, 42, 0.8);
        image-rendering: pixelated;
      }

      #progressDetail {
        font-size: 0.9rem;
        color: rgba(226, 232, 240, 0.82);
      }

      @media (max-width: 900px) {
        #hud {
          left: 20px;
          right: 20px;
        }

        #paletteDock {
          padding: 16px 18px 22px;
        }

        .swatch {
          min-width: 180px;
        }
      }

      @media (max-width: 600px) {
        #hud {
          top: 16px;
          left: 16px;
          right: 16px;
          flex-direction: column;
          align-items: stretch;
          gap: 10px;
        }

        #menuToggle {
          width: 42px;
          height: 42px;
        }

        #statusBar {
          padding: 12px 14px;
          min-width: 0;
          width: 100%;
        }

        #paletteScroller {
          gap: 10px;
          padding: 8px 10px 12px;
        }

        .swatch {
          grid-template-columns: 48px 1fr;
          min-width: 148px;
          padding: 10px 12px;
        }

        .swatch .sample {
          width: 48px;
          height: 48px;
          border-radius: 12px;
        }

        #startHint .hint-body {
          max-width: 280px;
          padding: 24px;
        }

        #startHint p {
          font-size: 0.95rem;
        }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div id="stage">
        <div id="canvasViewport">
          <canvas id="puzzleCanvas" width="640" height="480"></canvas>
        </div>
      </div>
      <div id="startHint" class="hint" tabindex="0">
        <div class="hint-body">
          <h1>Drop an image to start</h1>
          <p>Drag a picture anywhere on the screen or choose a file from your device.</p>
          <button id="selectImage" type="button">Choose an image</button>
        </div>
      </div>
      <div id="hud">
        <button
          id="menuToggle"
          type="button"
          aria-haspopup="true"
          aria-expanded="false"
          aria-controls="optionsDrawer"
        >
          <span class="icon">☰</span>
        </button>
        <div id="statusBar" class="sr-only" role="status" aria-live="polite">
          <span id="statusMessage">Drop an image anywhere to begin.</span>
          <span id="progressSummary">No puzzle loaded yet.</span>
        </div>
      </div>
      <div id="paletteDock">
        <div
          id="paletteScroller"
          role="listbox"
          aria-label="Colour palette"
          aria-live="polite"
          data-testid="palette-dock"
        ></div>
      </div>
    </div>
    <div id="optionsBackdrop" aria-hidden="true"></div>
    <aside id="optionsDrawer" aria-label="Puzzle options" tabindex="-1" aria-hidden="true">
      <button id="closeOptions" type="button">Close</button>
      <div class="panel-section">
        <h2>Generator</h2>
        <label class="control">
          <span>Colours <output data-for="colorCount">16</output></span>
          <input id="colorCount" type="range" min="4" max="48" value="16" />
        </label>
        <label class="control">
          <span>Regions <output data-for="minRegion">80 px²</output></span>
          <input id="minRegion" type="range" min="1" max="400" value="80" />
        </label>
        <p class="control-note">Higher values merge smaller areas for fewer regions.</p>
        <label class="control">
          <span>Detail <output data-for="detailLevel">768 px</output></span>
          <input id="detailLevel" type="range" min="320" max="1280" step="64" value="768" />
        </label>
        <p class="control-note">Controls the longest edge used when resizing the source image.</p>
        <div class="panel-actions">
          <button id="applyOptions" type="button" disabled>Apply changes</button>
          <button id="resetPuzzle" type="button" disabled>Reset progress</button>
        </div>
        <button id="downloadJson" type="button" disabled>Download JSON</button>
      </div>
      <div class="panel-section">
        <h2>Preview</h2>
        <canvas id="previewCanvas" width="320" height="240"></canvas>
      </div>
      <div class="panel-section">
        <h2>Progress</h2>
        <div id="progressDetail">Drop an image to begin.</div>
      </div>
    </aside>
    <input id="fileInput" type="file" accept="image/*" hidden />
    <script>
      const fileInput = document.getElementById("fileInput");
      const selectButton = document.getElementById("selectImage");
      const startHint = document.getElementById("startHint");
      const statusMessage = document.getElementById("statusMessage");
      const progressSummary = document.getElementById("progressSummary");
      const progressDetail = document.getElementById("progressDetail");
      const colorCountEl = document.getElementById("colorCount");
      const minRegionEl = document.getElementById("minRegion");
      const detailEl = document.getElementById("detailLevel");
      const applyBtn = document.getElementById("applyOptions");
      const resetBtn = document.getElementById("resetPuzzle");
      const downloadBtn = document.getElementById("downloadJson");
      const canvasViewport = document.getElementById("canvasViewport");
      const puzzleCanvas = document.getElementById("puzzleCanvas");
      const previewCanvas = document.getElementById("previewCanvas");
      const paletteScroller = document.getElementById("paletteScroller");
      const puzzleCtx = puzzleCanvas.getContext("2d");
      const previewCtx = previewCanvas.getContext("2d");
      const menuToggle = document.getElementById("menuToggle");
      const optionsDrawer = document.getElementById("optionsDrawer");
      const optionsBackdrop = document.getElementById("optionsBackdrop");
      const closeOptionsBtn = document.getElementById("closeOptions");

      const state = {
        puzzle: null,
        activeColor: null,
        filled: new Set(),
        sourceUrl: null,
        lastOptions: null,
      };

      const view = {
        scale: 1,
        minScale: 0.5,
        maxScale: 4,
        offsetX: 0,
        offsetY: 0,
      };

      const pointerState = new Map();
      let pinchBase = null;

      selectButton.addEventListener("click", () => fileInput.click());

      startHint.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          fileInput.click();
        }
      });

      fileInput.addEventListener("change", (event) => {
        const file = event.target.files?.[0];
        if (file) {
          handleFile(file);
        }
      });

      function hasFiles(event) {
        const types = event.dataTransfer?.types;
        if (!types) return false;
        if (typeof types.includes === "function") {
          return types.includes("Files");
        }
        if (typeof types.contains === "function") {
          return types.contains("Files");
        }
        return Array.from(types).includes("Files");
      }

      let dragDepth = 0;
      window.addEventListener("dragenter", (event) => {
        if (!hasFiles(event)) return;
        dragDepth += 1;
        document.body.classList.add("dragging");
        event.preventDefault();
      });

      window.addEventListener("dragleave", (event) => {
        if (!hasFiles(event)) return;
        dragDepth = Math.max(0, dragDepth - 1);
        if (dragDepth === 0) {
          document.body.classList.remove("dragging");
        }
      });

      window.addEventListener("dragover", (event) => {
        if (!hasFiles(event)) return;
        event.preventDefault();
      });

      window.addEventListener("drop", (event) => {
        if (!hasFiles(event)) return;
        event.preventDefault();
        const file = event.dataTransfer?.files?.[0];
        dragDepth = 0;
        document.body.classList.remove("dragging");
        if (file) {
          handleFile(file);
        }
      });

      const paletteWheelHandler = (event) => {
        if (Math.abs(event.deltaY) <= Math.abs(event.deltaX)) return;
        event.preventDefault();
        paletteScroller.scrollBy({ left: event.deltaY, behavior: "auto" });
      };
      paletteScroller.addEventListener("wheel", paletteWheelHandler, { passive: false });

      menuToggle.addEventListener("click", () => {
        const shouldOpen = !optionsDrawer.classList.contains("open");
        if (shouldOpen) {
          optionsDrawer.classList.add("open");
          optionsBackdrop.classList.add("visible");
          optionsDrawer.setAttribute("aria-hidden", "false");
          optionsBackdrop.setAttribute("aria-hidden", "false");
          menuToggle.setAttribute("aria-expanded", "true");
          requestAnimationFrame(() => {
            optionsDrawer.focus({ preventScroll: true });
          });
        } else {
          closeOptions(true);
        }
      });

      function closeOptions(returnFocus = false) {
        optionsDrawer.classList.remove("open");
        optionsBackdrop.classList.remove("visible");
        optionsDrawer.setAttribute("aria-hidden", "true");
        optionsBackdrop.setAttribute("aria-hidden", "true");
        menuToggle.setAttribute("aria-expanded", "false");
        if (returnFocus) {
          menuToggle.focus({ preventScroll: true });
        }
      }

      closeOptionsBtn.addEventListener("click", () => {
        closeOptions(true);
      });

      optionsBackdrop.addEventListener("click", () => {
        closeOptions(true);
      });

      window.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && optionsDrawer.classList.contains("open")) {
          closeOptions(true);
        }
      });

      function syncRangeOutput(input) {
        const output = document.querySelector(`output[data-for="${input.id}"]`);
        if (!output) return;
        if (input.id === "detailLevel") {
          output.textContent = `${input.value} px`;
        } else if (input.id === "minRegion") {
          output.textContent = `${input.value} px²`;
        } else {
          output.textContent = input.value;
        }
      }

      [colorCountEl, minRegionEl, detailEl].forEach((input) => {
        syncRangeOutput(input);
        input.addEventListener("input", () => {
          syncRangeOutput(input);
          markOptionsDirty();
        });
      });

      applyBtn.addEventListener("click", () => {
        if (!state.sourceUrl) return;
        applyBtn.disabled = true;
        regenerateFromSource();
      });

      resetBtn.addEventListener("click", () => {
        if (!state.puzzle) return;
        state.filled = new Set();
        ensureActiveColor();
        renderPuzzle();
        renderPalette();
        updateProgress();
      });

      canvasViewport.addEventListener("pointerdown", onPointerDown);
      canvasViewport.addEventListener("pointermove", onPointerMove);
      canvasViewport.addEventListener("pointerup", onPointerEnd);
      canvasViewport.addEventListener("pointercancel", onPointerEnd);
      canvasViewport.addEventListener("pointerleave", onPointerEnd);
      canvasViewport.addEventListener(
        "wheel",
        (event) => {
          if (!state.puzzle || !event.ctrlKey) return;
          event.preventDefault();
          const scaleFactor = Math.exp(-event.deltaY / 500);
          const nextScale = clamp(view.scale * scaleFactor, view.minScale, view.maxScale);
          zoomAt(nextScale, { x: event.clientX, y: event.clientY });
        },
        { passive: false }
      );

      canvasViewport.addEventListener("dblclick", (event) => {
        if (!state.puzzle) return;
        event.preventDefault();
        resetView();
      });

      window.addEventListener("resize", () => {
        if (!state.puzzle) return;
        refreshViewBounds(true);
      });

      downloadBtn.addEventListener("click", () => {
        if (!state.puzzle) return;
        const blob = new Blob([
          JSON.stringify(
            {
              width: state.puzzle.width,
              height: state.puzzle.height,
              palette: state.puzzle.palette.map((p) => ({
                id: p.id,
                hex: p.hex,
              })),
              cells: state.puzzle.regions.map((region) => ({
                id: region.id,
                colorId: region.colorId,
                center: [Number(region.cx.toFixed(2)), Number(region.cy.toFixed(2))],
                pixelCount: region.pixelCount,
              })),
            },
            null,
            2
          ),
        ], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "color-by-number.json";
        document.body.appendChild(link);
        link.click();
        requestAnimationFrame(() => {
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        });
      });

      function onPointerDown(event) {
        if (!state.puzzle) return;
        canvasViewport.setPointerCapture(event.pointerId);
        pointerState.set(event.pointerId, {
          x: event.clientX,
          y: event.clientY,
          lastX: event.clientX,
          lastY: event.clientY,
          startX: event.clientX,
          startY: event.clientY,
          moved: false,
        });
        if (pointerState.size === 2) {
          const snapshot = capturePinch();
          if (snapshot) {
            pinchBase = { distance: Math.max(snapshot.distance, 1), scale: view.scale };
          }
        }
      }

      function onPointerMove(event) {
        const pointer = pointerState.get(event.pointerId);
        if (!pointer) return;
        if (!state.puzzle) return;
        const dx = event.clientX - pointer.lastX;
        const dy = event.clientY - pointer.lastY;
        pointer.lastX = event.clientX;
        pointer.lastY = event.clientY;
        pointer.x = event.clientX;
        pointer.y = event.clientY;
        if (!pointer.moved) {
          const totalDx = event.clientX - pointer.startX;
          const totalDy = event.clientY - pointer.startY;
          pointer.moved = Math.hypot(totalDx, totalDy) > 6;
        }
        if (pointerState.size >= 2) {
          canvasViewport.classList.remove("panning");
          const snapshot = capturePinch();
          if (!snapshot) return;
          if (!pinchBase || pinchBase.distance <= 0) {
            pinchBase = { distance: Math.max(snapshot.distance, 1), scale: view.scale };
          }
          const scaleFactor = snapshot.distance / pinchBase.distance;
          const nextScale = clamp(pinchBase.scale * scaleFactor, view.minScale, view.maxScale);
          zoomAt(nextScale, { x: snapshot.centerX, y: snapshot.centerY });
          pinchBase = { distance: Math.max(snapshot.distance, 1), scale: view.scale };
        } else if (pointerState.size === 1 && pointer.moved) {
          view.offsetX += dx;
          view.offsetY += dy;
          clampView();
          applyViewTransform();
          canvasViewport.classList.add("panning");
        }
      }

      function onPointerEnd(event) {
        const pointer = pointerState.get(event.pointerId);
        const wasPinch = pointerState.size >= 2;
        if (!pointer) return;
        pointerState.delete(event.pointerId);
        if (canvasViewport.hasPointerCapture(event.pointerId)) {
          canvasViewport.releasePointerCapture(event.pointerId);
        }
        if (pointerState.size < 2) {
          pinchBase = null;
        }
        if (pointerState.size === 0) {
          canvasViewport.classList.remove("panning");
        }
        if (!wasPinch && !pointer.moved) {
          handleTap(event.clientX, event.clientY);
        }
      }

      function handleTap(clientX, clientY) {
        if (!state.puzzle || state.activeColor == null) return;
        const point = clientToPuzzle(clientX, clientY);
        if (!point) return;
        const x = Math.floor(point.x);
        const y = Math.floor(point.y);
        const idx = y * puzzleCanvas.width + x;
        if (idx < 0 || idx >= state.puzzle.regionMap.length) return;
        const regionId = state.puzzle.regionMap[idx];
        if (regionId == null || regionId < 0) return;
        const region = state.puzzle.regions[regionId];
        if (!region) return;
        if (state.filled.has(regionId)) return;
        if (region.colorId !== state.activeColor) {
          flashRegion(regionId, "#facc15");
          return;
        }
        state.filled.add(regionId);
        if (countRemaining(region.colorId) === 0) {
          const next = findNextIncompleteColor(region.colorId);
          state.activeColor = next;
        }
        renderPuzzle();
        renderPalette();
        updateProgress();
      }

      function clientToPuzzle(clientX, clientY) {
        if (!state.puzzle) return null;
        const rect = canvasViewport.getBoundingClientRect();
        const localX = clientX - rect.left;
        const localY = clientY - rect.top;
        const x = (localX - view.offsetX) / view.scale;
        const y = (localY - view.offsetY) / view.scale;
        if (Number.isNaN(x) || Number.isNaN(y)) return null;
        if (x < 0 || y < 0 || x >= puzzleCanvas.width || y >= puzzleCanvas.height) {
          return null;
        }
        return { x, y };
      }

      function capturePinch() {
        if (pointerState.size < 2) return null;
        const pointers = Array.from(pointerState.values());
        if (pointers.length < 2) return null;
        const [a, b] = pointers;
        return {
          distance: Math.hypot(b.x - a.x, b.y - a.y),
          centerX: (a.x + b.x) / 2,
          centerY: (a.y + b.y) / 2,
        };
      }

      function zoomAt(newScale, center) {
        if (!state.puzzle) return;
        const rect = canvasViewport.getBoundingClientRect();
        const localX = center.x - rect.left;
        const localY = center.y - rect.top;
        const worldX = (localX - view.offsetX) / view.scale;
        const worldY = (localY - view.offsetY) / view.scale;
        view.scale = newScale;
        view.offsetX = localX - worldX * view.scale;
        view.offsetY = localY - worldY * view.scale;
        clampView();
        applyViewTransform();
      }

      function resetView() {
        refreshViewBounds(false);
      }

      function refreshViewBounds(preservePosition) {
        if (!state.puzzle) return;
        const viewportWidth = canvasViewport.clientWidth;
        const viewportHeight = canvasViewport.clientHeight;
        if (!viewportWidth || !viewportHeight) return;
        const margins = getViewportMargins();
        const fitScale = Math.min(
          (viewportWidth - margins.horizontal * 2) / state.puzzle.width,
          (viewportHeight - margins.vertical * 2) / state.puzzle.height,
          1
        );
        view.minScale = Math.max(0.25, fitScale * 0.5);
        view.maxScale = Math.max(4, fitScale * 3);
        if (preservePosition) {
          view.scale = clamp(view.scale, view.minScale, view.maxScale);
        } else {
          view.scale = fitScale;
          view.offsetX = (viewportWidth - state.puzzle.width * view.scale) / 2;
          view.offsetY = (viewportHeight - state.puzzle.height * view.scale) / 2;
        }
        clampView();
        applyViewTransform();
      }

      function getViewportMargins() {
        const viewportWidth = canvasViewport.clientWidth || window.innerWidth;
        const viewportHeight = canvasViewport.clientHeight || window.innerHeight;
        return {
          horizontal: Math.max(24, Math.min(120, viewportWidth * 0.08)),
          vertical: Math.max(56, Math.min(160, viewportHeight * 0.14)),
        };
      }

      function clampView() {
        if (!state.puzzle) return;
        const viewportWidth = canvasViewport.clientWidth;
        const viewportHeight = canvasViewport.clientHeight;
        if (!viewportWidth || !viewportHeight) return;
        const margins = getViewportMargins();
        const displayWidth = state.puzzle.width * view.scale;
        const displayHeight = state.puzzle.height * view.scale;
        if (displayWidth + margins.horizontal * 2 <= viewportWidth) {
          view.offsetX = (viewportWidth - displayWidth) / 2;
        } else {
          const minX = viewportWidth - displayWidth - margins.horizontal;
          const maxX = margins.horizontal;
          view.offsetX = clamp(view.offsetX, minX, maxX);
        }
        if (displayHeight + margins.vertical * 2 <= viewportHeight) {
          view.offsetY = (viewportHeight - displayHeight) / 2;
        } else {
          const minY = viewportHeight - displayHeight - margins.vertical;
          const maxY = margins.vertical;
          view.offsetY = clamp(view.offsetY, minY, maxY);
        }
      }

      function applyViewTransform() {
        puzzleCanvas.style.transform = `translate(${view.offsetX}px, ${view.offsetY}px) scale(${view.scale})`;
      }

      function updateViewportStatus() {
        canvasViewport.classList.toggle("ready", Boolean(state.puzzle));
        if (!state.puzzle) {
          canvasViewport.classList.remove("panning");
        }
      }

      function getCurrentOptions() {
        return {
          targetColors: clamp(Number(colorCountEl.value) || 16, 4, 64),
          minRegion: clamp(Number(minRegionEl.value) || 30, 1, 2000),
          maxSize: clamp(Number(detailEl.value) || 768, 256, 1600),
        };
      }

      function markOptionsDirty() {
        if (!state.puzzle) return;
        const current = getCurrentOptions();
        const last = state.lastOptions;
        const dirty =
          !last ||
          current.targetColors !== last.targetColors ||
          current.minRegion !== last.minRegion ||
          current.maxSize !== last.maxSize;
        applyBtn.disabled = !dirty;
      }

      function regenerateFromSource() {
        if (!state.sourceUrl) return;
        statusMessage.textContent = "Updating puzzle with new settings...";
        loadImage(state.sourceUrl);
      }

      function handleFile(file) {
        resetPuzzleUI();
        statusMessage.textContent = "Loading image...";
        const reader = new FileReader();
        reader.onload = () => {
          const result = reader.result;
          if (typeof result === "string") {
            state.sourceUrl = result;
            document.body.classList.remove("dragging");
            startHint.classList.add("hidden");
            loadImage(result);
          }
        };
        reader.onerror = () => {
          statusMessage.textContent = "Unable to read that file.";
        };
        reader.readAsDataURL(file);
      }

      function loadImage(url) {
        const img = new Image();
        img.onload = async () => {
          try {
            await generatePuzzleFromImage(img);
          } catch (error) {
            console.error(error);
            statusMessage.textContent = "Something went wrong while generating the puzzle.";
          }
        };
        img.onerror = () => {
          statusMessage.textContent = "Unable to read that image.";
        };
        img.src = url;
      }

      function resetPuzzleUI() {
        state.puzzle = null;
        state.activeColor = null;
        state.filled = new Set();
        for (const id of pointerState.keys()) {
          if (canvasViewport.hasPointerCapture(id)) {
            canvasViewport.releasePointerCapture(id);
          }
        }
        pointerState.clear();
        pinchBase = null;
        canvasViewport.classList.remove("panning");
        view.scale = 1;
        view.offsetX = 0;
        view.offsetY = 0;
        applyViewTransform();
        updateViewportStatus();
        paletteScroller.innerHTML = "";
        progressSummary.textContent = "Processing...";
        progressDetail.textContent = "Processing...";
        resetBtn.disabled = true;
        downloadBtn.disabled = true;
        applyBtn.disabled = true;
        puzzleCtx.clearRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);
        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      }

      async function generatePuzzleFromImage(img) {
        const { targetColors, minRegion, maxSize } = getCurrentOptions();
        statusMessage.textContent = "Quantizing colours...";
        const data = await createPuzzleData(img, {
          targetColors,
          minRegion,
          maxSize,
          kmeansIters: 12,
        });
        state.puzzle = data;
        state.filled = new Set();
        state.lastOptions = { targetColors, minRegion, maxSize };
        puzzleCanvas.width = data.width;
        puzzleCanvas.height = data.height;
        previewCanvas.width = data.width;
        previewCanvas.height = data.height;
        refreshViewBounds(false);
        updateViewportStatus();
        ensureActiveColor();
        renderPreview();
        renderPuzzle();
        renderPalette();
        updateProgress();
        resetBtn.disabled = false;
        downloadBtn.disabled = false;
        applyBtn.disabled = true;
        statusMessage.textContent = `Generated ${data.regions.length} regions across ${data.palette.length} colours.`;
      }

      function renderPreview() {
        if (!state.puzzle) return;
        const { width, height, regions, palette } = state.puzzle;
        const imageData = previewCtx.createImageData(width, height);
        const data = imageData.data;
        for (const region of regions) {
          const color = palette[region.colorId - 1];
          if (!color) continue;
          const rgba = color.rgba;
          for (const idx of region.pixels) {
            const base = idx * 4;
            data[base] = rgba[0];
            data[base + 1] = rgba[1];
            data[base + 2] = rgba[2];
            data[base + 3] = 255;
          }
        }
        previewCtx.putImageData(imageData, 0, 0);
      }

      function renderPuzzle() {
        if (!state.puzzle) return;
        const { width, height, regions, palette } = state.puzzle;
        puzzleCtx.save();
        puzzleCtx.clearRect(0, 0, width, height);
        puzzleCtx.fillStyle = "#f8fafc";
        puzzleCtx.fillRect(0, 0, width, height);
        for (const region of regions) {
          if (!state.filled.has(region.id)) continue;
          const color = palette[region.colorId - 1];
          if (!color) continue;
          puzzleCtx.fillStyle = color.hex;
          for (const idx of region.pixels) {
            const x = idx % width;
            const y = (idx / width) | 0;
            puzzleCtx.fillRect(x, y, 1, 1);
          }
        }
        drawOutlines();
        drawNumbers();
        puzzleCtx.restore();
      }

      function drawNumbers() {
        if (!state.puzzle) return;
        const { regions } = state.puzzle;
        const fontSize = Math.max(10, Math.round(state.puzzle.width / 45));
        puzzleCtx.font = `${fontSize}px "Inter", "Segoe UI", sans-serif`;
        puzzleCtx.fillStyle = "rgba(15, 23, 42, 0.95)";
        puzzleCtx.textAlign = "center";
        puzzleCtx.textBaseline = "middle";
        for (const region of regions) {
          if (state.filled.has(region.id)) continue;
          puzzleCtx.fillText(String(region.colorId), region.cx, region.cy);
        }
      }

      function drawOutlines() {
        if (!state.puzzle) return;
        const { width, height, regionMap } = state.puzzle;
        puzzleCtx.fillStyle = "rgba(15, 23, 42, 0.65)";
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            const id = regionMap[idx];
            const left = x > 0 ? regionMap[idx - 1] : id;
            const right = x < width - 1 ? regionMap[idx + 1] : id;
            const up = y > 0 ? regionMap[idx - width] : id;
            const down = y < height - 1 ? regionMap[idx + width] : id;
            if (left !== id || right !== id || up !== id || down !== id) {
              puzzleCtx.fillRect(x, y, 1, 1);
            }
          }
        }
      }

      function renderPalette() {
        paletteScroller.innerHTML = "";
        if (!state.puzzle) return;
        ensureActiveColor();
        const totals = computeColorTotals();
        const incomplete = [];
        const completed = [];
        for (const color of state.puzzle.palette) {
          const remaining = countRemaining(color.id);
          const swatch = document.createElement("button");
          swatch.type = "button";
          swatch.className = "swatch";
          swatch.dataset.colorId = String(color.id);
          if (state.activeColor === color.id && remaining > 0) {
            swatch.classList.add("active");
          }
          swatch.addEventListener("click", () => {
            state.activeColor = color.id;
            renderPalette();
          });
          swatch.innerHTML = `
            <span class="sample" style="background:${color.hex}"></span>
            <span class="info">
              <strong>Colour ${color.id}</strong>
              <span>${color.hex.toUpperCase()} · ${totals.get(color.id) || 0} cells</span>
              <span>${remaining} remaining</span>
            </span>
          `;
          if (remaining === 0) {
            swatch.classList.add("completed");
            swatch.setAttribute("aria-label", `Colour ${color.id} completed`);
            completed.push(swatch);
          } else {
            swatch.setAttribute(
              "aria-label",
              `Colour ${color.id} with ${remaining} regions remaining`
            );
            incomplete.push(swatch);
          }
        }
        const fragment = document.createDocumentFragment();
        for (const swatch of incomplete) fragment.appendChild(swatch);
        for (const swatch of completed) fragment.appendChild(swatch);
        paletteScroller.appendChild(fragment);
        requestAnimationFrame(scrollActiveIntoView);
      }

      function scrollActiveIntoView() {
        const active = paletteScroller.querySelector(".swatch.active");
        if (!active) return;
        const scrollerRect = paletteScroller.getBoundingClientRect();
        const swatchRect = active.getBoundingClientRect();
        const offset = swatchRect.left - scrollerRect.left;
        const target = offset - scrollerRect.width / 2 + swatchRect.width / 2;
        const desired = paletteScroller.scrollLeft + target;
        const maxScroll = paletteScroller.scrollWidth - paletteScroller.clientWidth;
        const next = Math.min(Math.max(0, desired), Math.max(0, maxScroll));
        paletteScroller.scrollTo({
          left: next,
          behavior: "smooth",
        });
      }

      function ensureActiveColor() {
        if (!state.puzzle) return null;
        if (state.activeColor != null && countRemaining(state.activeColor) > 0) {
          return state.activeColor;
        }
        const next = findNextIncompleteColor(state.activeColor);
        state.activeColor = next;
        return next;
      }

      function findNextIncompleteColor(currentColorId) {
        if (!state.puzzle) return null;
        const palette = state.puzzle.palette;
        if (!palette.length) return null;
        let ordered;
        if (currentColorId == null) {
          ordered = palette.slice();
        } else {
          const startIndex = palette.findIndex((color) => color.id === currentColorId);
          ordered = startIndex >= 0
            ? [...palette.slice(startIndex + 1), ...palette.slice(0, startIndex + 1)]
            : palette.slice();
        }
        for (const color of ordered) {
          if (countRemaining(color.id) > 0) {
            return color.id;
          }
        }
        return null;
      }

      function computeColorTotals() {
        const totals = new Map();
        if (!state.puzzle) return totals;
        for (const region of state.puzzle.regions) {
          totals.set(region.colorId, (totals.get(region.colorId) || 0) + 1);
        }
        return totals;
      }

      function countRemaining(colorId) {
        if (!state.puzzle) return 0;
        let remaining = 0;
        for (const region of state.puzzle.regions) {
          if (region.colorId === colorId && !state.filled.has(region.id)) {
            remaining += 1;
          }
        }
        return remaining;
      }

      function updateProgress() {
        if (!state.puzzle) {
          progressSummary.textContent = "Load an image to begin.";
          progressDetail.textContent = "Load an image to begin.";
          return;
        }
        const total = state.puzzle.regions.length;
        const done = state.filled.size;
        if (done === total) {
          progressSummary.textContent = "Puzzle complete!";
          progressDetail.textContent = "Puzzle complete! Download the data or try another image.";
        } else {
          progressSummary.textContent = `Filled ${done} of ${total} regions.`;
          progressDetail.textContent = `Filled ${done} of ${total} regions.`;
        }
      }

      function flashRegion(regionId, color) {
        if (!state.puzzle) return;
        const region = state.puzzle.regions[regionId];
        if (!region) return;
        puzzleCtx.save();
        puzzleCtx.fillStyle = color;
        for (const idx of region.pixels) {
          const x = idx % state.puzzle.width;
          const y = (idx / state.puzzle.width) | 0;
          puzzleCtx.fillRect(x, y, 1, 1);
        }
        puzzleCtx.restore();
        setTimeout(() => {
          renderPuzzle();
        }, 180);
      }

      function clamp(value, min, max) {
        if (Number.isNaN(value)) return min;
        if (value < min) return min;
        if (value > max) return max;
        return value;
      }

      async function createPuzzleData(image, options) {
        const { targetColors, minRegion, maxSize, kmeansIters } = options;
        const scale = Math.min(maxSize / image.width, maxSize / image.height, 1);
        const width = Math.max(8, Math.round(image.width * scale));
        const height = Math.max(8, Math.round(image.height * scale));
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        ctx.drawImage(image, 0, 0, width, height);
        const imageData = ctx.getImageData(0, 0, width, height);
        const pixels = imageData.data;
        statusMessage.textContent = "Running k-means clustering...";
        const { centroids, assignments } = kmeansQuantize(pixels, targetColors, kmeansIters);
        statusMessage.textContent = "Cleaning tiny regions...";
        const { regionMap, regions } = segmentRegions(width, height, assignments, minRegion);
        for (const region of regions) {
          let sumX = 0;
          let sumY = 0;
          for (const idx of region.pixels) {
            sumX += idx % width;
            sumY += (idx / width) | 0;
          }
          region.cx = sumX / region.pixelCount;
          region.cy = sumY / region.pixelCount;
        }
        const palette = centroids.map((c, idx) => ({
          id: idx + 1,
          hex: `#${toHex(c[0])}${toHex(c[1])}${toHex(c[2])}`,
          rgba: c,
        }));
        for (const region of regions) {
          region.colorId = region.colorId + 1;
        }
        const normalizedRegionMap = new Int32Array(regionMap.length);
        for (let i = 0; i < regionMap.length; i++) {
          normalizedRegionMap[i] = regionMap[i];
        }
        return {
          width,
          height,
          palette,
          regions,
          regionMap: normalizedRegionMap,
        };
      }

      function kmeansQuantize(pixels, targetColors, iterations) {
        const samples = [];
        for (let i = 0; i < pixels.length; i += 4) {
          samples.push([pixels[i], pixels[i + 1], pixels[i + 2]]);
        }
        const centroids = [];
        const used = new Set();
        while (centroids.length < targetColors && centroids.length < samples.length) {
          let index = Math.floor(Math.random() * samples.length);
          let guard = 0;
          while (used.has(index) && guard < samples.length) {
            index = (index + 1) % samples.length;
            guard += 1;
          }
          used.add(index);
          centroids.push(samples[index].slice());
        }
        while (centroids.length < targetColors) {
          centroids.push(centroids[centroids.length - 1].slice());
        }
        const assignments = new Uint16Array(samples.length);
        for (let iter = 0; iter < iterations; iter++) {
          for (let i = 0; i < samples.length; i++) {
            let best = 0;
            let bestDist = Infinity;
            const pixel = samples[i];
            for (let c = 0; c < centroids.length; c++) {
              const centroid = centroids[c];
              const dist =
                (pixel[0] - centroid[0]) * (pixel[0] - centroid[0]) +
                (pixel[1] - centroid[1]) * (pixel[1] - centroid[1]) +
                (pixel[2] - centroid[2]) * (pixel[2] - centroid[2]);
              if (dist < bestDist) {
                bestDist = dist;
                best = c;
              }
            }
            assignments[i] = best;
          }
          const sums = Array.from({ length: centroids.length }, () => [0, 0, 0, 0]);
          for (let i = 0; i < samples.length; i++) {
            const target = assignments[i];
            const sample = samples[i];
            const bucket = sums[target];
            bucket[0] += sample[0];
            bucket[1] += sample[1];
            bucket[2] += sample[2];
            bucket[3] += 1;
          }
          for (let c = 0; c < centroids.length; c++) {
            const bucket = sums[c];
            if (bucket[3] === 0) continue;
            centroids[c][0] = bucket[0] / bucket[3];
            centroids[c][1] = bucket[1] / bucket[3];
            centroids[c][2] = bucket[2] / bucket[3];
          }
        }
        return { centroids: centroids.map((c) => c.map((value) => Math.round(value))), assignments };
      }

      function segmentRegions(width, height, assignments, minRegion) {
        const indexMap = new Uint16Array(assignments);
        let attempt = 0;
        let threshold = Math.max(1, minRegion);
        while (true) {
          const { regionMap, regions } = floodFill(width, height, indexMap);
          const tiny = regions.filter((region) => region.pixelCount < threshold);
          if (tiny.length === 0 || threshold <= 1) {
            return { regionMap, regions };
          }
          let changed = false;
          for (const region of tiny) {
            const colorVotes = new Map();
            for (const idx of region.pixels) {
              const x = idx % width;
              const y = (idx / width) | 0;
              const neighbors = neighborIndexes(x, y, width, height);
              for (const n of neighbors) {
                const color = indexMap[n];
                if (color === region.colorId) continue;
                colorVotes.set(color, (colorVotes.get(color) || 0) + 1);
              }
            }
            if (colorVotes.size === 0) continue;
            let bestColor = region.colorId;
            let bestVotes = -1;
            for (const [color, votes] of colorVotes.entries()) {
              if (votes > bestVotes) {
                bestVotes = votes;
                bestColor = color;
              }
            }
            if (bestColor !== region.colorId) {
              changed = true;
              for (const idx of region.pixels) {
                indexMap[idx] = bestColor;
              }
            }
          }
          attempt += 1;
          if (!changed || attempt > 6) {
            threshold = Math.max(1, Math.floor(threshold / 2));
          }
        }
      }

      function floodFill(width, height, indexMap) {
        const regionMap = new Int32Array(width * height);
        regionMap.fill(-1);
        const regions = [];
        let regionId = 0;
        const stack = [];
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const startIdx = y * width + x;
            if (regionMap[startIdx] !== -1) continue;
            const colorId = indexMap[startIdx];
            stack.push(startIdx);
            regionMap[startIdx] = regionId;
            const pixels = [];
            while (stack.length) {
              const idx = stack.pop();
              pixels.push(idx);
              const px = idx % width;
              const py = (idx / width) | 0;
              const neighbors = neighborIndexes(px, py, width, height);
              for (const n of neighbors) {
                if (regionMap[n] !== -1) continue;
                if (indexMap[n] !== colorId) continue;
                regionMap[n] = regionId;
                stack.push(n);
              }
            }
            regions.push({
              id: regionId,
              colorId,
              pixels,
              pixelCount: pixels.length,
            });
            regionId += 1;
          }
        }
        return { regionMap, regions };
      }

      function neighborIndexes(x, y, width, height) {
        const neighbors = [];
        if (x > 0) neighbors.push(y * width + (x - 1));
        if (x < width - 1) neighbors.push(y * width + (x + 1));
        if (y > 0) neighbors.push((y - 1) * width + x);
        if (y < height - 1) neighbors.push((y + 1) * width + x);
        return neighbors;
      }

      function toHex(value) {
        return value.toString(16).padStart(2, "0");
      }
    </script>
  </body>
</html>
