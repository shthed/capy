<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Color-by-Number Demo</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "Inter", "Segoe UI", -apple-system, BlinkMacSystemFont, system-ui,
          sans-serif;
        background-color: #030712;
        color: #e2e8f0;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, rgba(56, 189, 248, 0.08), transparent),
          #030712;
        color: inherit;
      }

      #root {
        min-height: 100vh;
      }

      button {
        font: inherit;
      }

      svg {
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <div id="root" role="application" aria-label="Color-by-number painting app"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel">
const { useCallback, useEffect, useMemo, useRef, useState } = React;

// Capybooper Web Game — MVP single-file React app (patched)
// Fixes: correct zoom/pan math, pan over filled cells, pinch zoom, drag-fill,
// eyedropper, auto-advance, hint stroke highlight, smoke-test HUD.
// No external libs. LocalStorage autosave. Keyboard support.

// ---------- Types ----------
/** @typedef {number} ColorId */

/**
 * @typedef PaletteItem
 * @property {ColorId} id
 * @property {string=} name
 * @property {string} rgba
 */

/**
 * @typedef Cell
 * @property {string} id
 * @property {ColorId} colorId
 * @property {string} d
 * @property {number=} area
 */

/**
 * @typedef Artwork
 * @property {string} id
 * @property {string} title
 * @property {number} width
 * @property {number} height
 * @property {PaletteItem[]} palette
 * @property {Cell[]} cells
 */

/**
 * @typedef SaveState
 * @property {string} artworkId
 * @property {Record<string, boolean>} filled
 * @property {ColorId=} activeColor
 * @property {{ scale: number; x: number; y: number }=} viewport
 * @property {number} lastSaved
 */

// ---------- Sample Artwork ----------
const DEMO_ART = {
  id: "demo-fox",
  title: "Low‑poly Fox",
  width: 1000,
  height: 1000,
  palette: [
    { id: 1, name: "Light Fur", rgba: "#F7C68E" },
    { id: 2, name: "Mid Fur", rgba: "#EAA15E" },
    { id: 3, name: "Dark Fur", rgba: "#B65A37" },
    { id: 4, name: "White", rgba: "#F2F2F2" },
    { id: 5, name: "Nose", rgba: "#222" },
    { id: 6, name: "Shadow", rgba: "#8C3E28" },
    { id: 7, name: "Ear Inner", rgba: "#F7D9B5" },
  ],
  cells: [
    { id: "c1", colorId: 7, d: "M120 90 L230 260 L120 260 Z" },
    { id: "c2", colorId: 7, d: "M880 90 L770 260 L880 260 Z" },
    { id: "c3", colorId: 3, d: "M230 260 L350 300 L200 420 Z" },
    { id: "c4", colorId: 3, d: "M770 260 L650 300 L800 420 Z" },
    { id: "c5", colorId: 2, d: "M350 300 L500 360 L650 300 L500 150 Z" },
    { id: "c6", colorId: 2, d: "M200 420 L350 300 L500 520 L300 520 Z" },
    { id: "c7", colorId: 2, d: "M800 420 L650 300 L500 520 L700 520 Z" },
    { id: "c8", colorId: 1, d: "M300 520 L500 520 L460 700 L260 620 Z" },
    { id: "c9", colorId: 1, d: "M700 520 L500 520 L540 700 L740 620 Z" },
    { id: "c10", colorId: 4, d: "M260 620 L460 700 L500 760 L440 820 L280 740 Z" },
    { id: "c11", colorId: 4, d: "M740 620 L540 700 L500 760 L560 820 L720 740 Z" },
    { id: "c12", colorId: 4, d: "M440 820 L500 760 L560 820 L500 900 Z" },
    { id: "c13", colorId: 5, d: "M480 820 L520 820 L500 840 Z" },
    { id: "c14", colorId: 6, d: "M350 300 L420 380 L500 360 Z" },
    { id: "c15", colorId: 6, d: "M650 300 L580 380 L500 360 Z" },
    { id: "c16", colorId: 6, d: "M460 700 L500 640 L540 700 L500 760 Z" },
    { id: "c17", colorId: 6, d: "M440 820 L500 900 L420 880 Z" },
    { id: "c18", colorId: 6, d: "M560 820 L500 900 L580 880 Z" },
    { id: "c19", colorId: 1, d: "M300 520 L260 620 L220 560 Z" },
    { id: "c20", colorId: 1, d: "M700 520 L740 620 L780 560 Z" },
    { id: "c21", colorId: 2, d: "M420 380 L500 520 L500 360 Z" },
    { id: "c22", colorId: 2, d: "M580 380 L500 520 L500 360 Z" },
    { id: "c23", colorId: 7, d: "M170 220 L200 260 L140 260 Z" },
    { id: "c24", colorId: 7, d: "M830 220 L800 260 L860 260 Z" },
  ].map((c) => ({ ...c, area: estimatePathArea(c.d) })),
};

function cloneArtwork(art) {
  return {
    ...art,
    palette: (art.palette ?? []).map((p) => ({ ...p })),
    cells: (art.cells ?? []).map((c) => ({ ...c })),
  };
}

function getStarterArtworks() {
  return [cloneArtwork(DEMO_ART)];
}

// Rough polygon area estimator for simple paths.
function estimatePathArea(d) {
  try {
    const tokens = d.split(/[ ,]/).filter(Boolean);
    const pts = [];
    for (let i = 0; i < tokens.length; i++) {
      const t = tokens[i];
      if (t === "M" || t === "L" || t === "Z") continue;
      const n = Number(t);
      if (!Number.isNaN(n)) pts.push(n);
    }
    const xy = [];
    for (let i = 0; i + 1 < pts.length; i += 2) xy.push([pts[i], pts[i + 1]]);
    let area = 0;
    for (let i = 0; i < xy.length; i++) {
      const [x1, y1] = xy[i];
      const [x2, y2] = xy[(i + 1) % xy.length];
      area += x1 * y2 - x2 * y1;
    }
    return Math.abs(area / 2);
  } catch (err) {
    return 1000;
  }
}

// ---------- Utilities ----------
const SAVE_KEY = (artId) => `capybooper_save_${artId}`;
const ARTWORKS_KEY = "capybooper_artworks_v1";
const ACTIVE_ART_KEY = "capybooper_active_art";

function normalizeArtwork(raw) {
  if (!raw) return null;
  try {
    const width = Number(raw.width);
    const height = Number(raw.height);
    if (!Number.isFinite(width) || width <= 0) return null;
    if (!Number.isFinite(height) || height <= 0) return null;
    const palette = Array.isArray(raw.palette)
      ? raw.palette
          .map((item) => ({
            id: item.id,
            name: item.name ?? undefined,
            rgba: item.rgba,
          }))
          .filter((item) => item.id !== undefined && typeof item.rgba === "string")
      : [];
    const cells = Array.isArray(raw.cells)
      ? raw.cells
          .map((cell) => ({
            id: cell.id,
            colorId: cell.colorId,
            d: cell.d,
            area: cell.area ?? estimatePathArea(cell.d ?? ""),
          }))
          .filter(
            (cell) =>
              typeof cell.id === "string" &&
              cell.id.length > 0 &&
              typeof cell.d === "string" &&
              cell.d.length > 0 &&
              cell.colorId !== undefined
          )
      : [];
    const title = (raw.title ?? "").trim();
    let id = (raw.id ?? "").toString().trim();
    if (!title || !palette.length || !cells.length) return null;
    if (!id) {
      const slug = title
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "");
      id = slug || `art-${Math.random().toString(36).slice(2, 8)}`;
    }
    return {
      id,
      title,
      width,
      height,
      palette,
      cells,
    };
  } catch (err) {
    return null;
  }
}

function loadArtworks() {
  try {
    const raw = localStorage.getItem(ARTWORKS_KEY);
    if (!raw) return getStarterArtworks();
    const parsed = JSON.parse(raw);
    const normalized = (Array.isArray(parsed) ? parsed : [])
      .map((art) => normalizeArtwork(art))
      .filter(Boolean);
    return normalized.length ? normalized : getStarterArtworks();
  } catch (err) {
    return getStarterArtworks();
  }
}

function persistArtworks(list) {
  try {
    localStorage.setItem(ARTWORKS_KEY, JSON.stringify(list));
  } catch (err) {}
}

function loadActiveArtworkId(artworks) {
  try {
    const stored = localStorage.getItem(ACTIVE_ART_KEY);
    if (!stored) return artworks?.[0]?.id ?? null;
    return artworks?.some((art) => art.id === stored) ? stored : artworks?.[0]?.id ?? null;
  } catch (err) {
    return artworks?.[0]?.id ?? null;
  }
}

function persistActiveArtworkId(id) {
  try {
    if (id) {
      localStorage.setItem(ACTIVE_ART_KEY, id);
    } else {
      localStorage.removeItem(ACTIVE_ART_KEY);
    }
  } catch (err) {}
}

const DEFAULT_CONFIG = {
  enableAutosave: true,
  autoAdvanceOnComplete: true,
  enableHintPulse: true,
  enableDragFill: true,
  enableEyedropper: true,
  enableKeyboardShortcuts: true,
  showNumberBadges: true,
  showHeatmapDots: true,
  enableSmokeHud: true,
};

const CONFIG_KEY = "capybooper_config";

function loadConfig() {
  try {
    const raw = localStorage.getItem(CONFIG_KEY);
    if (!raw) return DEFAULT_CONFIG;
    const parsed = JSON.parse(raw);
    return { ...DEFAULT_CONFIG, ...parsed };
  } catch (err) {
    return DEFAULT_CONFIG;
  }
}

function persistConfig(next) {
  try {
    localStorage.setItem(CONFIG_KEY, JSON.stringify(next));
  } catch (err) {}
}

function shallowEqual(a, b) {
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) return false;
  for (const key of keysA) if (a[key] !== b[key]) return false;
  return true;
}

function loadSave(art) {
  if (!art) return undefined;
  try {
    const raw = localStorage.getItem(SAVE_KEY(art.id));
    if (!raw) return undefined;
    const s = JSON.parse(raw);
    if (s.artworkId !== art.id) return undefined;
    return s;
  } catch (err) {
    return undefined;
  }
}

function persistSave(art, s) {
  if (!art) return;
  try {
    localStorage.setItem(SAVE_KEY(art.id), JSON.stringify(s));
  } catch (err) {}
}

function clearSave(artId) {
  try {
    localStorage.removeItem(SAVE_KEY(artId));
  } catch (err) {}
}

function computeRemaining(art, filled) {
  if (!art) return {};
  const map = {};
  for (const p of art.palette) map[p.id] = 0;
  for (const c of art.cells) if (!filled[c.id]) map[c.colorId] = (map[c.colorId] ?? 0) + 1;
  return map;
}

// ---------- App ----------
﻿function App() {
  const initialConfig = useMemo(() => loadConfig(), []);
  const initialArtworksRef = useRef(null);

  if (initialArtworksRef.current === null) {
    initialArtworksRef.current = loadArtworks();
  }

  const [artworks, setArtworks] = useState(initialArtworksRef.current);
  const [activeArtworkId, setActiveArtworkIdState] = useState(() =>
    loadActiveArtworkId(initialArtworksRef.current)
  );
  const [config, setConfig] = useState(initialConfig);
  const isDefaultConfig = useMemo(() => shallowEqual(config, DEFAULT_CONFIG), [config]);

  const art = useMemo(() => {
    const match = artworks.find((entry) => entry.id === activeArtworkId);
    return match ?? artworks[0] ?? null;
  }, [artworks, activeArtworkId]);

  const [filled, setFilled] = useState({});
  const [activeColor, setActiveColor] = useState(art?.palette?.[0]?.id ?? null);
  const [scale, setScale] = useState(0.9);
  const [offset, setOffset] = useState({ x: 50, y: 50 });
  const [lastAction, setLastAction] = useState(null);
  const [hintPulse, setHintPulse] = useState(new Set());
  const [showTests, setShowTests] = useState(initialConfig.enableSmokeHud);
  const [showOptions, setShowOptions] = useState(false);
  const [showLibrary, setShowLibrary] = useState(false);
  const [libraryRevision, setLibraryRevision] = useState(0);

  const selectArtwork = useCallback((id) => {
    setActiveArtworkIdState(id);
    persistActiveArtworkId(id ?? null);
  }, []);

  useEffect(() => {
    persistArtworks(artworks);
  }, [artworks]);

  useEffect(() => {
    if (!artworks.length) {
      selectArtwork(null);
      return;
    }
    if (!artworks.some((entry) => entry.id === activeArtworkId)) {
      selectArtwork(artworks[0].id);
    }
  }, [artworks, activeArtworkId, selectArtwork]);

  useEffect(() => {
    if (!art) {
      setFilled({});
      setActiveColor(null);
      setScale(0.9);
      setOffset({ x: 50, y: 50 });
      setLastAction(null);
      setHintPulse(new Set());
      return;
    }
    const saved = loadSave(art);
    setFilled(saved?.filled ?? {});
    setActiveColor(saved?.activeColor ?? art.palette?.[0]?.id ?? null);
    setScale(saved?.viewport?.scale ?? 0.9);
    setOffset({
      x: saved?.viewport?.x ?? 50,
      y: saved?.viewport?.y ?? 50,
    });
    setLastAction(null);
    setHintPulse(new Set());
  }, [art?.id]);

  const {
    enableAutosave,
    autoAdvanceOnComplete,
    enableHintPulse,
    enableDragFill,
    enableEyedropper,
    enableKeyboardShortcuts,
    showNumberBadges,
    showHeatmapDots,
    enableSmokeHud,
  } = config;

  useEffect(() => {
    if (!enableAutosave || !art) return;
    const t = setTimeout(() => {
      persistSave(art, {
        artworkId: art.id,
        filled,
        activeColor,
        viewport: { scale, x: offset.x, y: offset.y },
        lastSaved: Date.now(),
      });
    }, 800);
    return () => clearTimeout(t);
  }, [art, filled, activeColor, scale, offset, enableAutosave]);

  const remaining = useMemo(() => computeRemaining(art, filled), [art, filled]);
  const totalCells = art?.cells?.length ?? 0;
  const filledCount = Object.values(filled).filter(Boolean).length;
  const progress = totalCells > 0 ? Math.round((filledCount / totalCells) * 100) : 0;

  const libraryProgress = useMemo(() => {
    const map = {};
    artworks.forEach((entry) => {
      if (!entry) return;
      if (art && entry.id === art.id) {
        map[entry.id] = progress;
        return;
      }
      const total = entry.cells?.length ?? 0;
      const saved = loadSave(entry);
      if (!saved) {
        map[entry.id] = 0;
        return;
      }
      const count = Object.values(saved.filled ?? {}).filter(Boolean).length;
      map[entry.id] = total > 0 ? Math.round((count / total) * 100) : 0;
    });
    return map;
  }, [artworks, art?.id, progress, libraryRevision]);

  const handleImportArtwork = useCallback(
    (json) => {
      if (!json || !json.trim()) {
        return { ok: false, error: "Paste artwork JSON first." };
      }
      try {
        const parsed = JSON.parse(json);
        const normalized = normalizeArtwork(parsed);
        if (!normalized) {
          return {
            ok: false,
            error:
              "The JSON is missing required fields (id, title, width, height, palette, cells).",
          };
        }
        const existingIds = new Set(artworks.map((item) => item.id));
        const baseId = normalized.id || `art-${Math.random().toString(36).slice(2, 8)}`;
        let uniqueId = baseId;
        let suffix = 2;
        while (existingIds.has(uniqueId)) {
          uniqueId = `${baseId}-${suffix++}`;
        }
        const finalArtwork = { ...normalized, id: uniqueId };
        setArtworks((prev) => [...prev, finalArtwork]);
        selectArtwork(finalArtwork.id);
        setLibraryRevision((v) => v + 1);
        return { ok: true, artwork: finalArtwork };
      } catch (err) {
        return {
          ok: false,
          error: err instanceof Error ? err.message : "Unable to parse the JSON payload.",
        };
      }
    },
    [artworks, selectArtwork]
  );

  const handleDeleteArtwork = useCallback(
    (id) => {
      setArtworks((prev) => {
        const next = prev.filter((entry) => entry.id !== id);
        if (!next.length) {
          selectArtwork(null);
          return [];
        }
        if (!next.some((entry) => entry.id === activeArtworkId)) {
          selectArtwork(next[0].id);
        }
        return next;
      });
      clearSave(id);
      setLibraryRevision((v) => v + 1);
      if (art && art.id === id) {
        setFilled({});
        setActiveColor(null);
        setScale(0.9);
        setOffset({ x: 50, y: 50 });
        setLastAction(null);
        setHintPulse(new Set());
        setShowLibrary(true);
      }
    },
    [art, activeArtworkId, selectArtwork, setShowLibrary]
  );

  const handleRenameArtwork = useCallback((id, nextTitle) => {
    const title = (nextTitle ?? "").trim() || "Untitled artwork";
    setArtworks((prev) => prev.map((entry) => (entry.id === id ? { ...entry, title } : entry)));
  }, []);

  const handleClearProgress = useCallback(
    (id) => {
      clearSave(id);
      setLibraryRevision((v) => v + 1);
      if (art && art.id === id) {
        setFilled({});
        setActiveColor(art.palette?.[0]?.id ?? null);
        setScale(0.9);
        setOffset({ x: 50, y: 50 });
        setLastAction(null);
        setHintPulse(new Set());
      }
    },
    [art]
  );

  const previousSmokePreferenceRef = useRef(initialConfig.enableSmokeHud);

  useEffect(() => {
    if (!enableSmokeHud) {
      previousSmokePreferenceRef.current = showTests;
      setShowTests(false);
    } else {
      setShowTests((prev) => prev || previousSmokePreferenceRef.current);
    }
  }, [enableSmokeHud, showTests]);

  useEffect(() => {
    if (!showOptions) return;
    function onKeyDown(e) {
      if (e.key === "Escape") setShowOptions(false);
    }
    window.addEventListener("keydown", onKeyDown);
    return () => window.removeEventListener("keydown", onKeyDown);
  }, [showOptions]);

  const svgRef = useRef(null);
  const isPanningRef = useRef(false);
  const isPaintingRef = useRef(false);
  const lastPosRef = useRef(null);
  const movedRef = useRef(0);
  const eyedropCandidateRef = useRef(null);
  const pointersRef = useRef(new Map());
  const pinchRef = useRef(null);

  function cssToArt(svg, clientX, clientY) {
    if (!art) return { pxArt: 0, pyArt: 0 };
    const rect = svg.getBoundingClientRect();
    const sx = art.width / rect.width;
    const sy = art.height / rect.height;
    const pxArt = (clientX - rect.left) * sx;
    const pyArt = (clientY - rect.top) * sy;
    return { pxArt, pyArt };
  }

  function onWheel(e) {
    if (!art) return;
    e.preventDefault();
    const factor = Math.exp(-e.deltaY * 0.0015);
    const newScale = clamp(scale * factor, 0.3, 4);

    const svg = svgRef.current;
    if (svg) {
      const { pxArt, pyArt } = cssToArt(svg, e.clientX, e.clientY);
      const artX = (pxArt - offset.x) / scale;
      const artY = (pyArt - offset.y) / scale;
      setOffset({ x: pxArt - artX * newScale, y: pyArt - artY * newScale });
    }
    setScale(newScale);
  }

  function onPointerDown(e) {
    if (!art) return;
    const svg = svgRef.current;
    svg?.setPointerCapture?.(e.pointerId);
    pointersRef.current.set(e.pointerId, { x: e.clientX, y: e.clientY });

    const target = e.target;
    const cid = target?.dataset?.cellId;
    movedRef.current = 0;

    if (pointersRef.current.size === 2 && !pinchRef.current) {
      const ids = Array.from(pointersRef.current.keys());
      const p1 = pointersRef.current.get(ids[0]);
      const p2 = pointersRef.current.get(ids[1]);
      const d0 = Math.hypot(p2.x - p1.x, p2.y - p1.y);
      const mid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      pinchRef.current = { id1: ids[0], id2: ids[1], d0, s0: scale, mid0: mid };
      isPanningRef.current = false;
      isPaintingRef.current = false;
      eyedropCandidateRef.current = null;
      return;
    }

    if (cid) {
      const already = !!filled[cid];
      if (already) {
        eyedropCandidateRef.current = enableEyedropper ? cid : null;
        isPanningRef.current = true;
        lastPosRef.current = { x: e.clientX, y: e.clientY };
        return;
      }
      isPaintingRef.current = true;
      onCellTap(cid);
      return;
    }
    isPanningRef.current = true;
    lastPosRef.current = { x: e.clientX, y: e.clientY };
  }

  function onPointerMove(e) {
    if (!art) return;
    const svg = svgRef.current;
    pointersRef.current.set(e.pointerId, { x: e.clientX, y: e.clientY });

    if (pinchRef.current) {
      const { id1, id2, d0, s0, mid0 } = pinchRef.current;
      const p1 = pointersRef.current.get(id1);
      const p2 = pointersRef.current.get(id2);
      if (p1 && p2) {
        const d = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        const factor = d0 > 0 ? d / d0 : 1;
        const newScale = clamp(s0 * factor, 0.3, 4);
        const { pxArt, pyArt } = cssToArt(svg, mid0.x, mid0.y);
        const artX = (pxArt - offset.x) / scale;
        const artY = (pyArt - offset.y) / scale;
        setOffset({ x: pxArt - artX * newScale, y: pyArt - artY * newScale });
        setScale(newScale);
      }
      return;
    }

    if (isPaintingRef.current) {
      if (!enableDragFill) return;
      const target = e.target;
      const id = target?.dataset?.cellId;
      if (id) onCellTap(id);
      return;
    }

    if (isPanningRef.current && lastPosRef.current) {
      const rect = svg.getBoundingClientRect();
      const sx = art.width / rect.width;
      const sy = art.height / rect.height;
      const dxPx = e.clientX - lastPosRef.current.x;
      const dyPx = e.clientY - lastPosRef.current.y;
      movedRef.current += Math.hypot(dxPx, dyPx);
      lastPosRef.current = { x: e.clientX, y: e.clientY };
      setOffset((o) => ({ x: o.x + dxPx * sx, y: o.y + dyPx * sy }));
    }
  }

  function onPointerUp(e) {
    if (!art) return;
    const svg = svgRef.current;
    svg?.releasePointerCapture?.(e.pointerId);

    if (enableEyedropper && eyedropCandidateRef.current && movedRef.current < 6) {
      const cell = art.cells.find((c) => c.id === eyedropCandidateRef.current);
      if (cell && (remaining[cell.colorId] ?? 0) > 0) setActiveColor(cell.colorId);
    }

    pointersRef.current.delete(e.pointerId);
    if (pinchRef.current && (e.pointerId === pinchRef.current.id1 || e.pointerId === pinchRef.current.id2)) {
      pinchRef.current = null;
    }

    isPanningRef.current = false;
    isPaintingRef.current = false;
    lastPosRef.current = null;
    eyedropCandidateRef.current = null;
    movedRef.current = 0;
  }

  function onCellTap(cellId) {
    if (!art || activeColor == null) return;
    const cell = art.cells.find((c) => c.id === cellId);
    if (!cell) return;

    if (filled[cellId]) return;

    if (cell.colorId !== activeColor) {
      const el = document.getElementById(cellId);
      if (el) {
        el.setAttribute("stroke", "#d22");
        el.setAttribute("stroke-width", "4");
        setTimeout(() => {
          el.setAttribute("stroke", "#444");
          el.setAttribute("stroke-width", "2");
        }, 220);
      }
      return;
    }

    const willCompleteColor = (remaining[activeColor] ?? 0) === 1;
    setFilled((prev) => ({ ...prev, [cellId]: true }));
    setLastAction(cellId);
    if (willCompleteColor && autoAdvanceOnComplete) nextColor();
  }

  function undo() {
    if (!lastAction) return;
    setFilled((prev) => ({ ...prev, [lastAction]: false }));
    setLastAction(null);
  }

  function hint() {
    if (!enableHintPulse || !art || activeColor == null) return;
    const candidates = art.cells
      .filter((c) => c.colorId === activeColor && !filled[c.id])
      .sort((a, b) => (a.area ?? 0) - (b.area ?? 0))
      .slice(0, 3);
    const ids = new Set(candidates.map((c) => c.id));
    setHintPulse(ids);
    setTimeout(() => setHintPulse(new Set()), 1000);
  }

  function resetView() {
    setScale(0.9);
    setOffset({ x: 50, y: 50 });
  }

  function nextColor() {
    if (!art || activeColor == null) return;
    const order = art.palette.map((p) => p.id);
    const startIdx = order.indexOf(activeColor);
    for (let i = 1; i <= order.length; i++) {
      const id = order[(startIdx + i) % order.length];
      if ((remaining[id] ?? 0) > 0) {
        setActiveColor(id);
        return;
      }
    }
  }

  function handleConfigChange(key, value) {
    setConfig((prev) => {
      if (prev[key] === value) return prev;
      const next = { ...prev, [key]: value };
      persistConfig(next);
      return next;
    });
  }

  function handleConfigReset() {
    setConfig((prev) => {
      if (shallowEqual(prev, DEFAULT_CONFIG)) return prev;
      persistConfig(DEFAULT_CONFIG);
      return DEFAULT_CONFIG;
    });
    previousSmokePreferenceRef.current = DEFAULT_CONFIG.enableSmokeHud;
    setShowTests(DEFAULT_CONFIG.enableSmokeHud);
  }

  useEffect(() => {
    if (!enableKeyboardShortcuts) return;
    function onKey(e) {
      if (e.key === "0") resetView();
      if (e.key === "+" || e.key === "=") setScale((s) => clamp(s * 1.1, 0.3, 4));
      if (e.key === "-" || e.key === "_") setScale((s) => clamp(s / 1.1, 0.3, 4));
      if (e.key.toLowerCase() === "h") hint();
      if (e.key.toLowerCase() === "n") nextColor();
      if (e.key.toLowerCase() === "u") undo();
      if (e.key.toLowerCase() === "t" && enableSmokeHud) setShowTests((v) => !v);
      if (e.key === "Escape") {
        if (showOptions) setShowOptions(false);
        if (showLibrary) setShowLibrary(false);
      }
    }
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [enableKeyboardShortcuts, enableSmokeHud, showOptions, showLibrary]);

  const headerTitle = art ? art.title : "No artwork selected";
  const progressLabel = art ? `Progress: ${progress}%` : "Add or load an artwork";

  return (
    React.createElement(
      "div",
      { style: styles.app },
      React.createElement(
        "header",
        { style: styles.header },
        React.createElement(
          "button",
          {
            "aria-label": "Open art library",
            title: "Manage artworks",
            style: styles.back,
            onClick: () => setShowLibrary(true),
          },
          "LIB"
        ),
        React.createElement("div", { style: { fontWeight: 600 } }, headerTitle),
        React.createElement(
          "div",
          { style: styles.headerRight },
          React.createElement(
            "span",
            { "aria-live": "polite", style: { marginRight: 12 } },
            progressLabel
          ),
          React.createElement(
            "button",
            {
              style: styles.iconBtn,
              onClick: () => setShowOptions(true),
              title: "Options and app overview",
              "aria-haspopup": "dialog",
            },
            "\u2699"
          ),
          React.createElement(
            "button",
            { style: styles.iconBtn, onClick: resetView, title: "Fit to screen" },
            "\u2922"
          ),
          React.createElement(
            "button",
            { style: styles.iconBtn, onClick: undo, title: "Undo" },
            "\u21B6"
          ),
          React.createElement(
            "button",
            {
              style: {
                ...styles.iconBtn,
                opacity: enableHintPulse ? 1 : 0.4,
                cursor: enableHintPulse ? "pointer" : "not-allowed",
              },
              onClick: hint,
              title: "Hint",
              disabled: !enableHintPulse,
            },
            "\uD83D\uDCA1"
          ),
          React.createElement(
            "button",
            { style: styles.iconBtn, onClick: nextColor, title: "Next color" },
            "\u27A1"
          ),
          React.createElement(
            "button",
            {
              style: {
                ...styles.iconBtn,
                opacity: enableSmokeHud ? 1 : 0.4,
                cursor: enableSmokeHud ? "pointer" : "not-allowed",
              },
              onClick: () => enableSmokeHud && setShowTests((v) => !v),
              title: "Toggle tests",
              disabled: !enableSmokeHud,
              "aria-pressed": showTests,
            },
            "\u2714"
          )
        )
      ),
      showLibrary &&
        React.createElement(ArtLibrary, {
          artworks: artworks,
          activeArtworkId: activeArtworkId,
          progressMap: libraryProgress,
          onSelect: (id) => {
            selectArtwork(id);
            setShowLibrary(false);
          },
          onClose: () => setShowLibrary(false),
          onImport: handleImportArtwork,
          onDelete: handleDeleteArtwork,
          onRename: handleRenameArtwork,
          onClearProgress: handleClearProgress,
        }),
      showOptions &&
        React.createElement(OptionsPanel, {
          config: config,
          onToggle: handleConfigChange,
          canReset: !isDefaultConfig,
          onReset: handleConfigReset,
          onClose: () => setShowOptions(false),
        }),
      React.createElement(
        "main",
        { style: styles.main },
        art
          ? React.createElement(
              "div",
              { id: "artframe", style: styles.artframe },
              React.createElement(
                "svg",
                {
                  ref: svgRef,
                  width: "100%",
                  height: "100%",
                  viewBox: `0 0 ${art.width} ${art.height}`,
                  style: { background: "#0f172a", touchAction: "none" },
                  onWheel: onWheel,
                  onPointerDown: onPointerDown,
                  onPointerMove: onPointerMove,
                  onPointerUp: onPointerUp,
                },
                React.createElement(
                  "g",
                  { transform: `translate(${offset.x} ${offset.y}) scale(${scale})` },
                  React.createElement("rect", {
                    x: 0,
                    y: 0,
                    width: art.width,
                    height: art.height,
                    fill: "#0f172a",
                    stroke: "#1e293b",
                  }),
                  art.cells.map((c) => {
                    const isFilled = !!filled[c.id];
                    const pal = art.palette.find((p) => p.id === c.colorId);
                    const showPulse = hintPulse.has(c.id);
                    return React.createElement(
                      "g",
                      { key: c.id },
                      isFilled &&
                        React.createElement("path", {
                          d: c.d,
                          fill: pal?.rgba,
                          pointerEvents: "none",
                        }),
                      React.createElement("path", {
                        id: c.id,
                        "data-cell-id": c.id,
                        "data-color-id": c.colorId,
                        d: c.d,
                        fill: isFilled ? "transparent" : "#0f172a",
                        stroke: showPulse ? "#f2c200" : "#334155",
                        strokeWidth: showPulse ? 4 : 2,
                        style: {
                          cursor: isFilled ? "grab" : "pointer",
                          opacity: isFilled ? 0.35 : 1,
                        },
                        "aria-label": `Cell ${c.id}. Target color ${c.colorId}. ${isFilled ? "Filled" : "Unfilled"}`,
                      }),
                      !isFilled && showNumberBadges && scale >= 0.6 &&
                        React.createElement(NumberLabel, { d: c.d, text: `${c.colorId}` }),
                      !isFilled && showHeatmapDots && scale < 0.6 &&
                        React.createElement(HeatDot, { d: c.d })
                    );
                  })
                )
              )
            )
          : React.createElement(
              "div",
              { style: styles.emptyArtState },
              "Import or add an artwork in the library to start painting."
            ),
        enableSmokeHud && showTests && art && React.createElement(SmokeTests, { art: art, filled: filled })
      ),
      React.createElement(
        "footer",
        { style: styles.footer },
        art
          ? React.createElement(Palette, {
              palette: art.palette,
              remaining: remaining,
              activeColor: activeColor,
              onSelect: setActiveColor,
            })
          : React.createElement("div", { style: styles.footerEmpty }, "No palette available yet.")
      )
    )
  );
}

// ---------- Helpers: Number label & heat dot ----------
function centroidFromPath(d) {
  const tokens = d.split(/[ ,]/).filter(Boolean);
  const pts = [];
  for (let i = 0; i < tokens.length; i++) {
    const t = tokens[i];
    if (t === "M" || t === "L" || t === "Z") continue;
    const n = Number(t);
    if (!Number.isNaN(n)) pts.push(n);
  }
  const xy = [];
  for (let i = 0; i + 1 < pts.length; i += 2) xy.push([pts[i], pts[i + 1]]);
  let cx = 0,
    cy = 0,
    a = 0;
  for (let i = 0; i < xy.length; i++) {
    const [x1, y1] = xy[i];
    const [x2, y2] = xy[(i + 1) % xy.length];
    const cross = x1 * y2 - x2 * y1;
    a += cross;
    cx += (x1 + x2) * cross;
    cy += (y1 + y2) * cross;
  }
  a *= 0.5;
  if (Math.abs(a) < 1e-5) return { x: xy[0]?.[0] ?? 0, y: xy[0]?.[1] ?? 0 };
  return { x: cx / (6 * a), y: cy / (6 * a) };
}

function NumberLabel({ d, text }) {
  const { x, y } = centroidFromPath(d);
  return React.createElement(
    "g",
    { pointerEvents: "none" },
    React.createElement("circle", { cx: x, cy: y, r: 16, fill: "rgba(15, 23, 42, 0.9)" }),
    React.createElement(
      "text",
      {
        x,
        y: y + 5,
        fontSize: 24,
        textAnchor: "middle",
        fill: "#e2e8f0",
        fontFamily: "ui-sans-serif, system-ui",
      },
      text
    )
  );
}

function HeatDot({ d }) {
  const { x, y } = centroidFromPath(d);
  return React.createElement("circle", { pointerEvents: "none", cx: x, cy: y, r: 6, fill: "#94a3b8" });
}

// ---------- Palette ----------
function Palette({ palette, remaining, activeColor, onSelect }) {
  return React.createElement(
    "div",
    { style: styles.paletteWrap },
    palette.map((p) => {
      const left = remaining[p.id] ?? 0;
      const isActive = p.id === activeColor;
      return React.createElement(
        "button",
        {
          key: p.id,
          onClick: () => onSelect(p.id),
          disabled: left === 0 && !isActive,
          "aria-pressed": isActive,
          title: `${p.name ?? "Color"} #${p.id} • Remaining ${left}`,
          style: {
            ...styles.swatch,
            borderColor: isActive ? "#f8fafc" : "transparent",
            boxShadow: isActive ? "0 0 0 2px rgba(148, 163, 184, 0.4)" : undefined,
            opacity: left === 0 ? 0.4 : 1,
          },
        },
        React.createElement(
          "div",
          { style: { ...styles.swatchChip, background: p.rgba } },
          React.createElement("span", { style: styles.swatchNumber }, p.id)
        ),
        React.createElement(
          "div",
          { style: styles.swatchMeta },
          React.createElement("span", { style: styles.swatchCountLabel }, "Cells"),
          React.createElement("span", { style: styles.swatchCount }, left)
        )
      );
    })
  );
}

﻿function ArtLibrary({
  artworks,
  activeArtworkId,
  progressMap,
  onSelect,
  onClose,
  onImport,
  onDelete,
  onRename,
  onClearProgress,
}) {
  const [draft, setDraft] = useState("");
  const [feedback, setFeedback] = useState(null);
  const [editingId, setEditingId] = useState(null);
  const [titleDraft, setTitleDraft] = useState("");
  const [promptStatus, setPromptStatus] = useState(null);
  const promptTimerRef = useRef(null);

  const sorted = useMemo(
    () => [...artworks].sort((a, b) => a.title.localeCompare(b.title)),
    [artworks]
  );

  useEffect(() => {
    function handleKey(e) {
      if (e.key === "Escape") onClose();
    }
    window.addEventListener("keydown", handleKey);
    return () => window.removeEventListener("keydown", handleKey);
  }, [onClose]);

  useEffect(() => {
    return () => {
      if (promptTimerRef.current) clearTimeout(promptTimerRef.current);
    };
  }, []);

  const promptText = `You are an SVG color-by-number generator. Produce JSON with keys: id (short slug), title, width, height, palette (array of { id, name, rgba }), and cells (array of { id, colorId, d } path commands using only M/L/Z). Ensure 40-80 cells and 6-12 palette entries. Colors should be polished and themed. Return JSON only.`;

  function schedulePromptStatus(status) {
    setPromptStatus(status);
    if (promptTimerRef.current) {
      clearTimeout(promptTimerRef.current);
    }
    promptTimerRef.current = setTimeout(() => setPromptStatus(null), 2500);
  }

  function handleCopyPrompt() {
    const clipboard = navigator?.clipboard;
    if (clipboard?.writeText) {
      clipboard
        .writeText(promptText)
        .then(() =>
          schedulePromptStatus({ type: "success", message: "Prompt copied to clipboard." })
        )
        .catch(() =>
          schedulePromptStatus({
            type: "error",
            message: "Clipboard copy failed. Copy manually below.",
          })
        );
      return;
    }

    try {
      const textarea = document.createElement("textarea");
      textarea.value = promptText;
      textarea.setAttribute("readonly", "true");
      textarea.style.position = "absolute";
      textarea.style.left = "-9999px";
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand("copy");
      document.body.removeChild(textarea);
      schedulePromptStatus({ type: "success", message: "Prompt copied to clipboard." });
    } catch (err) {
      schedulePromptStatus({ type: "error", message: "Clipboard copy failed. Copy manually below." });
    }
  }

  function handleImportSubmit(e) {
    e?.preventDefault?.();
    const result = onImport(draft);
    if (result?.ok) {
      setDraft("");
      setFeedback({ type: "success", message: `Imported "${result.artwork.title}".` });
      setEditingId(null);
      setTitleDraft("");
    } else if (result?.error) {
      setFeedback({ type: "error", message: result.error });
    } else {
      setFeedback({ type: "error", message: "Unable to import artwork." });
    }
  }

  function startEditing(art) {
    setEditingId(art.id);
    setTitleDraft(art.title);
  }

  function saveEdit() {
    onRename(editingId, titleDraft);
    setEditingId(null);
    setTitleDraft("");
  }

  function cancelEdit() {
    setEditingId(null);
    setTitleDraft("");
  }

  const list = sorted.length
    ? sorted.map((art) => {
        const isActive = art.id === activeArtworkId;
        const isEditing = editingId === art.id;
        const progress = progressMap?.[art.id] ?? 0;
        return React.createElement(
          "div",
          {
            key: art.id,
            style: {
              ...styles.libraryItem,
              ...(isActive ? styles.libraryItemActive : {}),
            },
          },
          React.createElement(
            "div",
            { style: styles.libraryItemHeader },
            isEditing
              ? React.createElement("input", {
                  style: styles.libraryTitleInput,
                  value: titleDraft,
                  onChange: (e) => setTitleDraft(e.target.value),
                  autoFocus: true,
                })
              : React.createElement("div", { style: styles.libraryItemTitle }, art.title),
            React.createElement(
              "span",
              {
                style: {
                  ...styles.libraryBadge,
                  ...(isActive ? styles.libraryBadgeActive : {}),
                },
              },
              isActive ? "Active" : `${progress}%`
            )
          ),
          React.createElement(
            "div",
            { style: styles.libraryMeta },
            `Progress: ${progress}% - ${art.palette.length} colors - ${art.cells.length} cells`
          ),
          React.createElement(
            "div",
            { style: styles.libraryButtons },
            isEditing
              ? [
                  React.createElement(
                    "button",
                    {
                      key: "save",
                      type: "button",
                      style: styles.libraryPrimaryButton,
                      onClick: saveEdit,
                    },
                    "Save"
                  ),
                  React.createElement(
                    "button",
                    {
                      key: "cancel",
                      type: "button",
                      style: styles.libraryButton,
                      onClick: cancelEdit,
                    },
                    "Cancel"
                  ),
                ]
              : [
                  React.createElement(
                    "button",
                    {
                      key: "load",
                      type: "button",
                      style: styles.libraryPrimaryButton,
                      onClick: () => onSelect(art.id),
                    },
                    isActive ? "Resume" : "Load"
                  ),
                  React.createElement(
                    "button",
                    {
                      key: "rename",
                      type: "button",
                      style: styles.libraryButton,
                      onClick: () => startEditing(art),
                    },
                    "Rename"
                  ),
                  React.createElement(
                    "button",
                    {
                      key: "clear",
                      type: "button",
                      style: styles.libraryButton,
                      onClick: () => onClearProgress(art.id),
                    },
                    "Clear progress"
                  ),
                  React.createElement(
                    "button",
                    {
                      key: "delete",
                      type: "button",
                      style: styles.libraryDangerButton,
                      onClick: () => onDelete(art.id),
                    },
                    "Delete"
                  ),
                ]
          )
        );
      })
    : React.createElement("div", { style: styles.libraryEmpty }, "No artworks saved yet.");

  return React.createElement(
    "div",
    { style: styles.libraryOverlay, onClick: onClose },
    React.createElement(
      "aside",
      {
        style: styles.libraryPanel,
        role: "dialog",
        "aria-modal": true,
        "aria-label": "Artwork library",
        onClick: (e) => e.stopPropagation(),
      },
      React.createElement(
        "div",
        { style: styles.libraryHeader },
        React.createElement("div", { style: styles.libraryTitle }, "Art Library"),
        React.createElement(
          "button",
          { style: styles.libraryClose, onClick: onClose, "aria-label": "Close art library" },
          "\u2715"
        )
      ),
      React.createElement("div", { style: styles.libraryList }, list),
      React.createElement(
        "section",
        { style: styles.libraryPromptSection },
        React.createElement("h3", { style: styles.libraryPromptTitle }, "ChatGPT prompt"),
        React.createElement(
          "p",
          { style: styles.libraryPromptBody },
          "Use this prompt with ChatGPT to produce a new color-by-number JSON file."
        ),
        React.createElement(
          "div",
          { style: styles.libraryPromptActions },
          React.createElement(
            "button",
            { type: "button", style: styles.libraryPrimaryButton, onClick: handleCopyPrompt },
            "Copy prompt"
          ),
          promptStatus &&
            React.createElement(
              "span",
              {
                style: {
                  ...styles.libraryPromptStatus,
                  color: promptStatus.type === "error" ? "#f87171" : "#22c55e",
                },
              },
              promptStatus.message
            )
        ),
        React.createElement(
          "pre",
          { style: styles.libraryPromptPre },
          promptText
        )
      ),
      React.createElement(
        "form",
        { style: styles.libraryImport, onSubmit: handleImportSubmit },
        React.createElement("label", { style: styles.libraryLabel }, "Import artwork JSON"),
        React.createElement("textarea", {
          style: styles.libraryTextarea,
          value: draft,
          onChange: (e) => setDraft(e.target.value),
          placeholder: "{ \"id\": \"my-art\", ... }",
          rows: 6,
        }),
        React.createElement(
          "div",
          { style: styles.libraryImportActions },
          React.createElement(
            "button",
            { type: "submit", style: styles.libraryPrimaryButton },
            "Add artwork"
          ),
          React.createElement(
            "button",
            {
              type: "button",
              style: styles.libraryButton,
              onClick: () => {
                setDraft("");
                setFeedback(null);
              },
            },
            "Clear"
          )
        ),
        feedback &&
          React.createElement(
            "div",
            {
              style: {
                ...styles.libraryFeedback,
                color: feedback.type === "error" ? "#f87171" : "#22c55e",
              },
            },
            feedback.message
          )
      )
    )
  );
}

function OptionsPanel({ config, onToggle, canReset, onReset, onClose }) {
  const options = [
    {
      key: "enableAutosave",
      label: "Autosave progress",
      description: "Persist the fill state and viewport to localStorage after each change.",
    },
    {
      key: "autoAdvanceOnComplete",
      label: "Auto-advance color",
      description: "Jump to the next color when the active color has no unfilled cells remaining.",
    },
    {
      key: "enableHintPulse",
      label: "Hint pulses",
      description: "Allow the Hint control to highlight the smallest unfilled cells in the active color.",
    },
    {
      key: "enableDragFill",
      label: "Drag-to-fill",
      description: "While painting, drag across adjacent cells to fill them without additional taps.",
    },
    {
      key: "enableEyedropper",
      label: "Eyedropper",
      description: "Tap a filled cell without moving to reselect its color.",
    },
    {
      key: "enableKeyboardShortcuts",
      label: "Keyboard shortcuts",
      description: "Use H, N, U, T, +/-, and 0 to control hints, color cycling, undo, tests, zoom, and fitting.",
    },
    {
      key: "showNumberBadges",
      label: "Number badges",
      description: "Show numbered overlays for unfilled cells when zoomed in.",
    },
    {
      key: "showHeatmapDots",
      label: "Heat-map dots",
      description: "Show locator dots for tiny cells when zoomed out.",
    },
    {
      key: "enableSmokeHud",
      label: "Smoke-test HUD",
      description: "Allow the debugging overlay that summarizes automated checks.",
    },
  ];

  const surfaces = [
    {
      title: "Root layout",
      body: "Dark-mode experience with a full-viewport canvas and floating header/footer controls.",
    },
    {
      title: "Header bar",
      body: "Back affordance, artwork title, progress text, and utility buttons for fit, undo, hint, next color, tests, and options.",
    },
    {
      title: "Canvas frame",
      body: "Fullscreen SVG stage with pan/zoom transforms, strokes, badges, and heat-map dots as you zoom.",
    },
    {
      title: "Smoke Tests HUD",
      body: "Optional floating card that reports automated sanity checks and can be hidden with the toolbar or T shortcut.",
    },
    {
      title: "Palette footer",
      body: "Scrollable row of numbered swatches with remaining counts, highlighting the active color and disabling completed ones.",
    },
  ];

  return React.createElement(
    "div",
    { style: styles.optionsOverlay, onClick: onClose },
    React.createElement(
      "aside",
      {
        style: styles.optionsCard,
        role: "dialog",
        "aria-modal": true,
        "aria-label": "Options and configuration",
        onClick: (e) => e.stopPropagation(),
      },
      React.createElement(
        "div",
        { style: styles.optionsHeader },
        React.createElement("div", { style: styles.optionsTitle }, "Options"),
        React.createElement(
          "button",
          { style: styles.optionsClose, onClick: onClose, "aria-label": "Close options" },
          "\u2715"
        )
      ),
      React.createElement(
        "p",
        { style: styles.optionsAbout },
        "The project is a single-page React 18 color-by-number demo that boots entirely from index.html, pulling React, ReactDOM, and Babel from CDNs so the JSX logic can run in the browser without a build step. It loads a predefined \u201CLow\u2011poly Fox\u201D artwork composed of numbered SVG paths and a corresponding palette, then tracks each cell\u2019s fill state so users can paint the illustration by matching colors to numbers."
      ),
      React.createElement("div", { style: styles.optionsSectionTitle }, "UI surfaces"),
      React.createElement(
        "ul",
        { style: styles.optionsUiList },
        surfaces.map((s) =>
          React.createElement(
            "li",
            { key: s.title },
            React.createElement("strong", null, s.title, ": "),
            s.body
          )
        )
      ),
      React.createElement("div", { style: styles.optionsSectionTitle }, "Configuration"),
      React.createElement(
        "div",
        { style: styles.optionsList },
        options.map((opt) =>
          React.createElement(
            "label",
            { key: opt.key, style: styles.optionRow },
            React.createElement("input", {
              type: "checkbox",
              checked: !!config[opt.key],
              onChange: (e) => onToggle(opt.key, e.target.checked),
              style: styles.optionCheckbox,
            }),
            React.createElement(
              "div",
              null,
              React.createElement("div", { style: styles.optionLabel }, opt.label),
              React.createElement("div", { style: styles.optionDescription }, opt.description)
            )
          )
        )
      ),
      React.createElement("div", { style: styles.optionsSectionTitle }, "Current values"),
      React.createElement(
        "pre",
        { style: styles.optionsConfigPre },
        JSON.stringify(config, null, 2)
      ),
      React.createElement(
        "div",
        { style: styles.optionsFooter },
        React.createElement(
          "button",
          {
            style: {
              ...styles.optionsReset,
              opacity: canReset ? 1 : 0.5,
              cursor: canReset ? "pointer" : "not-allowed",
            },
            type: "button",
            onClick: canReset ? onReset : undefined,
            disabled: !canReset,
          },
          "Reset to defaults"
        )
      )
    )
  );
}

// ---------- Smoke Tests HUD ----------
function SmokeTests({ art, filled }) {
  const results = useMemo(() => runSmokeTests(art, filled), [art, filled]);
  const allPass = results.every((r) => r.pass);
  return React.createElement(
    "div",
    {
      style: {
        position: "absolute",
        left: 16,
        bottom: 180,
        background: allPass ? "rgba(34, 197, 94, 0.12)" : "rgba(248, 113, 113, 0.12)",
        border: `1px solid ${allPass ? "#22c55e" : "#f87171"}`,
        borderRadius: 12,
        padding: 12,
        boxShadow: "0 12px 40px rgba(15, 23, 42, 0.35)",
        maxWidth: 360,
        fontSize: 12,
        backdropFilter: "blur(12px)",
      },
    },
    React.createElement(
      "div",
      { style: { fontWeight: 700, marginBottom: 8 } },
      allPass ? "Smoke tests passed" : "Smoke tests failed"
    ),
    React.createElement(
      "ul",
      { style: { margin: 0, paddingLeft: 18 } },
      results.map((r) =>
        React.createElement(
          "li",
          { key: r.name, style: { color: r.pass ? "#4ade80" : "#fca5a5" } },
          `${r.pass ? "✔" : "✖"} ${r.name}${r.msg ? ` – ${r.msg}` : ""}`
        )
      )
    ),
    React.createElement(
      "div",
      { style: { marginTop: 8, color: "#94a3b8" } },
      "Press T to hide/show."
    )
  );
}

function runSmokeTests(art, filled) {
  const tests = [];
  const rem = computeRemaining(art, filled);
  const sum = Object.values(rem).reduce((a, b) => a + b, 0);
  const expected = art.cells.filter((c) => !filled[c.id]).length;
  tests.push({ name: "Remaining matches unfilled count", pass: sum === expected, msg: `${sum}/${expected}` });
  const c0 = art.cells[0];
  const { x, y } = centroidFromPath(c0.d);
  tests.push({ name: "Centroid in bounds", pass: x >= 0 && y >= 0 && x <= art.width && y <= art.height });
  const ids = new Set(art.palette.map((p) => p.id));
  tests.push({ name: "Palette IDs unique", pass: ids.size === art.palette.length });
  return tests;
}

// ---------- Styles ----------
const styles = {
  app: {
    minHeight: "100vh",
    position: "relative",
    fontFamily: "'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui",
    color: "#f8fafc",
    background: "radial-gradient(circle at top, rgba(56, 189, 248, 0.05), rgba(15, 23, 42, 0.9))",
  },
  header: {
    display: "grid",
    gridTemplateColumns: "56px 1fr auto",
    alignItems: "center",
    padding: "0 20px",
    borderBottom: "1px solid rgba(148, 163, 184, 0.2)",
    background: "rgba(2, 6, 23, 0.7)",
    backdropFilter: "blur(12px)",
    position: "fixed",
    top: 0,
    left: 0,
    right: 0,
    zIndex: 30,
    boxShadow: "0 12px 32px rgba(2, 6, 23, 0.55)",
  },
  back: {
    width: 44,
    height: 44,
    borderRadius: 14,
    border: "1px solid rgba(148, 163, 184, 0.3)",
    background: "rgba(15, 23, 42, 0.8)",
    color: "#e2e8f0",
    cursor: "pointer",
  },
  headerRight: {
    display: "flex",
    alignItems: "center",
  },
  iconBtn: {
    width: 44,
    height: 44,
    borderRadius: 14,
    border: "1px solid rgba(148, 163, 184, 0.3)",
    background: "rgba(15, 23, 42, 0.8)",
    color: "#e2e8f0",
    cursor: "pointer",
    marginLeft: 10,
    display: "grid",
    placeItems: "center",
  },
  main: {
    position: "relative",
    display: "grid",
    placeItems: "center",
    padding: "96px 24px 168px",
    minHeight: "100vh",
    width: "100%",
  },
  artframe: {
    width: "min(96vw, 1100px)",
    height: "max(320px, calc(100vh - 264px))",
    background: "rgba(15, 23, 42, 0.85)",
    border: "1px solid rgba(148, 163, 184, 0.15)",
    borderRadius: 24,
    overflow: "hidden",
    boxShadow: "0 18px 50px rgba(2, 6, 23, 0.55)",
  },
  footer: {
    borderTop: "1px solid rgba(148, 163, 184, 0.2)",
    background: "rgba(2, 6, 23, 0.7)",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    padding: "18px 24px",
    backdropFilter: "blur(12px)",
    position: "fixed",
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 30,
    boxShadow: "0 -12px 32px rgba(2, 6, 23, 0.55)",
  },
  emptyArtState: {
    width: "min(96vw, 1100px)",
    minHeight: "max(320px, calc(100vh - 264px))",
    borderRadius: 24,
    border: "1px dashed rgba(148, 163, 184, 0.35)",
    display: "grid",
    placeItems: "center",
    textAlign: "center",
    color: "#94a3b8",
    background: "rgba(15, 23, 42, 0.6)",
    padding: "32px",
  },
  footerEmpty: {
    color: "#94a3b8",
    fontSize: 14,
  },
  libraryOverlay: {
    position: "fixed",
    inset: 0,
    background: "rgba(2, 6, 23, 0.7)",
    backdropFilter: "blur(12px)",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    padding: "24px",
    zIndex: 60,
  },
  libraryPanel: {
    width: "min(560px, 100%)",
    maxHeight: "calc(100vh - 48px)",
    overflowY: "auto",
    background: "rgba(15, 23, 42, 0.96)",
    borderRadius: 24,
    padding: 24,
    boxShadow: "0 24px 60px rgba(2, 6, 23, 0.7)",
    border: "1px solid rgba(148, 163, 184, 0.3)",
    color: "#e2e8f0",
    display: "grid",
    gap: 20,
  },
  libraryHeader: {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
  },
  libraryTitle: {
    fontSize: 20,
    fontWeight: 700,
  },
  libraryClose: {
    width: 36,
    height: 36,
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.8)",
    color: "#cbd5f5",
    cursor: "pointer",
  },
  libraryList: {
    display: "grid",
    gap: 12,
  },
  libraryItem: {
    border: "1px solid rgba(148, 163, 184, 0.2)",
    borderRadius: 16,
    padding: 16,
    background: "rgba(15, 23, 42, 0.7)",
    display: "grid",
    gap: 12,
  },
  libraryItemActive: {
    borderColor: "rgba(56, 189, 248, 0.6)",
    boxShadow: "0 0 0 1px rgba(56, 189, 248, 0.4)",
  },
  libraryItemHeader: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
  },
  libraryItemTitle: {
    fontWeight: 600,
    fontSize: 16,
  },
  libraryTitleInput: {
    width: "100%",
    padding: "6px 10px",
    borderRadius: 10,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.85)",
    color: "#e2e8f0",
  },
  libraryBadge: {
    padding: "4px 10px",
    borderRadius: 999,
    fontSize: 12,
    background: "rgba(148, 163, 184, 0.2)",
    color: "#cbd5f5",
  },
  libraryBadgeActive: {
    background: "rgba(56, 189, 248, 0.2)",
    color: "#38bdf8",
  },
  libraryMeta: {
    fontSize: 13,
    color: "#94a3b8",
  },
  libraryButtons: {
    display: "flex",
    flexWrap: "wrap",
    gap: 8,
  },
  libraryButton: {
    padding: "8px 12px",
    borderRadius: 10,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(30, 41, 59, 0.6)",
    color: "#cbd5f5",
    cursor: "pointer",
  },
  libraryPrimaryButton: {
    padding: "8px 12px",
    borderRadius: 10,
    border: "1px solid rgba(56, 189, 248, 0.5)",
    background: "rgba(56, 189, 248, 0.2)",
    color: "#38bdf8",
    cursor: "pointer",
  },
  libraryDangerButton: {
    padding: "8px 12px",
    borderRadius: 10,
    border: "1px solid rgba(248, 113, 113, 0.5)",
    background: "rgba(248, 113, 113, 0.15)",
    color: "#fca5a5",
    cursor: "pointer",
  },
  libraryEmpty: {
    padding: 16,
    textAlign: "center",
    color: "#94a3b8",
    border: "1px dashed rgba(148, 163, 184, 0.3)",
    borderRadius: 16,
  },
  libraryPromptSection: {
    border: "1px solid rgba(148, 163, 184, 0.25)",
    borderRadius: 16,
    padding: 16,
    background: "rgba(15, 23, 42, 0.7)",
    display: "grid",
    gap: 12,
  },
  libraryPromptTitle: {
    margin: 0,
    fontSize: 15,
    fontWeight: 600,
  },
  libraryPromptBody: {
    margin: 0,
    fontSize: 13,
    color: "#94a3b8",
  },
  libraryPromptActions: {
    display: "flex",
    alignItems: "center",
    gap: 12,
  },
  libraryPromptStatus: {
    fontSize: 12,
  },
  libraryPromptPre: {
    margin: 0,
    padding: 12,
    background: "rgba(15, 23, 42, 0.85)",
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.2)",
    fontSize: 12,
    color: "#cbd5f5",
    overflowX: "auto",
    whiteSpace: "pre-wrap",
    fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
  },
  libraryImport: {
    display: "grid",
    gap: 12,
  },
  libraryLabel: {
    fontSize: 13,
    fontWeight: 600,
    color: "#cbd5f5",
  },
  libraryTextarea: {
    width: "100%",
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.8)",
    color: "#e2e8f0",
    padding: 12,
    fontSize: 13,
    fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
  },
  libraryImportActions: {
    display: "flex",
    gap: 12,
    flexWrap: "wrap",
  },
  libraryFeedback: {
    fontSize: 12,
  },
  paletteWrap: {
    display: "flex",
    gap: 16,
    padding: "0 12px",
    overflowX: "auto",
    width: "100%",
    maxWidth: 960,
  },
  swatch: {
    minWidth: 120,
    height: 72,
    borderRadius: 20,
    border: "1px solid transparent",
    display: "flex",
    alignItems: "center",
    justifyContent: "flex-start",
    gap: 14,
    padding: "0 16px",
    background: "rgba(15, 23, 42, 0.8)",
    color: "#cbd5f5",
    cursor: "pointer",
  },
  swatchChip: {
    width: 48,
    height: 48,
    borderRadius: "50%",
    display: "grid",
    placeItems: "center",
    boxShadow: "0 0 0 2px rgba(15, 23, 42, 0.6)",
  },
  swatchNumber: {
    fontWeight: 700,
    color: "#020617",
  },
  swatchMeta: {
    display: "grid",
    gap: 2,
    fontSize: 12,
  },
  swatchCountLabel: {
    textTransform: "uppercase",
    letterSpacing: 1,
    color: "#64748b",
    fontSize: 10,
  },
  swatchCount: {
    fontSize: 18,
    fontWeight: 700,
    color: "#e2e8f0",
  },
  optionsOverlay: {
    position: "fixed",
    inset: 0,
    background: "rgba(2, 6, 23, 0.6)",
    backdropFilter: "blur(8px)",
    display: "flex",
    justifyContent: "flex-end",
    alignItems: "center",
    padding: "24px 32px",
    zIndex: 50,
  },
  optionsCard: {
    width: "min(420px, 100%)",
    maxHeight: "calc(100vh - 48px)",
    overflowY: "auto",
    background: "rgba(15, 23, 42, 0.96)",
    borderRadius: 24,
    padding: 24,
    boxShadow: "0 24px 60px rgba(2, 6, 23, 0.65)",
    border: "1px solid rgba(148, 163, 184, 0.25)",
    color: "#e2e8f0",
  },
  optionsHeader: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 12,
  },
  optionsTitle: {
    fontSize: 20,
    fontWeight: 700,
  },
  optionsClose: {
    width: 32,
    height: 32,
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(15, 23, 42, 0.8)",
    color: "#cbd5f5",
    cursor: "pointer",
  },
  optionsAbout: {
    fontSize: 13,
    lineHeight: 1.6,
    color: "#cbd5f5",
    marginTop: 0,
    marginBottom: 16,
  },
  optionsSectionTitle: {
    fontSize: 11,
    textTransform: "uppercase",
    letterSpacing: 1,
    color: "#64748b",
    margin: "20px 0 10px",
  },
  optionsUiList: {
    margin: 0,
    paddingLeft: 18,
    display: "grid",
    gap: 8,
    fontSize: 13,
    color: "#d0def5",
  },
  optionsList: {
    display: "grid",
    gap: 12,
  },
  optionRow: {
    display: "grid",
    gridTemplateColumns: "auto 1fr",
    gap: 12,
    alignItems: "start",
    background: "rgba(15, 23, 42, 0.7)",
    padding: 12,
    borderRadius: 16,
    border: "1px solid rgba(148, 163, 184, 0.15)",
  },
  optionCheckbox: {
    width: 18,
    height: 18,
    marginTop: 4,
  },
  optionLabel: {
    fontWeight: 600,
    color: "#e2e8f0",
  },
  optionDescription: {
    fontSize: 12,
    color: "#94a3b8",
    marginTop: 4,
  },
  optionsConfigPre: {
    margin: 0,
    padding: 12,
    background: "rgba(15, 23, 42, 0.7)",
    borderRadius: 16,
    border: "1px solid rgba(148, 163, 184, 0.15)",
    fontSize: 12,
    color: "#f8fafc",
    overflowX: "auto",
  },
  optionsFooter: {
    marginTop: 16,
    display: "flex",
    justifyContent: "flex-end",
  },
  optionsReset: {
    borderRadius: 12,
    border: "1px solid rgba(148, 163, 184, 0.35)",
    background: "rgba(51, 65, 85, 0.4)",
    color: "#e2e8f0",
    padding: "10px 16px",
    cursor: "pointer",
    fontWeight: 600,
  },
};

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(React.createElement(App));
    </script>
  </body>
</html>

