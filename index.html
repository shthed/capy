<!DOCTYPE html>
<html lang="en">
  <!--
    Developer Map
    ==========
    - UI chrome (header/footer modals): command rail + sheets define primary controls and expose
      buttons that wire into the handler helpers inside the script. Look for "Command button"
      listeners when adjusting layout interactions.
    - Viewport + stage: #viewport, #canvasStage, and #canvasTransform cooperate with the
      viewState structure. applyViewTransform, applyZoom, resetView, and the pointer handlers are
      the touch/mouse entry points for navigation. Pointerdown/up/move feed handlePan* while
      wheel/key events route through applyZoom.
    - Puzzle state + rendering: the state object captures palette, regions, fill progress, and
      metadata. Rendering flows through renderPuzzle ‚Üí drawOutlines/drawNumbers with helpers like
      applyRegionToImage.
    - Generation pipeline: loadImage ‚Üí createPuzzleData orchestrates quantization (kmeansQuantize),
      segmentation (segmentRegions), and palette prep. Regeneration, fixture loading, and saves all
      call applyPuzzleResult to hydrate UI.
    - Persistence + exports: local storage helpers (persistSaves/loadSavedEntries) back the save
      sheet. serializeCurrentPuzzle produces an export-safe object.
    - External API: window.capyGenerator exposes entry points that manual test harnesses
      rely on. Keep it stable whenever you shuffle internal wiring.
  -->
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <title>Image to Color-by-Number</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: "Inter", "Segoe UI", -apple-system, BlinkMacSystemFont, system-ui,
          sans-serif;
        background: #020617;
        color: #e2e8f0;
        --ui-scale-user: 1;
        --ui-scale-auto: 1;
        --ui-scale: calc(var(--ui-scale-user, 1) * var(--ui-scale-auto, 1));
        --app-width: 100vw;
        --app-height: 100vh;
        --viewport-padding: calc(32px * var(--ui-scale));
        --rail-gap: calc(8px * var(--ui-scale));
        --rail-gap-portrait: calc(6px * var(--ui-scale));
        --rail-padding-block: calc(12px * var(--ui-scale));
        --rail-padding-inline: calc(24px * var(--ui-scale));
        --command-button-size: clamp(
          calc(32px * var(--ui-scale)),
          calc(40px * var(--ui-scale)),
          calc(48px * var(--ui-scale))
        );
        --command-button-size-portrait: clamp(
          calc(30px * var(--ui-scale)),
          calc(36px * var(--ui-scale)),
          calc(44px * var(--ui-scale))
        );
      }

      * {
        box-sizing: border-box;
      }

      html {
        touch-action: manipulation;
      }

      body {
        margin: 0;
        min-height: 100vh;
        min-height: 100dvh;
        background: radial-gradient(circle at top, rgba(59, 130, 246, 0.22), transparent),
          #020617;
        color: inherit;
        overflow: hidden;
        font-size: calc(16px * var(--ui-scale));
        touch-action: manipulation;
        overscroll-behavior: none;
      }

      body.sheet-open {
        overflow: hidden;
      }

      body.dragging {
        cursor: copy;
      }

      body.panning {
        cursor: grabbing;
      }

      #app {
        position: relative;
        width: min(var(--app-width, 100vw), 100vw);
        height: min(var(--app-height, 100vh), 100vh);
        overflow: hidden;
        display: grid;
        grid-template-rows: auto 1fr auto;
      }

      @supports (height: 100dvh) {
        #app {
          height: min(var(--app-height, 100dvh), 100dvh);
        }
      }

      #commandRail {
        position: sticky;
        top: 0;
        left: 0;
        right: 0;
        display: flex;
        justify-content: flex-end;
        align-items: center;
        flex-wrap: wrap;
        gap: var(--rail-gap);
        padding: var(--rail-padding-block) var(--rail-padding-inline);
        padding-block-start:
          calc(var(--rail-padding-block) + env(safe-area-inset-top, 0px));
        padding-block-end:
          calc(var(--rail-padding-block) + env(safe-area-inset-bottom, 0px));
        padding-inline-start:
          calc(var(--rail-padding-inline) + env(safe-area-inset-left, 0px));
        padding-inline-end:
          calc(var(--rail-padding-inline) + env(safe-area-inset-right, 0px));
        background: linear-gradient(180deg, rgba(2, 6, 23, 0.96), rgba(2, 6, 23, 0.82));
        z-index: 3;
        touch-action: manipulation;
        width: 100%;
      }

      #commandRail button {
        border-radius: 12px;
        padding: 0;
        width: var(--command-button-size);
        height: var(--command-button-size);
        display: grid;
        place-items: center;
        background: rgba(15, 23, 42, 0.82);
        color: rgba(226, 232, 240, 0.92);
        border: 1px solid rgba(148, 163, 184, 0.28);
      }

      #commandRail button.active {
        background: rgba(37, 99, 235, 0.28);
        border-color: rgba(96, 165, 250, 0.55);
        color: rgba(226, 232, 240, 1);
      }

      #commandRail button .icon {
        font-size: 1.1rem;
        line-height: 1;
      }

      #commandRail button:disabled {
        background: rgba(15, 23, 42, 0.55);
        color: rgba(148, 163, 184, 0.6);
        border-color: rgba(71, 85, 105, 0.35);
      }

      body[data-orientation="portrait"] #commandRail {
        gap: var(--rail-gap-portrait);
        padding: var(--rail-padding-block) calc(16px * var(--ui-scale));
        justify-content: center;
        width: 100%;
      }

      body[data-orientation="portrait"] #commandRail button {
        width: var(--command-button-size-portrait);
        height: var(--command-button-size-portrait);
      }

      body.compact-commands #commandRail {
        justify-content: center;
        gap: var(--rail-gap-portrait);
        padding-inline: calc(16px * var(--ui-scale));
      }

      body.compact-commands #commandRail button {
        width: min(var(--command-button-size), calc(14vw));
        height: min(var(--command-button-size), calc(14vw));
      }

      body[data-orientation="portrait"] #paletteDock {
        flex-direction: column;
        align-items: stretch;
        gap: 12px;
      }

      #viewport {
        position: relative;
        width: 100%;
        height: 100%;
        display: grid;
        place-items: center;
        padding: var(--viewport-padding, 32px);
        overflow: hidden;
      }

      #canvasStage {
        position: absolute;
        top: 50%;
        left: 50%;
        --pan-x: 0px;
        --pan-y: 0px;
        transform: translate(calc(-50% + var(--pan-x)), calc(-50% + var(--pan-y)));
        display: flex;
        align-items: center;
        justify-content: center;
        touch-action: none;
        will-change: transform;
        z-index: 1;
        cursor: grab;
      }

      body.custom-cursor:not(.panning) #canvasStage {
        cursor: none;
      }

      #pointerOverlay {
        --cursor-x: -9999px;
        --cursor-y: -9999px;
        --cursor-ring: rgba(226, 232, 240, 0.95);
        --cursor-fill: rgba(15, 23, 42, 0.55);
        --cursor-swatch: transparent;
        position: fixed;
        top: 0;
        left: 0;
        z-index: 6;
        pointer-events: none;
        transform: translate3d(var(--cursor-x), var(--cursor-y), 0);
        opacity: 0;
        transition: opacity 0.12s ease;
      }

      #pointerOverlay.active {
        opacity: 1;
      }

      body:not(.custom-cursor) #pointerOverlay {
        opacity: 0;
      }

      body.panning #pointerOverlay,
      body.sheet-open #pointerOverlay,
      body.dragging #pointerOverlay {
        opacity: 0;
      }

      #pointerOverlay .pointer-indicator {
        width: calc(20px * var(--ui-scale));
        height: calc(20px * var(--ui-scale));
        border-radius: 50%;
        border: 2px solid var(--cursor-ring);
        background: var(--cursor-fill);
        box-shadow: 0 6px 14px rgba(2, 6, 23, 0.45), 0 0 0 1px rgba(15, 23, 42, 0.6);
        transform: translate(-50%, -50%);
        backdrop-filter: blur(4px);
      }

      #pointerOverlay.matching .pointer-indicator {
        box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.42), 0 8px 18px rgba(2, 6, 23, 0.4);
      }

      #pointerOverlay.mismatch .pointer-indicator {
        box-shadow: 0 0 0 3px rgba(248, 113, 113, 0.45), 0 8px 18px rgba(2, 6, 23, 0.4);
      }

      #pointerOverlay.filled .pointer-indicator {
        box-shadow: 0 0 0 3px rgba(148, 163, 184, 0.35), 0 8px 18px rgba(2, 6, 23, 0.4);
      }

      #pointerOverlay .pointer-tooltip {
        display: inline-flex;
        align-items: center;
        gap: calc(6px * var(--ui-scale));
        min-width: 0;
        padding: calc(4px * var(--ui-scale)) calc(6px * var(--ui-scale));
        border-radius: calc(6px * var(--ui-scale));
        background: rgba(248, 250, 252, 0.95);
        border: 1px solid rgba(148, 163, 184, 0.35);
        box-shadow: 0 12px 24px rgba(2, 6, 23, 0.25);
        transform: translate(calc(-50% + 14px), calc(-50% + 20px));
        font-size: calc(14px * var(--ui-scale));
        line-height: 1;
      }

      #pointerOverlay.matching .pointer-tooltip {
        border-color: rgba(34, 197, 94, 0.55);
      }

      #pointerOverlay.mismatch .pointer-tooltip {
        border-color: rgba(248, 113, 113, 0.55);
      }

      #pointerOverlay.filled .pointer-tooltip {
        border-color: rgba(148, 163, 184, 0.5);
      }

      #pointerOverlay .pointer-number {
        font-weight: 600;
        letter-spacing: 0.02em;
        color: rgba(15, 23, 42, 0.88);
        text-shadow: 0 0 4px rgba(15, 23, 42, 0.35);
      }

      #pointerOverlay .pointer-swatch {
        width: calc(14px * var(--ui-scale));
        height: calc(14px * var(--ui-scale));
        border-radius: calc(4px * var(--ui-scale));
        border: 1px solid rgba(148, 163, 184, 0.7);
        background: var(--cursor-swatch);
        box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.4);
      }

      #canvasTransform {
        transform-origin: center;
        --zoom: 1;
        transform: scale(var(--zoom));
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #viewport::before {
        content: "";
        position: absolute;
        inset: 24px;
        border-radius: 24px;
        border: 2px dashed rgba(148, 163, 184, 0.35);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.18s ease;
      }

      body.dragging #viewport::before,
      body.panning #viewport::before {
        opacity: 1;
      }

      #puzzleCanvas {
        max-width: calc(100vw - 160px);
        max-height: calc(100vh - 220px);
        width: auto;
        height: auto;
        border-radius: 20px;
        background: #0f172a;
        border: 1px solid rgba(148, 163, 184, 0.45);
        box-shadow: 0 30px 60px rgba(15, 23, 42, 0.45);
        image-rendering: pixelated;
        touch-action: none;
      }

      #previewOverlay {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        background: rgba(2, 6, 23, 0.9);
        backdrop-filter: blur(16px);
        z-index: 4;
        transition: opacity 0.24s ease;
      }

      #previewOverlay.hidden {
        opacity: 0;
        pointer-events: none;
      }

      #previewOverlay canvas {
        width: min(100%, calc(100vh - 140px));
        height: auto;
        border-radius: calc(20px * var(--ui-scale));
        border: 1px solid rgba(148, 163, 184, 0.4);
        box-shadow: 0 32px 70px rgba(2, 6, 23, 0.65);
        image-rendering: pixelated;
      }

      #previewOverlay button {
        margin-top: calc(24px * var(--ui-scale));
      }

      #startHint {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        background: rgba(15, 23, 42, 0.82);
        backdrop-filter: blur(18px);
        transition: opacity 0.24s ease;
        z-index: 2;
      }

      #startHint.hidden {
        opacity: 0;
        pointer-events: none;
      }

      #startHint.hidden * {
        pointer-events: none !important;
      }

      #startHint .hint-body {
        pointer-events: auto;
        text-align: center;
        max-width: 360px;
        padding: calc(32px * var(--ui-scale));
        border-radius: calc(20px * var(--ui-scale));
        background: rgba(2, 6, 23, 0.78);
        border: 1px solid rgba(59, 130, 246, 0.35);
        box-shadow: 0 20px 60px rgba(15, 23, 42, 0.6);
        display: grid;
        gap: calc(20px * var(--ui-scale));
        justify-items: center;
      }

      #startHint h1 {
        margin: 0 0 12px;
        font-size: clamp(1.8rem, 3vw + 0.5rem, 2.6rem);
      }

      #startHint p {
        margin: 0 0 20px;
        color: rgba(226, 232, 240, 0.8);
        font-size: 1rem;
      }

      #startHint .sample-art {
        width: min(calc(240px * var(--ui-scale)), 70vw);
        max-width: 100%;
        border-radius: calc(16px * var(--ui-scale));
        box-shadow: 0 16px 40px rgba(15, 23, 42, 0.55);
        border: 1px solid rgba(148, 163, 184, 0.25);
      }

      #startHint .hint-actions {
        display: grid;
        gap: calc(12px * var(--ui-scale));
        width: 100%;
      }

        .detail-callout {
          display: grid;
          gap: calc(12px * var(--ui-scale));
          width: 100%;
          text-align: center;
        }

        .detail-intro {
          margin: 0;
          font-size: 0.95rem;
          color: rgba(226, 232, 240, 0.82);
        }

        .detail-picker {
          display: flex;
          justify-content: center;
          gap: calc(8px * var(--ui-scale));
          flex-wrap: wrap;
        }

        button.detail-chip {
          padding: 6px 16px;
          border-radius: 999px;
          border: 1px solid rgba(148, 163, 184, 0.35);
          background: rgba(15, 23, 42, 0.65);
          color: rgba(226, 232, 240, 0.85);
          font-weight: 600;
          font-size: 0.85rem;
          letter-spacing: 0.01em;
          box-shadow: none;
        }

        button.detail-chip:hover:not(:disabled) {
          transform: none;
          box-shadow: none;
          background: rgba(37, 99, 235, 0.25);
          color: rgba(226, 232, 240, 0.95);
        }

        button.detail-chip[aria-pressed="true"] {
          background: rgba(59, 130, 246, 0.35);
          border-color: rgba(147, 197, 253, 0.6);
          color: rgba(226, 232, 240, 0.98);
        }

        .detail-caption {
          margin: 0;
          font-size: 0.85rem;
          color: rgba(148, 163, 184, 0.85);
        }

        #settingsSheet .detail-callout {
          text-align: left;
        }

        #settingsSheet .detail-picker {
          justify-content: flex-start;
        }
      button {
        font: inherit;
        border-radius: 999px;
        border: none;
        padding: calc(10px * var(--ui-scale)) calc(22px * var(--ui-scale));
        background: rgba(96, 165, 250, 0.92);
        color: #021027;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
      }

      button:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(37, 99, 235, 0.35);
        background: rgba(147, 197, 253, 0.96);
      }

      button:disabled {
        background: rgba(148, 163, 184, 0.35);
        color: rgba(226, 232, 240, 0.7);
        cursor: not-allowed;
        box-shadow: none;
      }

      #paletteDock {
        position: sticky;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        padding:
          calc(12px * var(--ui-scale))
          calc(20px * var(--ui-scale))
          calc(16px * var(--ui-scale));
        background: linear-gradient(182deg, rgba(2, 6, 23, 0.05) 0%, rgba(2, 6, 23, 0.9) 55%, rgba(2, 6, 23, 0.96) 100%);
        border-top: 1px solid rgba(30, 41, 59, 0.58);
        box-shadow: inset 0 1px 0 rgba(148, 163, 184, 0.08);
        flex-wrap: nowrap;
        overflow-x: auto;
        overflow-y: hidden;
        scrollbar-width: thin;
        -webkit-overflow-scrolling: touch;
        touch-action: pan-x;
        z-index: 3;
      }

      #paletteDock::-webkit-scrollbar {
        height: calc(6px * var(--ui-scale));
      }

      #paletteDock::-webkit-scrollbar-thumb {
        background: rgba(148, 163, 184, 0.4);
        border-radius: 999px;
      }

      #palette {
        flex: 1 1 auto;
        min-width: 0;
        display: flex;
        gap: calc(8px * var(--ui-scale));
        padding: calc(2px * var(--ui-scale)) 0;
      }

      .control {
        display: flex;
        flex-direction: column;
        gap: calc(6px * var(--ui-scale));
        font-size: 0.95rem;
      }

      .control > span {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
      }

      .control output {
        font-size: 0.85rem;
        color: rgba(148, 163, 184, 0.9);
      }

      details.advanced-options {
        margin-top: calc(16px * var(--ui-scale));
        padding: calc(12px * var(--ui-scale));
        border-radius: calc(12px * var(--ui-scale));
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.45);
      }

      details.advanced-options[open] {
        background: rgba(15, 23, 42, 0.6);
      }

      details.advanced-options summary {
        list-style: none;
        cursor: pointer;
        font-weight: 600;
        margin-bottom: calc(8px * var(--ui-scale));
        display: flex;
        align-items: center;
        gap: calc(6px * var(--ui-scale));
      }

      details.advanced-options summary::after {
        content: "‚ñæ";
        font-size: 0.85rem;
        opacity: 0.7;
        transform: rotate(0deg);
        transition: transform 0.2s ease;
      }

      details.advanced-options[open] summary::after {
        transform: rotate(180deg);
      }

      #artPrompt {
        width: 100%;
        min-height: calc(120px * var(--ui-scale));
        padding: calc(10px * var(--ui-scale));
        border-radius: calc(12px * var(--ui-scale));
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(15, 23, 42, 0.85);
        color: inherit;
        font: inherit;
        resize: vertical;
      }

      #artPrompt:focus {
        outline: none;
        border-color: rgba(96, 165, 250, 0.7);
        box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.25);
      }

      #artPrompt::placeholder {
        color: rgba(148, 163, 184, 0.7);
      }

      input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        height: 6px;
        border-radius: 999px;
        background: rgba(51, 65, 85, 0.9);
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: rgba(96, 165, 250, 0.95);
        border: none;
        box-shadow: 0 2px 6px rgba(37, 99, 235, 0.4);
        cursor: pointer;
      }

      input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: rgba(96, 165, 250, 0.95);
        border: none;
        box-shadow: 0 2px 6px rgba(37, 99, 235, 0.4);
        cursor: pointer;
      }

      input[type="color"] {
        width: 100%;
        height: 38px;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(15, 23, 42, 0.85);
        padding: 0;
        cursor: pointer;
      }

      input[type="color"]::-webkit-color-swatch,
      input[type="color"]::-moz-color-swatch {
        border: none;
        border-radius: 10px;
      }

      .control-note {
        margin-top: -8px;
        font-size: 0.8rem;
        color: rgba(148, 163, 184, 0.8);
      }

      .panel-actions {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
      }

      .panel-actions button {
        border-radius: 12px;
      }

      #downloadJson {
        width: 100%;
        border-radius: 12px;
        padding: 10px 0;
      }

      #previewCanvas {
        width: 100%;
        height: auto;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.3);
        background: rgba(15, 23, 42, 0.8);
        image-rendering: pixelated;
      }

      .swatch {
        flex: 0 0 auto;
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: calc(4px * var(--ui-scale));
        padding: calc(8px * var(--ui-scale)) calc(10px * var(--ui-scale));
        min-width: calc(60px * var(--ui-scale));
        min-height: calc(64px * var(--ui-scale));
        border-radius: calc(16px * var(--ui-scale));
        border: 1px solid rgba(148, 163, 184, 0.16);
        background:
          linear-gradient(176deg, rgba(15, 23, 42, 0.82), rgba(15, 23, 42, 0.7));
        color: var(--swatch-label-color, rgba(248, 250, 252, 0.98));
        text-align: center;
        cursor: pointer;
        transition: border-color 0.18s ease, box-shadow 0.18s ease, transform 0.18s ease;
        --flash-color: rgba(59, 130, 246, 0.65);
        --flash-border: rgba(96, 165, 250, 0.9);
        --swatch-label-border: rgba(30, 41, 59, 0.75);
        --swatch-label-shadow: 0 1px 1px rgba(2, 6, 23, 0.76);
        --swatch-label-text-shadow: 0 1px 1px rgba(2, 6, 23, 0.68);
      }

      .swatch::before {
        content: "";
        position: absolute;
        inset: calc(3px * var(--ui-scale));
        border-radius: calc(14px * var(--ui-scale));
        background:
          linear-gradient(140deg, rgba(15, 23, 42, 0.04), rgba(15, 23, 42, 0.22)),
          var(--swatch-color, transparent);
        opacity: 0.95;
        pointer-events: none;
      }

      .swatch:hover {
        transform: translateY(-1px);
      }

      .swatch.active {
        border-color: rgba(96, 165, 250, 0.85);
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
      }

      .swatch.done {
        opacity: 0.55;
      }

      .swatch.flash {
        animation: swatchHintPulse 0.48s ease;
      }

      @keyframes swatchHintPulse {
        0% {
          box-shadow: 0 0 0 0 var(--flash-color, rgba(59, 130, 246, 0.65));
          border-color: var(--flash-border, rgba(96, 165, 250, 0.9));
        }
        60% {
          box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
          border-color: rgba(148, 163, 184, 0.25);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
          border-color: rgba(148, 163, 184, 0.25);
        }
      }

      .swatch .label {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 0.85rem;
        line-height: 1.2;
        max-width: 100%;
        z-index: 1;
        padding: 0;
        color: inherit;
        text-shadow: var(--swatch-label-text-shadow, 0 1px 1px rgba(2, 6, 23, 0.7));
      }

      .swatch .label > strong {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: calc(32px * var(--ui-scale));
        padding: calc(1px * var(--ui-scale)) calc(8px * var(--ui-scale));
        border-radius: calc(9px * var(--ui-scale));
        border: 1px solid var(--swatch-label-border, rgba(30, 41, 59, 0.75));
        box-shadow: var(--swatch-label-shadow, 0 1px 1px rgba(2, 6, 23, 0.76));
        font-size: 1.12rem;
        letter-spacing: 0.015em;
        background: rgba(15, 23, 42, 0.08);
      }

      .sheet {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(420px, calc(100vw - 48px));
        max-height: calc(100vh - 96px);
        padding: 24px;
        display: flex;
        flex-direction: column;
        gap: 18px;
        border-radius: 22px;
        background: rgba(2, 6, 23, 0.95);
        border: 1px solid rgba(59, 130, 246, 0.4);
        box-shadow: 0 32px 80px rgba(8, 47, 73, 0.55);
        backdrop-filter: blur(26px);
        z-index: 6;
        opacity: 1;
        transition: opacity 0.2s ease;
      }

      .sheet.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .sheet-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
      }

      .sheet-header h2 {
        margin: 0;
        font-size: 1.25rem;
      }

      .close-button {
        padding: 6px 14px;
        border-radius: 12px;
        background: rgba(148, 163, 184, 0.15);
        color: rgba(226, 232, 240, 0.8);
        border: 1px solid rgba(148, 163, 184, 0.25);
      }

      .sheet-body {
        display: flex;
        flex-direction: column;
        gap: 22px;
        overflow-y: auto;
        padding-right: 4px;
      }

      .sheet-section {
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .sheet-section h3 {
        margin: 0;
        font-size: 1.05rem;
        letter-spacing: 0.02em;
      }

      .command-list {
        display: grid;
        grid-template-columns: minmax(0, auto) 1fr;
        gap: 6px 12px;
        margin: 0;
        padding: 0;
        list-style: none;
      }

      .command-list dt {
        font-weight: 600;
        color: rgba(148, 163, 184, 0.9);
        font-size: 0.95rem;
      }

      .command-list dd {
        margin: 0;
        font-size: 0.95rem;
      }

      .control-list {
        margin: 0;
        padding-left: 18px;
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 0.95rem;
        list-style: none;
      }

      .control-list kbd {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 1.4em;
        padding: 2px 6px;
        margin-right: 6px;
        border-radius: 6px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(15, 23, 42, 0.65);
        font-family: 'JetBrains Mono', 'SFMono-Regular', ui-monospace, SFMono-Regular, Menlo, Monaco,
          Consolas, 'Liberation Mono', 'Courier New', monospace;
        font-size: 0.85rem;
        color: rgba(226, 232, 240, 0.9);
      }

      .debug-log {
        border-radius: 16px;
        border: 1px solid rgba(59, 130, 246, 0.35);
        background: rgba(15, 23, 42, 0.85);
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-height: 240px;
        overflow-y: auto;
      }

      .debug-log .log-entry {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 4px 10px;
        align-items: baseline;
        font-size: 0.9rem;
      }

      .debug-log time {
        font-family: 'JetBrains Mono', 'SFMono-Regular', ui-monospace, SFMono-Regular, Menlo, Monaco,
          Consolas, 'Liberation Mono', 'Courier New', monospace;
        font-size: 0.8rem;
        color: rgba(148, 163, 184, 0.9);
      }

      .debug-log span {
        color: rgba(226, 232, 240, 0.95);
      }

      .log-empty {
        margin: 0;
        font-style: italic;
        color: rgba(148, 163, 184, 0.8);
      }

      .log-actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
      }

      .sheet-actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
      }

      .toggle {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 0.95rem;
      }

      .toggle input {
        width: 18px;
        height: 18px;
      }

      .backdrop {
        position: fixed;
        inset: 0;
        background: rgba(2, 6, 23, 0.65);
        backdrop-filter: blur(10px);
        z-index: 5;
        opacity: 1;
        transition: opacity 0.2s ease;
      }

      .backdrop.hidden {
        opacity: 0;
        pointer-events: none;
      }

      #saveList {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .save-entry {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 14px;
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.75);
        border: 1px solid rgba(59, 130, 246, 0.2);
      }

      .save-entry header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }

      .save-entry time {
        font-size: 0.8rem;
        color: rgba(148, 163, 184, 0.8);
      }

      .save-actions {
        display: flex;
        gap: 8px;
      }

      .save-actions button {
        flex: 1;
        border-radius: 10px;
        padding: 8px 12px;
      }

      @media (max-width: 1024px) {
        #puzzleCanvas {
          max-width: calc(100vw - 60px);
        }

        #commandRail {
          flex-wrap: wrap;
          justify-content: flex-end;
        }
      }

      @media (max-width: 720px) {
        #viewport {
          padding: 20px;
        }

        #puzzleCanvas {
          max-height: calc(100vh - 240px);
        }

        #paletteDock {
          flex-direction: column;
          align-items: stretch;
          gap: 12px;
        }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <header id="commandRail" aria-label="Game controls">
        <button
          id="hintButton"
          type="button"
          data-testid="hint-button"
          aria-label="Hint"
          title="Hint"
          disabled
        >
          <span class="icon" aria-hidden="true">?</span>
        </button>
        <button
          id="resetButton"
          type="button"
          data-testid="reset-button"
          aria-label="Reset puzzle"
          title="Reset puzzle"
          disabled
        >
          <span class="icon" aria-hidden="true">‚Ü∫</span>
        </button>
        <button
          id="previewToggle"
          type="button"
          data-testid="preview-toggle"
          aria-label="Show preview"
          title="Show preview"
          disabled
        >
          <span class="icon" aria-hidden="true">üñº</span>
        </button>
        <button
          id="sampleCommand"
          type="button"
          data-testid="sample-art-button"
          data-action="load-sample"
          aria-label="Reload sample puzzle"
          title="Reload sample puzzle"
        >
          <span class="icon" aria-hidden="true">üêπ</span>
        </button>
        <button
          id="fullscreenButton"
          type="button"
          data-testid="fullscreen-button"
          aria-label="Enter fullscreen"
          title="Enter fullscreen"
        >
          <span class="icon" aria-hidden="true">‚õ∂</span>
        </button>
        <button
          id="importButton"
          type="button"
          data-testid="import-button"
          aria-label="Import"
          title="Import"
        >
          <span class="icon" aria-hidden="true">‚¨Ü</span>
        </button>
        <button
          id="saveManagerButton"
          type="button"
          data-testid="save-manager-button"
          aria-label="Save manager"
          title="Save manager"
          disabled
        >
          <span class="icon" aria-hidden="true">üíæ</span>
        </button>
        <button
          id="helpButton"
          type="button"
          data-testid="help-button"
          aria-label="Help &amp; shortcuts"
          title="Help &amp; shortcuts"
        >
          <span class="icon" aria-hidden="true">‚Ñπ</span>
        </button>
        <button
          id="settingsButton"
          type="button"
          data-testid="settings-button"
          aria-label="Settings"
          title="Settings"
        >
          <span class="icon" aria-hidden="true">‚öô</span>
        </button>
      </header>
      <div id="viewport">
        <div id="canvasStage">
          <div id="canvasTransform">
            <canvas
              id="puzzleCanvas"
              data-testid="puzzle-canvas"
              width="640"
              height="480"
            ></canvas>
          </div>
        </div>
        <div id="pointerOverlay" aria-hidden="true">
          <div class="pointer-indicator"></div>
          <div class="pointer-tooltip">
            <span class="pointer-swatch" data-pointer-color-swatch aria-hidden="true"></span>
            <strong class="pointer-number" data-pointer-number></strong>
          </div>
        </div>
        <div id="previewOverlay" class="hidden" aria-hidden="true">
          <div>
            <canvas
              id="previewCanvas"
              data-testid="preview-canvas"
              width="640"
              height="480"
            ></canvas>
            <div style="display: grid; place-items: center; margin-top: 16px;">
              <button id="closePreview" type="button">Return to puzzle</button>
            </div>
          </div>
        </div>
        <div id="startHint" class="hint" tabindex="0" data-testid="start-hint">
          <div class="hint-body">
            <img
              id="sampleArtPreview"
              class="sample-art"
              alt="Capybara sample illustration"
            />
            <h1>Drop an image to start</h1>
            <p>
              Drag a picture anywhere on the screen, choose a file from your device,
              or jump straight into our capybara sample scene.
            </p>
              <div class="detail-callout">
                <p class="detail-intro">Pick a detail level for the capybara demo:</p>
                <div class="detail-picker" role="group" aria-label="Capybara sample detail level">
                  <button type="button" class="detail-chip" data-detail-level="low">Low</button>
                  <button type="button" class="detail-chip" data-detail-level="medium">Medium</button>
                  <button type="button" class="detail-chip" data-detail-level="high">High</button>
                </div>
                <p class="detail-caption" data-detail-caption></p>
              </div>
            <div class="hint-actions">
              <button id="selectImage" type="button">Choose an image</button>
              <button
                id="samplePuzzle"
                type="button"
                data-action="load-sample"
                aria-label="Load capybara sample puzzle"
              >
                Try the capybara sample
              </button>
            </div>
          </div>
        </div>
      </div>
      <footer id="paletteDock" aria-label="Palette dock" data-testid="palette-dock">
        <div id="palette" role="list"></div>
      </footer>
    </div>
    <input id="fileInput" type="file" accept=".json,image/*" hidden />
    <div id="sheetBackdrop" class="backdrop hidden" tabindex="-1"></div>
    <div
      id="helpSheet"
      class="sheet hidden"
      role="dialog"
      aria-modal="true"
      aria-labelledby="helpTitle"
    >
      <div class="sheet-header">
        <h2 id="helpTitle">Help &amp; shortcuts</h2>
        <button type="button" class="close-button" data-sheet-close="help">Close</button>
      </div>
      <div class="sheet-body">
        <section class="sheet-section" aria-labelledby="commandsHeading">
          <h3 id="commandsHeading">Command buttons</h3>
          <dl class="command-list">
            <dt>? Hint</dt>
            <dd>Flash the smallest unfinished region and switch colours if needed.</dd>
            <dt>‚Ü∫ Reset</dt>
            <dd>Clear every painted region and restart the current puzzle.</dd>
            <dt>üñº Preview</dt>
            <dd>Toggle the finished artwork overlay to compare your progress.</dd>
            <dt>üêπ Sample</dt>
              <dd>
                Reload the built-in capybara puzzle for a fresh board. Pair it with the Low/Medium/High
                detail presets to jump between ‚âà26, ‚âà42, or ‚âà140 regions.
              </dd>
              <dt>üéö Detail</dt>
              <dd>
                Toggle the capybara detail chips (start hint or Settings) to reload the sample with tuned
                palette sizes, minimum region areas, resize targets, and the region counts noted above.
              </dd>
            <dt>‚õ∂ Fullscreen</dt>
            <dd>Expand the app to fill the display or exit back to windowed mode.</dd>
            <dt>‚¨Ü Import</dt>
            <dd>Load a new image or JSON puzzle from disk.</dd>
            <dt>üíæ Saves</dt>
            <dd>Manage snapshots ‚Äî load, rename, export, or delete stored games.</dd>
            <dt>‚Ñπ Help</dt>
            <dd>Open this guide and inspect the live debug log.</dd>
            <dt>‚öô Settings</dt>
            <dd>
              Adjust generation sliders, toggle auto-advance, customise the background, resize the interface, or export JSON.
              Expand Advanced options to edit the hidden art prompt metadata when you need to capture the original brief.
            </dd>
          </dl>
        </section>
        <section class="sheet-section" aria-labelledby="controlsHeading">
          <h3 id="controlsHeading">Canvas controls</h3>
          <ul class="control-list">
            <li><kbd>Click</kbd> Fill the tapped region if it matches the active colour.</li>
            <li>Select a palette swatch to set the active colour and flash every matching region.</li>
            <li><kbd>Mouse wheel</kbd> or <kbd>+</kbd>/<kbd>-</kbd> Zoom in or out around the cursor.</li>
            <li><kbd>Space</kbd> + drag (or middle/right drag) Pan the canvas.</li>
            <li>Drag &amp; drop an image or JSON file anywhere on the window to import it.</li>
          </ul>
        </section>
        <section class="sheet-section" aria-labelledby="debugHeading">
          <h3 id="debugHeading">Debug log</h3>
          <p class="control-note">
            Recent actions, selections, and generation events appear here while you play.
          </p>
          <div
            id="debugLog"
            class="debug-log"
            role="log"
            aria-live="polite"
            aria-relevant="additions text"
          ></div>
          <div class="log-actions">
            <button id="clearDebugLog" type="button">Clear log</button>
          </div>
        </section>
      </div>
    </div>
    <div
      id="settingsSheet"
      class="sheet hidden"
      role="dialog"
      aria-modal="true"
      aria-labelledby="settingsTitle"
    >
      <div class="sheet-header">
        <h2 id="settingsTitle">Settings</h2>
        <button type="button" class="close-button" data-sheet-close="settings">Close</button>
      </div>
      <div class="sheet-body">
        <section class="sheet-section" aria-labelledby="gameplayHeading">
          <h3 id="gameplayHeading">Gameplay</h3>
          <label class="toggle">
            <input id="autoAdvanceToggle" type="checkbox" checked />
            <span>Auto-advance to the next colour when complete</span>
          </label>
          <label class="toggle">
            <input id="hintFlashToggle" type="checkbox" checked />
            <span>Animate hint highlights</span>
          </label>
        </section>
        <section class="sheet-section" aria-labelledby="appearanceHeading">
          <h3 id="appearanceHeading">Appearance</h3>
          <label class="control">
            <span>Background colour</span>
            <input id="backgroundColor" type="color" value="#f8fafc" />
          </label>
          <p class="control-note">
            Applies to unfinished regions and adjusts outline contrast automatically.
          </p>
          <label class="control">
            <span>Interface scale <output data-for="uiScale">100%</output></span>
            <input
              id="uiScale"
              type="range"
              min="0.85"
              max="1.35"
              step="0.05"
              value="1"
            />
          </label>
          <p class="control-note">Resize command buttons and labels without altering canvas zoom.</p>
        </section>
        <section class="sheet-section" aria-labelledby="generatorHeading">
          <h3 id="generatorHeading">Generator</h3>
          <div class="detail-callout">
            <p class="detail-intro">Capybara sample detail presets</p>
            <div class="detail-picker" role="group" aria-label="Capybara sample detail presets">
              <button type="button" class="detail-chip" data-detail-level="low">Low</button>
              <button type="button" class="detail-chip" data-detail-level="medium">Medium</button>
              <button type="button" class="detail-chip" data-detail-level="high">High</button>
            </div>
            <p class="detail-caption" data-detail-caption></p>
          </div>
          <p class="control-note">
            Switching presets updates the sliders below and reloads the sample scene when it's active.
          </p>
          <label class="control">
            <span>Colours <output data-for="colorCount">16</output></span>
            <input id="colorCount" type="range" min="4" max="64" value="16" />
          </label>
          <label class="control">
            <span>Regions <output data-for="minRegion">80 px¬≤</output></span>
            <input id="minRegion" type="range" min="1" max="600" value="80" />
          </label>
          <p class="control-note">Higher values merge smaller areas for fewer regions.</p>
          <label class="control">
            <span>Detail <output data-for="detailLevel">768 px</output></span>
            <input id="detailLevel" type="range" min="256" max="1600" step="64" value="768" />
          </label>
          <p class="control-note">Controls the longest edge used when resizing the source image.</p>
          <label class="control">
            <span>Sample rate <output data-for="sampleRate">65%</output></span>
            <input id="sampleRate" type="range" min="25" max="100" step="5" value="65" />
          </label>
          <p class="control-note">Lower values speed up clustering by sampling fewer pixels.</p>
          <label class="control">
            <span>Iterations <output data-for="kmeansIters">12</output></span>
            <input id="kmeansIters" type="range" min="4" max="32" step="1" value="12" />
          </label>
          <label class="control">
            <span>Smoothing passes <output data-for="smoothingPasses">1</output></span>
            <input id="smoothingPasses" type="range" min="0" max="4" step="1" value="1" />
          </label>
          <details class="advanced-options" id="generatorAdvanced">
            <summary>Advanced options</summary>
            <label class="control">
              <span>Art prompt</span>
              <textarea
                id="artPrompt"
                rows="3"
                placeholder="Describe the scene you want to reinterpret"
              ></textarea>
            </label>
            <p class="control-note">
              Stored with saves and exports so you can revisit the inspiration later.
            </p>
          </details>
        </section>
      </div>
      <div class="sheet-actions">
        <button id="downloadJson" type="button" disabled>Export puzzle JSON</button>
        <button id="applyOptions" type="button" disabled>Apply changes</button>
      </div>
    </div>
    <div
      id="saveSheet"
      class="sheet hidden"
      role="dialog"
      aria-modal="true"
      aria-labelledby="saveTitle"
    >
      <div class="sheet-header">
        <h2 id="saveTitle">Save manager</h2>
        <button type="button" class="close-button" data-sheet-close="save">Close</button>
      </div>
      <div class="sheet-body">
        <button id="saveSnapshot" type="button" disabled>Save current puzzle</button>
        <ul id="saveList" aria-live="polite"></ul>
      </div>
    </div>
        <script>
      // Cached DOM references so we can wire handlers without repeated lookups.
      const appEl = document.getElementById("app");
      const fileInput = document.getElementById("fileInput");
      const selectButton = document.getElementById("selectImage");
      const sampleButtons = Array.from(document.querySelectorAll('[data-action="load-sample"]'));
      const sampleDetailButtons = Array.from(document.querySelectorAll('[data-detail-level]'));
      const sampleDetailCaptions = Array.from(document.querySelectorAll('[data-detail-caption]'));
      const samplePreview = document.getElementById("sampleArtPreview");
      const startHint = document.getElementById("startHint");
      const hintButton = document.getElementById("hintButton");
      const resetButton = document.getElementById("resetButton");
      const previewToggle = document.getElementById("previewToggle");
      const fullscreenButton = document.getElementById("fullscreenButton");
      const importButton = document.getElementById("importButton");
      const saveManagerButton = document.getElementById("saveManagerButton");
      const settingsButton = document.getElementById("settingsButton");
      const helpButton = document.getElementById("helpButton");
      const closePreviewButton = document.getElementById("closePreview");
      const previewOverlay = document.getElementById("previewOverlay");
      const sheetBackdrop = document.getElementById("sheetBackdrop");
      const settingsSheet = document.getElementById("settingsSheet");
      const saveSheet = document.getElementById("saveSheet");
      const helpSheet = document.getElementById("helpSheet");
      const debugLogEl = document.getElementById("debugLog");
      const clearDebugLogButton = document.getElementById("clearDebugLog");
      const viewportEl = document.getElementById("viewport");
      const canvasStage = document.getElementById("canvasStage");
      const canvasTransform = document.getElementById("canvasTransform");
      const cursorOverlay = document.getElementById("pointerOverlay");
      const cursorNumberEl = cursorOverlay?.querySelector("[data-pointer-number]") || null;
      const autoAdvanceToggle = document.getElementById("autoAdvanceToggle");
      const hintFlashToggle = document.getElementById("hintFlashToggle");
      const backgroundColorInput = document.getElementById("backgroundColor");
      const uiScaleInput = document.getElementById("uiScale");
      const colorCountEl = document.getElementById("colorCount");
      const minRegionEl = document.getElementById("minRegion");
      const detailEl = document.getElementById("detailLevel");
      const sampleRateEl = document.getElementById("sampleRate");
      const kmeansItersEl = document.getElementById("kmeansIters");
      const smoothingEl = document.getElementById("smoothingPasses");
      const artPromptInput = document.getElementById("artPrompt");
      const applyBtn = document.getElementById("applyOptions");
      const downloadBtn = document.getElementById("downloadJson");
      const saveSnapshotBtn = document.getElementById("saveSnapshot");
      const saveList = document.getElementById("saveList");
      const paletteEl = document.getElementById("palette");
      const paletteSortEl = document.getElementById("paletteSort");
      const progressEl = document.getElementById("progress");
      const PROGRESS_MESSAGES = {
        idle: "Choose an artwork to start",
        loading: "Loading puzzle‚Ä¶",
        active: "Keep colouring",
        complete: "All done!",
      };
      const puzzleCanvas = document.getElementById("puzzleCanvas");
      const previewCanvas = document.getElementById("previewCanvas");
      const puzzleCtx = puzzleCanvas.getContext("2d");
      const previewCtx = previewCanvas.getContext("2d");

      // Settings sheet output mirrors we update while users drag sliders.
      const optionOutputs = {
        colorCount: settingsSheet.querySelector('output[data-for="colorCount"]'),
        minRegion: settingsSheet.querySelector('output[data-for="minRegion"]'),
        detail: settingsSheet.querySelector('output[data-for="detailLevel"]'),
        sample: settingsSheet.querySelector('output[data-for="sampleRate"]'),
        iterations: settingsSheet.querySelector('output[data-for="kmeansIters"]'),
        smoothing: settingsSheet.querySelector('output[data-for="smoothingPasses"]'),
        uiScale: settingsSheet.querySelector('output[data-for="uiScale"]'),
      };
      const SAVE_STORAGE_KEY = "capy.saves.v2";
      const AUTOSAVE_STORAGE_KEY = "capy.autosave.v1";
      const CLOUD_STORAGE_KEY = "capy.cloud.backup.v1";
      const DEFAULT_BACKGROUND_HEX = "#f8fafc";
      let backgroundPixel = [...hexToRgb(DEFAULT_BACKGROUND_HEX), 255];
      let backgroundInk = computeInkStyles(DEFAULT_BACKGROUND_HEX);
      const cloudSync = createCloudSync();
      let autosaveTimer = null;
      let pendingAutosaveReason = null;
      let preventingBrowserZoom = false;
      const DOUBLE_TAP_GUARD_MS = 350;

      function isInteractiveElementForZoomGuard(node) {
        return (
          node instanceof Element &&
          Boolean(
            node.closest(
              "input, textarea, select, button, [role=\"button\"], [role=\"textbox\"], [role=\"slider\"], [contenteditable=\"true\"]"
            )
          )
        );
      }

      function installBrowserZoomGuards() {
        if (typeof window === "undefined") return;
        if (preventingBrowserZoom) return;
        let lastTouchEndTime = 0;
        const isGameSurface = (node) => {
          if (!(node instanceof Node)) return false;
          if (canvasStage && canvasStage.contains(node)) return true;
          if (canvasTransform && canvasTransform.contains(node)) return true;
          if (puzzleCanvas && puzzleCanvas.contains(node)) return true;
          if (viewportEl && viewportEl.contains(node)) return true;
          return false;
        };

        window.addEventListener(
          "touchend",
          (event) => {
            const now = Date.now();
            const remainingTouches = event.touches ? event.touches.length : 0;
            if (remainingTouches === 0 && now - lastTouchEndTime <= DOUBLE_TAP_GUARD_MS) {
              if (!isInteractiveElementForZoomGuard(event.target)) {
                event.preventDefault();
              }
            }
            lastTouchEndTime = now;
          },
          { passive: false }
        );

        ["gesturestart", "gesturechange", "gestureend"].forEach((type) => {
          window.addEventListener(
            type,
            (event) => {
              if (event && typeof event.preventDefault === "function") {
                event.preventDefault();
              }
            },
            { passive: false }
          );
        });

        window.addEventListener(
          "wheel",
          (event) => {
            if (!event) return;
            if (!event.ctrlKey && !event.metaKey) return;
            const isInteractive = isInteractiveElementForZoomGuard(event.target);
            const isStageTarget = isGameSurface(event.target);
            if (isInteractive || isStageTarget) {
              return;
            }
            event.preventDefault();
          },
          { passive: false, capture: true }
        );

        window.addEventListener(
          "keydown",
          (event) => {
            if (!event) return;
            if (!event.ctrlKey && !event.metaKey) return;
            if (event.altKey) return;
            const isInteractive = isInteractiveElementForZoomGuard(event.target);
            if (isInteractive) return;
            const key = event.key;
            const code = event.code;
            const wantsReset = key === "0" || code === "Digit0" || code === "Numpad0";
            const wantsZoomIn =
              key === "+" || key === "=" || code === "Equal" || code === "NumpadAdd";
            const wantsZoomOut = key === "-" || code === "Minus" || code === "NumpadSubtract";
            if (!wantsReset && !wantsZoomIn && !wantsZoomOut) {
              return;
            }
            event.preventDefault();
            if (wantsReset) {
              resetView({ preserveZoom: false, recenter: true });
              return;
            }
            const allowShortcutTarget =
              isGameSurface(event.target) ||
              event.target === document.body ||
              event.target === document.documentElement;
            if (!allowShortcutTarget) {
              return;
            }
            applyZoom(wantsZoomIn ? 1.1 : 0.9);
          },
          { capture: true }
        );

        preventingBrowserZoom = true;
      }

      // Embedded sample used for onboarding and smoke tests.
      const SAMPLE_ARTWORK = {
        title: "Capybara Springs",
        description: "A capybara with an orange crown relaxes beside a dachshund in a forest lagoon.",
        dataUrl:
          "data:image/svg+xml;base64,PCEtLSBDYXB5YmFyYSBMYWdvb24gU3VucmlzZSAtIFNlZ21lbnRlZCBTVkcgLS0+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgOTYwIDYwMCIgd2lkdGg9Ijk2MCIgaGVpZ2h0PSI2MDAiIHJvbGU9ImltZyIgYXJpYS1sYWJlbGxlZGJ5PSJ0aXRsZSBkZXNjIj4KICA8dGl0bGUgaWQ9InRpdGxlIj5DYXB5YmFyYSBMYWdvb24gU3VucmlzZTwvdGl0bGU+CiAgPGRlc2MgaWQ9ImRlc2MiPkxheWVyZWQgc3VucmlzZSBiYW5kcyBvdmVyIGEgbGFnb29uIHdpdGggYSBzdHlsaXplZCBjYXB5YmFyYSBvbiB0aGUgc2hvcmUuPC9kZXNjPgogIDxnIGlkPSJyZWdpb24tYzAxIiBkYXRhLWNlbGwtaWQ9ImMxIiBkYXRhLWNvbG9yLWlkPSIxIiBkYXRhLWNvbG9yLW5hbWU9IlN1bnJpc2UgU2t5IiBkYXRhLWNvbG9yLWhleD0iI2Y2YmY2MCIgZmlsbD0iI2Y2YmY2MCI+CiAgICA8dGl0bGU+UmVnaW9uIGMxIOKAkyBDb2xvciAjMSAoU3VucmlzZSBTa3kpPC90aXRsZT4KICAgIDxwYXRoIGQ9Ik0wIDAgTDk2MCAwIEw5NjAgODAgQyA4MjAgNzAgNjgwIDY4IDU0MCA3MiBDIDM4MCA3OCAyMjAgODYgMCA4MCBaIi8+CiAgPC9nPgogIDxnIGlkPSJyZWdpb24tYzAyIiBkYXRhLWNlbGwtaWQ9ImMyIiBkYXRhLWNvbG9yLWlkPSIxIiBkYXRhLWNvbG9yLW5hbWU9IlN1bnJpc2UgU2t5IiBkYXRhLWNvbG9yLWhleD0iI2Y2YmY2MCIgZmlsbD0iI2Y2YmY2MCI+CiAgICA8dGl0bGU+UmVnaW9uIGMyIOKAkyBDb2xvciAjMSAoU3VucmlzZSBTa3kpPC90aXRsZT4KICAgIDxwYXRoIGQ9Ik0wIDgwIEMgMjAwIDkwIDM2MCA4NiA1NDAgODAgQyA3MjAgNzQgODYwIDc2IDk2MCA4MCBMOTYwIDE0OCBDIDgyMCAxNDIgNjgwIDE0OCA1MjAgMTU2IEMgMzYwIDE2NiAyMDAgMTY0IDAgMTQ4IFoiLz4KICA8L2c+CiAgPGcgaWQ9InJlZ2lvbi1jMDMiIGRhdGEtY2VsbC1pZD0iYzMiIGRhdGEtY29sb3ItaWQ9IjIiIGRhdGEtY29sb3ItbmFtZT0iQW1iZXIgRHJpZnQiIGRhdGEtY29sb3ItaGV4PSIjZjQ5OTRjIiBmaWxsPSIjZjQ5OTRjIj4KICAgIDx0aXRsZT5SZWdpb24gYzMg4oCTIENvbG9yICMyIChBbWJlciBEcmlmdCk8L3RpdGxlPgogICAgPHBhdGggZD0iTTAgMTQ4IEMgMTYwIDE1NiAzMjAgMTYwIDUyMCAxNTIgQyA1MDAgMTc2IDQ4MCAxOTggNDQwIDIxMiBDIDMyMCAyMjAgMTYwIDIxOCAwIDIxNiBaIi8+CiAgPC9nPgogIDxnIGlkPSJyZWdpb24tYzA0IiBkYXRhLWNlbGwtaWQ9ImM0IiBkYXRhLWNvbG9yLWlkPSIyIiBkYXRhLWNvbG9yLW5hbWU9IkFtYmVyIERyaWZ0IiBkYXRhLWNvbG9yLWhleD0iI2Y0OTk0YyIgZmlsbD0iI2Y0OTk0YyI+CiAgICA8dGl0bGU+UmVnaW9uIGM0IOKAkyBDb2xvciAjMiAoQW1iZXIgRHJpZnQpPC90aXRsZT4KICAgIDxwYXRoIGQ9Ik01MjAgMTUyIEMgNzAwIDE1MCA4NDAgMTQ2IDk2MCAxNDggQyA5NDAgMTc2IDkwMCAxOTggODYwIDIxMCBDIDc0MCAyMjAgNjQwIDIyMCA1MjAgMjE0IEMgNTIwIDE5NCA1MjAgMTcyIDUyMCAxNTIgWiIvPgogIDwvZz4KICA8ZyBpZD0icmVnaW9uLWMwNSIgZGF0YS1jZWxsLWlkPSJjNSIgZGF0YS1jb2xvci1pZD0iMyIgZGF0YS1jb2xvci1uYW1lPSJWaW9sZXQgUmlkZ2UiIGRhdGEtY29sb3ItaGV4PSIjOWE2YmIzIiBmaWxsPSIjOWE2YmIzIj4KICAgIDx0aXRsZT5SZWdpb24gYzUg4oCTIENvbG9yICMzIChWaW9sZXQgUmlkZ2UpPC90aXRsZT4KICAgIDxwYXRoIGQ9Ik0wIDIxNiBDIDEyMCAyMjggMjIwIDIzMiAzMjAgMjMwIEMgMzAwIDI0OCAyNjAgMjY4IDIxMCAyNzggQyAxNTAgMjg2IDgwIDI4NCAwIDI4MCBaIi8+CiAgPC9nPgogIDxnIGlkPSJyZWdpb24tYzA2IiBkYXRhLWNlbGwtaWQ9ImM2IiBkYXRhLWNvbG9yLWlkPSIzIiBkYXRhLWNvbG9yLW5hbWU9IlZpb2xldCBSaWRnZSIgZGF0YS1jb2xvci1oZXg9IiM5YTZiYjMiIGZpbGw9IiM5YTZiYjMiPgogICAgPHRpdGxlPlJlZ2lvbiBjNiDigJMgQ29sb3IgIzMgKFZpb2xldCBSaWRnZSk8L3RpdGxlPgogICAgPHBhdGggZD0iTTMyMCAyMzAgQyA0NDAgMjM2IDUyMCAyMzQgNjQwIDIyNiBDIDYzMCAyNTAgNjAwIDI2OCA1NjAgMjc2IEMgNDgwIDI4NiA0MDAgMjg0IDMyMCAyNzggQyAzMjAgMjU4IDMyMCAyNDQgMzIwIDIzMCBaIi8+CiAgPC9nPgogIDxnIGlkPSJyZWdpb24tYzA3IiBkYXRhLWNlbGwtaWQ9ImM3IiBkYXRhLWNvbG9yLWlkPSIzIiBkYXRhLWNvbG9yLW5hbWU9IlZpb2xldCBSaWRnZSIgZGF0YS1jb2xvci1oZXg9IiM5YTZiYjMiIGZpbGw9IiM5YTZiYjMiPgogICAgPHRpdGxlPlJlZ2lvbiBjNyDigJMgQ29sb3IgIzMgKFZpb2xldCBSaWRnZSk8L3RpdGxlPgogICAgPHBhdGggZD0iTTY0MCAyMjYgQyA3NjAgMjI0IDg2MCAyMjAgOTYwIDIyMCBDIDk0MCAyNDAgOTAwIDI2MCA4NjAgMjcyIEMgNzgwIDI4NiA3MDAgMjg0IDY0MCAyNzggQyA2NDAgMjU2IDY0MCAyNDAgNjQwIDIyNiBaIi8+CiAgPC9nPgogIDxnIGlkPSJyZWdpb24tYzA4IiBkYXRhLWNlbGwtaWQ9ImM4IiBkYXRhLWNvbG9yLWlkPSI0IiBkYXRhLWNvbG9yLW5hbWU9IkZvcmVzdCBSaWRnZSIgZGF0YS1jb2xvci1oZXg9IiM1ZDdhNzYiIGZpbGw9IiM1ZDdhNzYiPgogICAgPHRpdGxlPlJlZ2lvbiBjOCDigJMgQ29sb3IgIzQgKEZvcmVzdCBSaWRnZSk8L3RpdGxlPgogICAgPHBhdGggZD0iTTAgMjgwIEMgMTAwIDI5MiAyMDAgMzAwIDMyMCAyOTIgQyAzMDAgMzEyIDI2MCAzMjggMjEwIDMzNiBDIDE1MCAzNDQgODAgMzQ0IDAgMzQwIFoiLz4KICA8L2c+CiAgPGcgaWQ9InJlZ2lvbi1jMDkiIGRhdGEtY2VsbC1pZD0iYzkiIGRhdGEtY29sb3ItaWQ9IjQiIGRhdGEtY29sb3ItbmFtZT0iRm9yZXN0IFJpZGdlIiBkYXRhLWNvbG9yLWhleD0iIzVkN2E3NiIgZmlsbD0iIzVkN2E3NiI+CiAgICA8dGl0bGU+UmVnaW9uIGM5IOKAkyBDb2xvciAjNCAoRm9yZXN0IFJpZGdlKTwvdGl0bGU+CiAgICA8cGF0aCBkPSJNMzIwIDI5MiBDIDQ0MCAyOTggNTQwIDMwMCA2NDAgMjk4IEMgNjIwIDMxOCA1ODAgMzMyIDU0MCAzNDAgQyA0NjAgMzQ4IDM4MCAzNDYgMzIwIDM0MCBDIDMyMCAzMjAgMzIwIDMwNiAzMjAgMjkyIFoiLz4KICA8L2c+CiAgPGcgaWQ9InJlZ2lvbi1jMTAiIGRhdGEtY2VsbC1pZD0iYzEwIiBkYXRhLWNvbG9yLWlkPSI0IiBkYXRhLWNvbG9yLW5hbWU9IkZvcmVzdCBSaWRnZSIgZGF0YS1jb2xvci1oZXg9IiM1ZDdhNzYiIGZpbGw9IiM1ZDdhNzYiPgogICAgPHRpdGxlPlJlZ2lvbiBjMTAg4oCTIENvbG9yICM0IChGb3Jlc3QgUmlkZ2UpPC90aXRsZT4KICAgIDxwYXRoIGQ9Ik02NDAgMjk4IEMgNzYwIDMwMCA4NjAgMzAwIDk2MCAzMDAgQyA5NDAgMzIwIDkwMCAzMzIgODYwIDM0MCBDIDc4MCAzNDggNzAwIDM0OCA2NDAgMzQwIEMgNjQwIDMyMCA2NDAgMzA4IDY0MCAyOTggWiIvPgogIDwvZz4KICA8ZyBpZD0icmVnaW9uLWMxMSIgZGF0YS1jZWxsLWlkPSJjMTEiIGRhdGEtY29sb3ItaWQ9IjUiIGRhdGEtY29sb3ItbmFtZT0iTGFnb29uIExpZ2h0IiBkYXRhLWNvbG9yLWhleD0iIzc2YzdkNiIgZmlsbD0iIzc2YzdkNiI+CiAgICA8dGl0bGU+UmVnaW9uIGMxMSDigJMgQ29sb3IgIzUgKExhZ29vbiBMaWdodCk8L3RpdGxlPgogICAgPHBhdGggZD0iTTAgMzQwIEMgMTIwIDM0NCAyMjAgMzQ2IDMyMCAzNDQgQyAzMDAgMzUwIDMwMCAzNTIgMzIwIDM1MiBDIDIwMCAzNTYgMTIwIDM1NCAwIDM1MiBDIDAgMzQ4IDAgMzQ0IDAgMzQwIFoiLz4KICA8L2c+CiAgPGcgaWQ9InJlZ2lvbi1jMTIiIGRhdGEtY2VsbC1pZD0iYzEyIiBkYXRhLWNvbG9yLWlkPSI1IiBkYXRhLWNvbG9yLW5hbWU9IkxhZ29vbiBMaWdodCIgZGF0YS1jb2xvci1oZXg9IiM3NmM3ZDYiIGZpbGw9IiM3NmM3ZDYiPgogICAgPHRpdGxlPlJlZ2lvbiBjMTIg4oCTIENvbG9yICM1IChMYWdvb24gTGlnaHQpPC90aXRsZT4KICAgIDxwYXRoIGQ9Ik0zMjAgMzQ0IEMgNDQwIDM0NiA1NDAgMzQ0IDY0MCAzNDIgQyA2NDAgMzQ2IDY0MCAzNTAgNjQwIDM1MiBDIDUyMCAzNTYgNDIwIDM1NiAzMjAgMzUyIEMgMzIwIDM0OCAzMjAgMzQ2IDMyMCAzNDQgWiIvPgogIDwvZz4KICA8ZyBpZD0icmVnaW9uLWMxMyIgZGF0YS1jZWxsLWlkPSJjMTMiIGRhdGEtY29sb3ItaWQ9IjUiIGRhdGEtY29sb3ItbmFtZT0iTGFnb29uIExpZ2h0IiBkYXRhLWNvbG9yLWhleD0iIzc2YzdkNiIgZmlsbD0iIzc2YzdkNiI+CiAgICA8dGl0bGU+UmVnaW9uIGMxMyDigJMgQ29sb3IgIzUgKExhZ29vbiBMaWdodCk8L3RpdGxlPgogICAgPHBhdGggZD0iTTY0MCAzNDIgQyA3NjAgMzQwIDg2MCAzMzggOTYwIDM0MCBDIDk2MCAzNDQgOTYwIDM0OCA5NjAgMzUyIEMgODQwIDM1NCA3NDAgMzU0IDY0MCAzNTIgQyA2NDAgMzQ4IDY0MCAzNDQgNjQwIDM0MiBaIi8+CiAgPC9nPgogIDxnIGlkPSJyZWdpb24tYzE0IiBkYXRhLWNlbGwtaWQ9ImMxNCIgZGF0YS1jb2xvci1pZD0iNSIgZGF0YS1jb2xvci1uYW1lPSJMYWdvb24gTGlnaHQiIGRhdGEtY29sb3ItaGV4PSIjNzZjN2Q2IiBmaWxsPSIjNzZjN2Q2Ij4KICAgIDx0aXRsZT5SZWdpb24gYzE0IOKAkyBDb2xvciAjNSAoTGFnb29uIExpZ2h0KTwvdGl0bGU+CiAgICA8cGF0aCBkPSJNMCAzNTIgQyAxMjAgMzU2IDIyMCAzNTYgMzIwIDM1MiBDIDMxMCAzNjQgMzEwIDM3MiAzMjAgMzc2IEMgMjAwIDM4MiAxMjAgMzgwIDAgMzc2IEMgMCAzNjQgMCAzNTggMCAzNTIgWiIvPgogIDwvZz4KICA8ZyBpZD0icmVnaW9uLWMxNSIgZGF0YS1jZWxsLWlkPSJjMTUiIGRhdGEtY29sb3ItaWQ9IjUiIGRhdGEtY29sb3ItbmFtZT0iTGFnb29uIExpZ2h0IiBkYXRhLWNvbG9yLWhleD0iIzc2YzdkNiIgZmlsbD0iIzc2YzdkNiI+CiAgICA8dGl0bGU+UmVnaW9uIGMxNSDigJMgQ29sb3IgIzUgKExhZ29vbiBMaWdodCk8L3RpdGxlPgogICAgPHBhdGggZD0iTTMyMCAzNTIgQyA0NDAgMzU0IDU0MCAzNTIgNjQwIDM1MiBDIDY1MCAzNjIgNjUwIDM3MCA2NDAgMzc2IEMgNTIwIDM4MiA0MjAgMzgyIDMyMCAzNzYgQyAzMjAgMzY2IDMyMCAzNjAgMzIwIDM1MiBaIi8+CiAgPC9nPgogIDxnIGlkPSJyZWdpb24tYzE2IiBkYXRhLWNlbGwtaWQ9ImMxNiIgZGF0YS1jb2xvci1pZD0iNSIgZGF0YS1jb2xvci1uYW1lPSJMYWdvb24gTGlnaHQiIGRhdGEtY29sb3ItaGV4PSIjNzZjN2Q2IiBmaWxsPSIjNzZjN2Q2Ij4KICAgIDx0aXRsZT5SZWdpb24gYzE2IOKAkyBDb2xvciAjNSAoTGFnb29uIExpZ2h0KTwvdGl0bGU+CiAgICA8cGF0aCBkPSJNNjQwIDM1MiBDIDc2MCAzNTIgODYwIDM1MCA5NjAgMzUyIEMgOTYwIDM2MiA5NjAgMzcyIDk2MCAzNzYgQyA4NDAgMzgwIDc0MCAzODAgNjQwIDM3NiBDIDY0MCAzNjYgNjQwIDM1OCA2NDAgMzUyIFoiLz4KICA8L2c+CiAgPGcgaWQ9InJlZ2lvbi1jMTciIGRhdGEtY2VsbC1pZD0iYzE3IiBkYXRhLWNvbG9yLWlkPSI2IiBkYXRhLWNvbG9yLW5hbWU9IkxhZ29vbiBEZXB0aCIgZGF0YS1jb2xvci1oZXg9IiMxYzZmOGMiIGZpbGw9IiMxYzZmOGMiPgogICAgPHRpdGxlPlJlZ2lvbiBjMTcg4oCTIENvbG9yICM2IChMYWdvb24gRGVwdGgpPC90aXRsZT4KICAgIDxwYXRoIGQ9Ik0wIDM3NiBDIDE2MCAzODIgMzIwIDM4OCA0ODAgMzg0IEMgNDgwIDM5NCA0ODAgNDAwIDQ4MCA0MDQgQyAzMjAgNDA4IDE2MCA0MDQgMCA0MDQgQyAwIDM5MiAwIDM4NCAwIDM3NiBaIi8+CiAgPC9nPgogIDxnIGlkPSJyZWdpb24tYzE4IiBkYXRhLWNlbGwtaWQ9ImMxOCIgZGF0YS1jb2xvci1pZD0iNiIgZGF0YS1jb2xvci1uYW1lPSJMYWdvb24gRGVwdGgiIGRhdGEtY29sb3ItaGV4PSIjMWM2ZjhjIiBmaWxsPSIjMWM2ZjhjIj4KICAgIDx0aXRsZT5SZWdpb24gYzE4IOKAkyBDb2xvciAjNiAoTGFnb29uIERlcHRoKTwvdGl0bGU+CiAgICA8cGF0aCBkPSJNNDgwIDM3NiBDIDY0MCAzODIgODAwIDM4MCA5NjAgMzc2IEw5NjAgNDA0IEMgODAwIDQxMCA2NDAgNDEyIDQ4MCA0MDQgQyA0ODAgMzk0IDQ4MCAzODYgNDgwIDM3NiBaIi8+CiAgPC9nPgogIDxnIGlkPSJyZWdpb24tYzE5IiBkYXRhLWNlbGwtaWQ9ImMxOSIgZGF0YS1jb2xvci1pZD0iNiIgZGF0YS1jb2xvci1uYW1lPSJMYWdvb24gRGVwdGgiIGRhdGEtY29sb3ItaGV4PSIjMWM2ZjhjIiBmaWxsPSIjMWM2ZjhjIj4KICAgIDx0aXRsZT5SZWdpb24gYzE5IOKAkyBDb2xvciAjNiAoTGFnb29uIERlcHRoKTwvdGl0bGU+CiAgICA8cGF0aCBkPSJNMCA0MDQgQyAxNjAgNDEwIDMyMCA0MTYgNDgwIDQxMiBDIDQ4MCA0MjggNDgwIDQ0MCA0ODAgNDQ4IEMgMzIwIDQ1NiAxNjAgNDUyIDAgNDQ4IEMgMCA0MzAgMCA0MTYgMCA0MDQgWiIvPgogIDwvZz4KICA8ZyBpZD0icmVnaW9uLWMyMCIgZGF0YS1jZWxsLWlkPSJjMjAiIGRhdGEtY29sb3ItaWQ9IjYiIGRhdGEtY29sb3ItbmFtZT0iTGFnb29uIERlcHRoIiBkYXRhLWNvbG9yLWhleD0iIzFjNmY4YyIgZmlsbD0iIzFjNmY4YyI+CiAgICA8dGl0bGU+UmVnaW9uIGMyMCDigJMgQ29sb3IgIzYgKExhZ29vbiBEZXB0aCk8L3RpdGxlPgogICAgPHBhdGggZD0iTTQ4MCA0MTIgQyA2NDAgNDE2IDgwMCA0MTAgOTYwIDQwNCBMOTYwIDQ0OCBDIDgyMCA0NTYgNjgwIDQ2MCA1MjAgNDU2IEMgNTAwIDQ1NCA0OTAgNDQ4IDQ4MCA0NDggQyA0ODAgNDMyIDQ4MCA0MjAgNDgwIDQxMiBaIi8+CiAgPC9nPgogIDxnIGlkPSJyZWdpb24tYzIxIiBkYXRhLWNlbGwtaWQ9ImMyMSIgZGF0YS1jb2xvci1pZD0iNyIgZGF0YS1jb2xvci1uYW1lPSJTaG9yZSBMZWZ0IiBkYXRhLWNvbG9yLWhleD0iIzRmN2Q1YyIgZmlsbD0iIzRmN2Q1YyI+CiAgICA8dGl0bGU+UmVnaW9uIGMyMSDigJMgQ29sb3IgIzcgKFNob3JlIExlZnQpPC90aXRsZT4KICAgIDxwYXRoIGQ9Ik0wIDQ0OCBDIDEyMCA0NTQgMjIwIDQ1OCAzMDAgNDYyIEMgMjgwIDUwMCAyMjAgNTQwIDE0MCA1NjYgQyA4MCA1ODQgMzAgNTkyIDAgNTkyIEMgMCA1NDQgMCA0OTYgMCA0NDggWiIvPgogIDwvZz4KICA8ZyBpZD0icmVnaW9uLWMyMiIgZGF0YS1jZWxsLWlkPSJjMjIiIGRhdGEtY29sb3ItaWQ9IjciIGRhdGEtY29sb3ItbmFtZT0iU2hvcmUgTGVmdCIgZGF0YS1jb2xvci1oZXg9IiM0ZjdkNWMiIGZpbGw9IiM0ZjdkNWMiPgogICAgPHRpdGxlPlJlZ2lvbiBjMjIg4oCTIENvbG9yICM3IChTaG9yZSBMZWZ0KTwvdGl0bGU+CiAgICA8cGF0aCBkPSJNMzAwIDQ2MiBDIDM2MCA0NjggNDIwIDQ3MiA1MjAgNDU2IEMgNTEwIDQ4NiA0OTAgNTE0IDQ2MCA1NDAgQyA0MjAgNTY4IDM2MCA1ODAgMzAwIDU3MiBDIDI4MCA1NDAgMjkwIDUwMCAzMDAgNDYyIFoiLz4KICA8L2c+CiAgPGcgaWQ9InJlZ2lvbi1jMjMiIGRhdGEtY2VsbC1pZD0iYzIzIiBkYXRhLWNvbG9yLWlkPSI4IiBkYXRhLWNvbG9yLW5hbWU9IlNob3JlIE1pZGRsZSIgZGF0YS1jb2xvci1oZXg9IiM2YjkzNTgiIGZpbGw9IiM2YjkzNTgiPgogICAgPHRpdGxlPlJlZ2lvbiBjMjMg4oCTIENvbG9yICM4IChTaG9yZSBNaWRkbGUpPC90aXRsZT4KICAgIDxwYXRoIGQ9Ik01MjAgNDU2IEMgNjQwIDQ2MiA3MjAgNDY0IDc4MCA0NjAgQyA3ODggNDc0IDc5MiA0OTggNzk2IDUyOCBDIDc4NiA1ODAgNzY4IDU4NCA3NTIgNTg4IEMgNzAwIDYwMCA2NTYgNTk4IDYwNCA1ODggQyA1NjYgNTgwIDUzNCA1NjQgNTE4IDU0NiBDIDUwNiA1MzIgNTA2IDUyMCA1MjAgNTEwIEMgNTA4IDQ5NiA1MTIgNDc2IDUyMCA0NTYgWiIvPgogIDwvZz4KICA8ZyBpZD0icmVnaW9uLWMyNCIgZGF0YS1jZWxsLWlkPSJjMjQiIGRhdGEtY29sb3ItaWQ9IjkiIGRhdGEtY29sb3ItbmFtZT0iQ2FweSBCb2R5IiBkYXRhLWNvbG9yLWhleD0iIzdkNTczNSIgZmlsbD0iIzdkNTczNSI+CiAgICA8dGl0bGU+UmVnaW9uIGMyNCDigJMgQ29sb3IgIzkgKENhcHkgQm9keSk8L3RpdGxlPgogICAgPHBhdGggZD0iTTUyMCA1MTAgQyA1NDggNDcwIDYxMiA0NDAgNjkyIDQzNCBDIDc0NCA0MzAgNzY4IDQzOCA3ODAgNDU2IEMgNzkwIDQ3NCA3OTQgNDk4IDc5NiA1MjggQyA3OTggNTU2IDc4NiA1ODAgNzUyIDU4OCBDIDcwOCA2MDAgNjU2IDU5OCA2MDQgNTg4IEMgNTY2IDU4MCA1MzQgNTY0IDUxOCA1NDYgQyA1MDggNTMyIDUwNiA1MTggNTIwIDUxMCBaIi8+CiAgPC9nPgogIDxnIGlkPSJyZWdpb24tYzI1IiBkYXRhLWNlbGwtaWQ9ImMyNSIgZGF0YS1jb2xvci1pZD0iMTAiIGRhdGEtY29sb3ItbmFtZT0iQ2FweSBIZWFkIiBkYXRhLWNvbG9yLWhleD0iIzVlM2IyNCIgZmlsbD0iIzVlM2IyNCI+CiAgICA8dGl0bGU+UmVnaW9uIGMyNSDigJMgQ29sb3IgIzEwIChDYXB5IEhlYWQpPC90aXRsZT4KICAgIDxwYXRoIGQ9Ik03ODAgNDU2IEMgODA0IDQzOCA4MzggNDM4IDg2NiA0NjAgQyA4OTQgNDgyIDkwNCA1MjAgODkyIDU1NiBDIDg3OCA1OTQgODQ2IDYwOCA4MTAgNjAwIEMgODAwIDU5OCA3OTYgNTkwIDc5NiA1MjggQyA3OTQgNTAwIDc4OCA0NzQgNzgwIDQ1NiBaIi8+CiAgPC9nPgogIDxnIGlkPSJyZWdpb24tYzI2IiBkYXRhLWNlbGwtaWQ9ImMyNiIgZGF0YS1jb2xvci1pZD0iMTEiIGRhdGEtY29sb3ItbmFtZT0iU2hvcmUgUmlnaHQiIGRhdGEtY29sb3ItaGV4PSIjM2Y1YjNiIiBmaWxsPSIjM2Y1YjNiIj4KICAgIDx0aXRsZT5SZWdpb24gYzI2IOKAkyBDb2xvciAjMTEgKFNob3JlIFJpZ2h0KTwvdGl0bGU+CiAgICA8cGF0aCBkPSJNNzgwIDQ2MCBDIDg0MCA0NTYgOTAwIDQ1NCA5NjAgNDUyIEw5NjAgNjAwIEMgOTEwIDYwMCA4NzAgNTk4IDgxMCA2MDAgQyA4NDYgNjA4IDg3OCA1OTQgODkyIDU1NiBDIDg4NCA1MjAgODYwIDQ4OCA3ODAgNDYwIFoiLz4KICA8L2c+Cjwvc3ZnPgo=",
      };

      const SAMPLE_DETAIL_LEVELS = {
        low: {
          id: "low",
          label: "Low detail",
          shortLabel: "Low",
          summary: "Low detail ‚Ä¢ 18 colours / 15 px¬≤ min regions / 1216 px resize ‚Ä¢ ‚âà26 regions",
          ariaLabel:
            "Low detail ‚Äì 18 colours, 15 pixel minimum regions, 1216px resize target, about 26 regions",
          logDescriptor: "low detail",
          approxRegions: 26,
          settings: {
            targetColors: 18,
            minRegion: 15,
            maxSize: 1216,
            sampleRate: 90,
            kmeansIters: 20,
            smoothingPasses: 1,
          },
        },
        medium: {
          id: "medium",
          label: "Medium detail",
          shortLabel: "Medium",
          summary: "Medium detail ‚Ä¢ 26 colours / 8 px¬≤ min regions / 1408 px resize ‚Ä¢ ‚âà42 regions",
          ariaLabel:
            "Medium detail ‚Äì 26 colours, 8 pixel minimum regions, 1408px resize target, about 42 regions",
          logDescriptor: "medium detail",
          approxRegions: 42,
          settings: {
            targetColors: 26,
            minRegion: 8,
            maxSize: 1408,
            sampleRate: 95,
            kmeansIters: 24,
            smoothingPasses: 1,
          },
        },
        high: {
          id: "high",
          label: "High detail",
          shortLabel: "High",
          summary: "High detail ‚Ä¢ 32 colours / 3 px¬≤ min regions / 1536 px resize ‚Ä¢ ‚âà140 regions",
          ariaLabel:
            "High detail ‚Äì 32 colours, 3 pixel minimum regions, 1536px resize target, about 140 regions",
          logDescriptor: "high detail",
          approxRegions: 140,
          settings: {
            targetColors: 32,
            minRegion: 3,
            maxSize: 1536,
            sampleRate: 100,
            kmeansIters: 28,
            smoothingPasses: 1,
          },
        },
      };
      const DEFAULT_SAMPLE_DETAIL = "high";

      
      if (samplePreview) {
        samplePreview.src = SAMPLE_ARTWORK.dataUrl;
        samplePreview.alt = SAMPLE_ARTWORK.description;
        samplePreview.title = SAMPLE_ARTWORK.title;
      }

      // View state drives pan/zoom transforms. baseScale keeps the puzzle fit-to-screen while
      // zoom holds user-controlled scaling.
      const viewState = {
        panX: 0,
        panY: 0,
        zoom: 1,
        baseScale: 1,
      };

      let panPointerId = null;
      const panOrigin = { x: 0, y: 0, panX: 0, panY: 0 };
      let panCandidate = null;
      let isPanning = false;
      let spacePressed = false;
      let colorFlashTimer = null;
      const activeTouches = new Map();
      let pinchSession = null;
      let lastViewportMetrics = { orientation: null, width: 0, height: 0 };
      let cursorHoverRegionId = null;
      let cursorLastClientX = null;
      let cursorLastClientY = null;

      // Primary puzzle state bag. applyPuzzleResult populates it and render* helpers read from it.
      const state = {
        puzzle: null,
        activeColor: null,
        filled: new Set(),
        sourceUrl: null,
        sourceTitle: null,
        lastOptions: null,
        sampleDetailLevel: DEFAULT_SAMPLE_DETAIL,
        paletteSort: "region",
        settings: {
          autoAdvance: true,
          animateHints: true,
          backgroundColor: DEFAULT_BACKGROUND_HEX,
          uiScale: 1,
          artPrompt: "",
        },
        previewVisible: false,
        saves: loadSavedEntries(),
        previewImageData: null,
        puzzleImageData: null,
      };

      function applyGameplaySettings(settings = {}) {
        if (!settings || typeof settings !== "object") return;
        if (typeof settings.autoAdvance === "boolean") {
          state.settings.autoAdvance = settings.autoAdvance;
          if (autoAdvanceToggle) {
            autoAdvanceToggle.checked = settings.autoAdvance;
          }
        }
        if (typeof settings.animateHints === "boolean") {
          state.settings.animateHints = settings.animateHints;
          if (hintFlashToggle) {
            hintFlashToggle.checked = settings.animateHints;
          }
        }
        if (typeof settings.uiScale === "number") {
          applyUiScale(settings.uiScale, { skipLog: true, skipAutosave: true });
        }
        if (typeof settings.artPrompt === "string") {
          applyArtPrompt(settings.artPrompt, { skipLog: true, skipAutosave: true });
        }
      }

      const debugLogEntries = [];
      const DEBUG_LOG_LIMIT = 80;

      if (typeof window !== "undefined") {
        installBrowserZoomGuards();
        // Public hooks for tests and manual loading. Keep backwards compatible.
        window.capyGenerator = {
          getState: () => state,
          loadFromDataUrl(dataUrl, metadata) {
            if (typeof dataUrl !== "string" || dataUrl.length === 0) {
              return;
            }
            resetPuzzleUI();
            state.sourceUrl = dataUrl;
            const metadataTitle =
              metadata && typeof metadata === "object"
                ? typeof metadata.title === "string" && metadata.title.trim()
                  ? metadata.title.trim()
                  : null
                : typeof metadata === "string" && metadata.trim()
                ? metadata.trim()
                : null;
            state.sourceTitle = metadataTitle || "External data";
            startHint.classList.add("hidden");
            logDebug(`Loading external puzzle data: ${state.sourceTitle}`);
            loadImage(dataUrl);
          },
          loadPuzzleFixture(puzzle) {
            return loadPuzzleFixtureData(puzzle);
          },
          setBackgroundColor(hex) {
            applyBackgroundColor(hex);
          },
          setUiScale(scale) {
            applyUiScale(scale);
          },
          setArtPrompt(promptText) {
            applyArtPrompt(promptText);
          },
          isBrowserZoomSuppressed() {
            return preventingBrowserZoom;
          },
          togglePreview(show) {
            if (typeof show === "boolean") {
              state.previewVisible = show;
            } else {
              state.previewVisible = !state.previewVisible;
            }
            updatePreviewState();
          },
          openSettings: () => openSheet(settingsSheet),
        };
      }

      applyGameplaySettings(state.settings);
      updateOptionOutputs();
      refreshSaveList();
      updateCommandStates();
      renderDebugLog();
      logDebug("Session started");
      handleViewportChange({ log: true, recenter: true });
      resetView({ recenter: true });

      if (paletteSortEl) {
        paletteSortEl.value = state.paletteSort;
        paletteSortEl.disabled = true;
        paletteSortEl.addEventListener("change", (event) => {
          const target = event.currentTarget?.value;
          applyPaletteSort(target);
        });
      }

      for (const button of sampleButtons) {
        if (!button) continue;
        button.setAttribute("type", "button");
        button.title = `Play ${SAMPLE_ARTWORK.title}`;
        button.addEventListener("click", () => {
          loadSamplePuzzle({ detailLevel: state.sampleDetailLevel });
        });
      }

      for (const button of sampleDetailButtons) {
        if (!button) continue;
        button.setAttribute("type", "button");
        button.addEventListener("click", (event) => {
          const target = event?.currentTarget?.dataset?.detailLevel;
          applySampleDetailLevel(target);
        });
      }

      applySampleDetailLevel(DEFAULT_SAMPLE_DETAIL, { skipReload: true, skipLog: true });

      const restoredSession = loadInitialSession();
      if (!restoredSession && SAMPLE_ARTWORK?.dataUrl) {
        loadSamplePuzzle({ detailLevel: state.sampleDetailLevel, skipDetailUpdate: true });
      }

      selectButton.addEventListener("click", () => fileInput.click());
      importButton.addEventListener("click", () => fileInput.click());
      settingsButton.addEventListener("click", () => openSheet(settingsSheet));
      saveManagerButton.addEventListener("click", () => openSheet(saveSheet));
      if (helpButton) {
        helpButton.addEventListener("click", () => openSheet(helpSheet));
      }

      if (fullscreenButton) {
        fullscreenButton.addEventListener("click", () => toggleFullscreen());
        updateFullscreenState();
      }

      document.addEventListener("fullscreenchange", () => {
        updateFullscreenState();
        const active = Boolean(document.fullscreenElement);
        logDebug(active ? "Entered fullscreen mode" : "Exited fullscreen mode");
        handleViewportChange({ log: true, recenter: true });
      });

      if (clearDebugLogButton) {
        clearDebugLogButton.addEventListener("click", () => {
          debugLogEntries.splice(0, debugLogEntries.length);
          renderDebugLog();
          logDebug("Debug log cleared");
        });
      }

      for (const button of document.querySelectorAll('[data-sheet-close]')) {
        button.addEventListener("click", (event) => {
          const target = event.currentTarget.getAttribute("data-sheet-close");
          if (target === "settings") {
            closeSheet(settingsSheet);
          } else if (target === "save") {
            closeSheet(saveSheet);
          } else if (target === "help") {
            closeSheet(helpSheet);
          }
        });
      }

      sheetBackdrop.addEventListener("click", () => closeAllSheets());

      startHint.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          fileInput.click();
        }
      });

      fileInput.addEventListener("change", (event) => {
        const [file] = event.target.files || [];
        if (file) {
          handleFile(file);
        }
        fileInput.value = "";
      });

      autoAdvanceToggle.addEventListener("change", () => {
        state.settings.autoAdvance = autoAdvanceToggle.checked;
        logDebug(`Auto-advance ${autoAdvanceToggle.checked ? "enabled" : "disabled"}`);
        scheduleAutosave("settings-auto-advance");
      });

      hintFlashToggle.addEventListener("change", () => {
        state.settings.animateHints = hintFlashToggle.checked;
        logDebug(`Hint animations ${hintFlashToggle.checked ? "enabled" : "disabled"}`);
        scheduleAutosave("settings-hint-animations");
      });

      if (backgroundColorInput) {
        backgroundColorInput.addEventListener("input", (event) => {
          applyBackgroundColor(event.target.value, { skipLog: true, skipAutosave: true });
        });
        backgroundColorInput.addEventListener("change", (event) => {
          applyBackgroundColor(event.target.value);
        });
      }

      if (uiScaleInput) {
        uiScaleInput.addEventListener("input", (event) => {
          applyUiScale(event.target.value, { skipLog: true, skipAutosave: true });
        });
        uiScaleInput.addEventListener("change", (event) => {
          applyUiScale(event.target.value);
        });
      }

      if (artPromptInput) {
        artPromptInput.addEventListener("input", (event) => {
          applyArtPrompt(event.target.value, { skipLog: true, skipAutosave: true });
        });
        artPromptInput.addEventListener("change", (event) => {
          applyArtPrompt(event.target.value);
        });
      }

      hintButton.addEventListener("click", () => {
        useHint();
      });

      resetButton.addEventListener("click", () => {
        if (!state.puzzle) return;
        state.filled = new Set();
        initializePuzzleImage();
        renderPuzzle();
        renderPalette();
        if (state.activeColor != null) {
          flashColorRegions(state.activeColor);
        }
        updateProgress();
        refreshCustomCursorHighlight();
        scheduleAutosave("reset-progress");
        logDebug("Reset puzzle progress");
      });

      if (paletteEl) {
        paletteEl.addEventListener("wheel", handlePaletteWheel, { passive: false });
      }

      previewToggle.addEventListener("click", () => {
        state.previewVisible = !state.previewVisible;
        updatePreviewState();
        logDebug(state.previewVisible ? "Opened preview overlay" : "Closed preview overlay");
      });

      closePreviewButton.addEventListener("click", () => {
        state.previewVisible = false;
        updatePreviewState();
        logDebug("Closed preview overlay");
      });

      applyBtn.addEventListener("click", () => {
        if (applyBtn.disabled) return;
        logDebug("Regenerating puzzle with current generator settings");
        regenerateFromSource();
      });

      downloadBtn.addEventListener("click", () => {
        if (!state.puzzle) return;
        const payload = serializeCurrentPuzzle();
        const blob = new Blob([JSON.stringify(payload, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = `${payload.title ?? "color-by-number"}.json`;
        document.body.appendChild(link);
        link.click();
        requestAnimationFrame(() => {
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        });
        logDebug("Exported puzzle JSON");
      });

      saveSnapshotBtn.addEventListener("click", () => {
        if (!state.puzzle) return;
        saveCurrentSnapshot();
      });

      saveList.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        const entryEl = target.closest("[data-save-id]");
        if (!entryEl) return;
        const id = entryEl.getAttribute("data-save-id");
        if (!id) return;
        if (target.dataset.action === "load") {
          loadSaveEntry(id);
        } else if (target.dataset.action === "delete") {
          deleteSaveEntry(id);
        } else if (target.dataset.action === "export") {
          exportSaveEntry(id);
        } else if (target.dataset.action === "rename") {
          renameSaveEntry(id);
        }
      });

      colorCountEl.addEventListener("input", updateOptionOutputs);
      minRegionEl.addEventListener("input", updateOptionOutputs);
      detailEl.addEventListener("input", updateOptionOutputs);
      sampleRateEl.addEventListener("input", updateOptionOutputs);
      kmeansItersEl.addEventListener("input", updateOptionOutputs);
      smoothingEl.addEventListener("input", updateOptionOutputs);

      colorCountEl.addEventListener("change", markOptionsDirty);
      minRegionEl.addEventListener("change", markOptionsDirty);
      detailEl.addEventListener("change", markOptionsDirty);
      sampleRateEl.addEventListener("change", markOptionsDirty);
      kmeansItersEl.addEventListener("change", markOptionsDirty);
      smoothingEl.addEventListener("change", markOptionsDirty);

      function hasFiles(event) {
        const types = event.dataTransfer?.types;
        if (!types) return false;
        if (typeof types.includes === "function") {
          return types.includes("Files");
        }
        if (typeof types.contains === "function") {
          return types.contains("Files");
        }
        return Array.from(types).includes("Files");
      }

      let dragDepth = 0;
      window.addEventListener("dragenter", (event) => {
        if (!hasFiles(event)) return;
        dragDepth += 1;
        document.body.classList.add("dragging");
        event.preventDefault();
      });

      window.addEventListener("dragleave", (event) => {
        if (!hasFiles(event)) return;
        dragDepth = Math.max(0, dragDepth - 1);
        if (dragDepth === 0) {
          document.body.classList.remove("dragging");
        }
      });

      window.addEventListener("dragover", (event) => {
        if (!hasFiles(event)) return;
        event.preventDefault();
      });

      window.addEventListener("drop", (event) => {
        if (!hasFiles(event)) return;
        event.preventDefault();
        const file = event.dataTransfer?.files?.[0];
        dragDepth = 0;
        document.body.classList.remove("dragging");
        if (file) {
          handleFile(file);
        }
      });

      // Viewport gesture wiring (mouse + pen):
      // - pointerdown delegates to handlePanStart so modifier / middle / right clicks immediately
      //   kick off panning while primary-button drags become "candidates" until they travel a few
      //   pixels. That keeps simple taps available for the canvas click handler below.
      // - pointermove promotes a stored candidate into a full pan session (capturing the pointer)
      //   once it travels ~4px, then continuously applies deltas via handlePanMove.
      // - pointerup/pointercancel tear down the session and restore the grab cursor. We also listen
      //   for lostpointercapture so releasing the mouse outside the stage still resets state.
      const pointerSurface = canvasStage || puzzleCanvas;
      if (pointerSurface) {
        const pointerOptions = { capture: true };
        pointerSurface.addEventListener("pointerdown", handlePanStart, pointerOptions);
        pointerSurface.addEventListener("pointermove", handlePanMove, pointerOptions);
        pointerSurface.addEventListener("pointerup", handlePanEnd, pointerOptions);
        pointerSurface.addEventListener("pointercancel", handlePanEnd, pointerOptions);
        pointerSurface.addEventListener("lostpointercapture", handlePanEnd);
        pointerSurface.addEventListener("wheel", handleWheel, { passive: false });
        pointerSurface.addEventListener("contextmenu", (event) => event.preventDefault());
      }
      if (cursorOverlay && puzzleCanvas) {
        const handleCursorHover = (event) => updateCustomCursor(event);
        puzzleCanvas.addEventListener("pointermove", handleCursorHover);
        puzzleCanvas.addEventListener("pointerdown", handleCursorHover);
        puzzleCanvas.addEventListener("pointerenter", handleCursorHover);
        puzzleCanvas.addEventListener("pointerleave", hideCustomCursor);
        if (canvasStage) {
          canvasStage.addEventListener("pointerleave", hideCustomCursor);
        }
        if (viewportEl) {
          viewportEl.addEventListener("pointerleave", hideCustomCursor);
        }
        window.addEventListener("scroll", hideCustomCursor, { passive: true });
      }
      setupCustomCursorPreference();
      window.addEventListener("keydown", handleKeyDown, true);
      window.addEventListener("keyup", handleKeyUp, true);
      window.addEventListener("resize", () => handleViewportChange({ log: true }));
      if (window.visualViewport) {
        window.visualViewport.addEventListener("resize", () => handleViewportChange({ log: true }));
        window.visualViewport.addEventListener("scroll", () => handleViewportChange({ log: false }));
      }
      window.addEventListener("blur", () => {
        spacePressed = false;
        if (panPointerId != null) {
          try {
            canvasStage.releasePointerCapture(panPointerId);
          } catch (error) {}
        }
        panPointerId = null;
        panCandidate = null;
        if (isPanning) {
          document.body.classList.remove("panning");
          isPanning = false;
        }
        hideCustomCursor();
      });

      if (window.screen?.orientation && typeof window.screen.orientation.addEventListener === "function") {
        window.screen.orientation.addEventListener("change", () =>
          handleViewportChange({ log: true, recenter: true })
        );
      } else if (window.matchMedia) {
        const orientationQuery = window.matchMedia("(orientation: portrait)");
        const orientationListener = () => handleViewportChange({ log: true, recenter: true });
        if (typeof orientationQuery.addEventListener === "function") {
          orientationQuery.addEventListener("change", orientationListener);
        } else if (typeof orientationQuery.addListener === "function") {
          orientationQuery.addListener(orientationListener);
        }
      }

      // Puzzle fill interaction: click to paint if the region matches the active colour.
      puzzleCanvas.addEventListener("click", (event) => {
        if (!state.puzzle) {
          logDebug("Ignoring canvas click: no puzzle loaded yet");
          return;
        }
        if (state.activeColor == null) {
          logDebug("Ignoring canvas click: no active colour selected");
          return;
        }
        const rect = puzzleCanvas.getBoundingClientRect();
        const scaleX = puzzleCanvas.width / rect.width;
        const scaleY = puzzleCanvas.height / rect.height;
        const x = Math.floor((event.clientX - rect.left) * scaleX);
        const y = Math.floor((event.clientY - rect.top) * scaleY);
        const idx = y * puzzleCanvas.width + x;
        const regionId = state.puzzle.regionMap[idx];
        const region = state.puzzle.regions[regionId];
        if (!region) {
          logDebug("Ignoring canvas click: no region mapped under pointer");
          return;
        }
        if (state.filled.has(regionId)) {
          logDebug(`Region ${region.id} already filled; ignoring click`);
          return;
        }
        if (region.colorId !== state.activeColor) {
          const paletteColor = getPaletteEntry(region.colorId);
          if (state.settings.animateHints) {
            const tint = paletteColor ? rgbaFromHex(paletteColor.hex, 0.5) : "rgba(250, 204, 21, 0.55)";
            flashRegion(regionId, tint);
          }
          flashPaletteSwatch(region.colorId, { hex: paletteColor?.hex });
          logDebug(
            `Region ${region.id} expects colour #${region.colorId}; active colour is #${state.activeColor}`
          );
          return;
        }
        state.filled.add(regionId);
        applyRegionToImage(regionId);
        renderPuzzle();
        renderPalette();
        if (state.activeColor != null) {
          flashColorRegions(state.activeColor);
        }
        updateProgress();
        scheduleAutosave("fill-region");
        logDebug(
          `Filled region ${region.id} with colour #${region.colorId} (${state.filled.size}/${state.puzzle.regions.length})`
        );
        if (state.settings.autoAdvance) {
          autoAdvanceColor(region.colorId);
        }
        refreshCustomCursorHighlight();
      });

      function openSheet(sheet) {
        sheet.classList.remove("hidden");
        sheetBackdrop.classList.remove("hidden");
        document.body.classList.add("sheet-open");
      }

      function closeSheet(sheet) {
        sheet.classList.add("hidden");
        const sheets = [settingsSheet, saveSheet, helpSheet];
        const anyOpen = sheets.some((panel) => panel && !panel.classList.contains("hidden"));
        if (!anyOpen) {
          sheetBackdrop.classList.add("hidden");
          document.body.classList.remove("sheet-open");
        }
      }

      function closeAllSheets() {
        const sheets = [settingsSheet, saveSheet, helpSheet];
        for (const panel of sheets) {
          if (panel) {
            panel.classList.add("hidden");
          }
        }
        sheetBackdrop.classList.add("hidden");
        document.body.classList.remove("sheet-open");
      }

      function updatePreviewState() {
        if (state.previewVisible && state.puzzle) {
          previewOverlay.classList.remove("hidden");
          previewOverlay.setAttribute("aria-hidden", "false");
          previewToggle.setAttribute("aria-pressed", "true");
          previewToggle.setAttribute("aria-label", "Hide preview");
          previewToggle.title = "Hide preview";
          previewToggle.classList.add("active");
          hideCustomCursor();
        } else {
          previewOverlay.classList.add("hidden");
          previewOverlay.setAttribute("aria-hidden", "true");
          previewToggle.setAttribute("aria-pressed", "false");
          previewToggle.setAttribute("aria-label", "Show preview");
          previewToggle.title = "Show preview";
          previewToggle.classList.remove("active");
          refreshCustomCursorHighlight();
        }
      }

      function updateFullscreenState() {
        if (!fullscreenButton) return;
        const active = Boolean(document.fullscreenElement);
        fullscreenButton.classList.toggle("active", active);
        fullscreenButton.setAttribute("aria-pressed", active ? "true" : "false");
        fullscreenButton.setAttribute("aria-label", active ? "Exit fullscreen" : "Enter fullscreen");
        fullscreenButton.title = active ? "Exit fullscreen" : "Enter fullscreen";
        const icon = fullscreenButton.querySelector(".icon");
        if (icon) {
          icon.textContent = active ? "üóó" : "‚õ∂";
        }
        fullscreenButton.disabled = !document.fullscreenEnabled && !active;
      }

      function toggleFullscreen() {
        if (!fullscreenButton) return;
        if (document.fullscreenElement) {
          if (document.exitFullscreen) {
            document.exitFullscreen().catch((error) => {
              console.error("Failed to exit fullscreen", error);
              logDebug("Unable to exit fullscreen");
            });
          }
          return;
        }
        const target = appEl || document.documentElement;
        if (!document.fullscreenEnabled || !target?.requestFullscreen) {
          logDebug("Fullscreen not supported in this browser");
          return;
        }
        target.requestFullscreen().catch((error) => {
          console.error("Failed to enter fullscreen", error);
          logDebug("Fullscreen request was blocked");
        });
      }

      function syncComputedUiScale() {
        const root = document.documentElement;
        const userValue =
          typeof state?.settings?.uiScale === "number" ? state.settings.uiScale : 1;
        if (!root) {
          return userValue;
        }
        let autoValue = 1;
        if (typeof window !== "undefined" && window.getComputedStyle) {
          const styles = getComputedStyle(root);
          const parsed = Number.parseFloat(styles.getPropertyValue("--ui-scale-auto"));
          if (Number.isFinite(parsed)) {
            autoValue = parsed;
          }
        } else {
          const inlineAuto = Number.parseFloat(root.style.getPropertyValue("--ui-scale-auto"));
          if (Number.isFinite(inlineAuto)) {
            autoValue = inlineAuto;
          }
        }
        const combined = clamp(userValue * autoValue, 0.6, 1.8);
        root.style.setProperty("--ui-scale", combined.toFixed(4));
        return combined;
      }

      function updateViewportMetrics() {
        const viewport = window.visualViewport;
        const visualWidth = Math.round(
          viewport?.width || window.innerWidth || document.documentElement.clientWidth || 0
        );
        const visualHeight = Math.round(
          viewport?.height || window.innerHeight || document.documentElement.clientHeight || 0
        );
        const orientation = visualWidth >= visualHeight ? "landscape" : "portrait";
        document.documentElement.style.setProperty("--app-width", `${visualWidth}px`);
        document.documentElement.style.setProperty("--app-height", `${visualHeight}px`);
        if (appEl) {
          appEl.style.width = `${visualWidth}px`;
          appEl.style.height = `${visualHeight}px`;
        }
        const minSide = Math.max(1, Math.min(visualWidth, visualHeight));
        const padding = orientation === "portrait" ? Math.min(28, Math.max(16, Math.round(minSide * 0.06))) : 32;
        document.documentElement.style.setProperty("--viewport-padding", `${padding}px`);
        const autoScale = clamp(minSide / 880, 0.8, 1.1);
        document.documentElement.style.setProperty("--ui-scale-auto", autoScale.toFixed(3));
        if (document.body) {
          document.body.dataset.orientation = orientation;
          const compact = visualWidth < 720 || visualHeight < 540;
          document.body.classList.toggle("compact-commands", compact);
        }
        syncComputedUiScale();
        const changed = orientation !== lastViewportMetrics.orientation;
        const sizeChanged =
          visualWidth !== lastViewportMetrics.width || visualHeight !== lastViewportMetrics.height;
        lastViewportMetrics = { orientation, width: visualWidth, height: visualHeight };
        return { orientation, changed, sizeChanged, width: visualWidth, height: visualHeight };
      }

      function handleViewportChange(options = {}) {
        const { log = false, recenter = false } = options;
        const metrics = updateViewportMetrics();
        const orientationChanged = metrics.changed;
        if (orientationChanged) {
          logDebug(`Orientation changed to ${metrics.orientation}`);
        } else if (log && metrics.sizeChanged) {
          logDebug(`Viewport resized to ${metrics.width}√ó${metrics.height} (${metrics.orientation})`);
        }
        if (state.puzzle) {
          resetView({ preserveZoom: true, recenter: recenter || orientationChanged });
        }
        hideCustomCursor();
      }

      function applySampleDetailLevel(level, options = {}) {
        const { skipReload = false, skipLog = false, skipOptions = false } = options;
        const normalized = level && SAMPLE_DETAIL_LEVELS[level] ? level : DEFAULT_SAMPLE_DETAIL;
        const config = SAMPLE_DETAIL_LEVELS[normalized];
        if (!config) return null;
        const previousLevel = state.sampleDetailLevel;
        state.sampleDetailLevel = config.id;
        for (const button of sampleDetailButtons) {
          if (!button) continue;
          const targetLevel = button.dataset.detailLevel;
          const targetConfig = SAMPLE_DETAIL_LEVELS[targetLevel];
          if (targetConfig) {
            button.textContent = targetConfig.shortLabel;
            button.setAttribute("aria-label", targetConfig.ariaLabel);
            button.title = targetConfig.ariaLabel;
          }
          const isActive = targetLevel === config.id;
          button.setAttribute("aria-pressed", isActive ? "true" : "false");
        }
        for (const caption of sampleDetailCaptions) {
          if (caption) {
            caption.textContent = config.summary;
          }
        }
        for (const button of sampleButtons) {
          if (!button) continue;
          const labelBase = `Reload ${SAMPLE_ARTWORK.title}`;
          const detailSummary = config.summary || config.label;
          const titleText = detailSummary ? `${labelBase} ‚Äì ${detailSummary}` : `${labelBase} ‚Äì ${config.label}`;
          const ariaText = detailSummary ? `${labelBase} (${detailSummary})` : `${labelBase} (${config.label})`;
          button.title = titleText;
          button.setAttribute("aria-label", ariaText);
          if (config.approxRegions != null) {
            button.dataset.detailRegions = String(config.approxRegions);
          }
        }
        if (samplePreview) {
          const previewSummary = config.summary || config.label;
          samplePreview.title = previewSummary
            ? `${SAMPLE_ARTWORK.title} ‚Äì ${previewSummary}`
            : `${SAMPLE_ARTWORK.title} ‚Äì ${config.label}`;
          if (config.approxRegions != null) {
            samplePreview.dataset.detailRegions = String(config.approxRegions);
          }
        }
        if (!skipOptions) {
          const settings = config.settings || {};
          if (colorCountEl && typeof settings.targetColors === "number") {
            colorCountEl.value = String(settings.targetColors);
          }
          if (minRegionEl && typeof settings.minRegion === "number") {
            minRegionEl.value = String(settings.minRegion);
          }
          if (detailEl && typeof settings.maxSize === "number") {
            detailEl.value = String(settings.maxSize);
          }
          if (sampleRateEl && typeof settings.sampleRate === "number") {
            sampleRateEl.value = String(settings.sampleRate);
          }
          if (kmeansItersEl && typeof settings.kmeansIters === "number") {
            kmeansItersEl.value = String(settings.kmeansIters);
          }
          if (smoothingEl && typeof settings.smoothingPasses === "number") {
            smoothingEl.value = String(settings.smoothingPasses);
          }
          updateOptionOutputs();
          markOptionsDirty();
        }
        if (!skipLog && previousLevel !== config.id) {
          logDebug(`Sample detail set to ${config.label} ‚Äì ${config.summary}`);
        }
        if (!skipReload && state.sourceUrl === SAMPLE_ARTWORK.dataUrl) {
          loadSamplePuzzle({ detailLevel: config.id, skipDetailUpdate: true });
        }
        return config;
      }

      function loadSamplePuzzle(options = {}) {
        const { announce = true, detailLevel, skipDetailUpdate = false } = options;
        const { dataUrl } = SAMPLE_ARTWORK;
        if (!dataUrl) return;
        const targetLevel = detailLevel || state.sampleDetailLevel || DEFAULT_SAMPLE_DETAIL;
        const detailConfig = skipDetailUpdate
          ? SAMPLE_DETAIL_LEVELS[targetLevel] || SAMPLE_DETAIL_LEVELS[DEFAULT_SAMPLE_DETAIL]
          : applySampleDetailLevel(targetLevel, { skipReload: true, skipLog: !announce }) ||
            SAMPLE_DETAIL_LEVELS[targetLevel] ||
            SAMPLE_DETAIL_LEVELS[DEFAULT_SAMPLE_DETAIL];
        resetPuzzleUI();
        state.sourceUrl = dataUrl;
        state.sourceTitle = SAMPLE_ARTWORK.title || "Sample puzzle";
        startHint.classList.add("hidden");
        const label = detailConfig ? detailConfig.label : null;
        const logDescriptor = detailConfig?.logDescriptor || (label ? label.toLowerCase() : null);
        const loadOptions = announce
          ? {
              logMessage: logDescriptor
                ? `Loading ${logDescriptor} sample puzzle: ${state.sourceTitle}`
                : `Loading sample puzzle: ${state.sourceTitle}`,
              completionMessage: label
                ? `${label} sample puzzle ready: ${state.sourceTitle}`
                : `Loading sample puzzle complete: ${state.sourceTitle}`,
              skipDefaultLog: true,
            }
          : undefined;
        loadImage(dataUrl, loadOptions);
      }

      function updateCommandStates() {
        const hasPuzzle = Boolean(state.puzzle);
        hintButton.disabled = !hasPuzzle;
        resetButton.disabled = !hasPuzzle;
        previewToggle.disabled = !hasPuzzle;
        downloadBtn.disabled = !hasPuzzle;
        saveSnapshotBtn.disabled = !hasPuzzle;
        saveManagerButton.disabled = !hasPuzzle && state.saves.length === 0;
      }

      function renderDebugLog() {
        if (!debugLogEl) return;
        debugLogEl.innerHTML = "";
        if (debugLogEntries.length === 0) {
          const empty = document.createElement("p");
          empty.className = "log-empty";
          empty.textContent = "No events yet.";
          debugLogEl.appendChild(empty);
          return;
        }
        const fragment = document.createDocumentFragment();
        for (let index = debugLogEntries.length - 1; index >= 0; index -= 1) {
          const entry = debugLogEntries[index];
          const item = document.createElement("div");
          item.className = "log-entry";
          const time = document.createElement("time");
          time.dateTime = entry.iso;
          time.textContent = entry.display;
          const message = document.createElement("span");
          message.textContent = entry.message;
          item.appendChild(time);
          item.appendChild(message);
          fragment.appendChild(item);
        }
        debugLogEl.appendChild(fragment);
        debugLogEl.scrollTop = 0;
      }

      function logDebug(message) {
        if (message == null) return;
        const now = new Date();
        const entry = {
          iso: now.toISOString(),
          display: now.toLocaleTimeString([], {
            hour12: false,
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
          }),
          message: String(message),
        };
        debugLogEntries.push(entry);
        if (debugLogEntries.length > DEBUG_LOG_LIMIT) {
          debugLogEntries.splice(0, debugLogEntries.length - DEBUG_LOG_LIMIT);
        }
        renderDebugLog();
      }

      function applyUiScale(scale, options = {}) {
        const { skipLog = false, skipAutosave = false, force = false } = options;
        const numeric = Number(scale);
        const resolved = clamp(Number.isFinite(numeric) ? numeric : state.settings.uiScale || 1, 0.8, 1.35);
        const current = state.settings.uiScale ?? 1;
        const changed = force || Math.abs(resolved - current) > 0.001;
        state.settings.uiScale = resolved;
        document.documentElement.style.setProperty("--ui-scale-user", String(resolved));
        syncComputedUiScale();
        if (uiScaleInput && Math.abs(Number(uiScaleInput.value) - resolved) > 0.001) {
          uiScaleInput.value = String(resolved);
        }
        updateOptionOutputs();
        if (changed && !skipLog) {
          logDebug(`Interface scale set to ${Math.round(resolved * 100)}%`);
        }
        if (changed && !skipAutosave) {
          scheduleAutosave("settings-ui-scale");
        }
        return resolved;
      }

      function applyArtPrompt(text, options = {}) {
        const { skipLog = false, skipAutosave = false } = options;
        const normalized = typeof text === "string" ? text : "";
        const previous = state.settings.artPrompt ?? "";
        state.settings.artPrompt = normalized;
        if (artPromptInput && artPromptInput.value !== normalized) {
          artPromptInput.value = normalized;
        }
        if (normalized !== previous) {
          if (!skipLog) {
            const trimmed = normalized.trim();
            logDebug(trimmed ? `Art prompt updated (${trimmed.length} characters)` : "Art prompt cleared");
          }
          if (!skipAutosave) {
            scheduleAutosave("settings-art-prompt");
          }
        }
        return normalized;
      }

      function applyBackgroundColor(hex, options = {}) {
        const { skipRender = false, skipLog = false, force = false } = options;
        const current = state.settings.backgroundColor ?? DEFAULT_BACKGROUND_HEX;
        const normalized = sanitizeHexColor(hex, current);
        const changed = force || normalized !== current;
        state.settings.backgroundColor = normalized;
        backgroundPixel = [...hexToRgb(normalized), 255];
        backgroundInk = computeInkStyles(normalized);
        if (backgroundColorInput && backgroundColorInput.value !== normalized) {
          backgroundColorInput.value = normalized;
        }
        if (!changed) {
          return normalized;
        }
        if (!skipRender) {
          if (state.puzzle) {
            initializePuzzleImage();
            renderPuzzle();
          } else {
            puzzleCtx.save();
            puzzleCtx.fillStyle = normalized;
            puzzleCtx.fillRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);
            puzzleCtx.restore();
          }
        }
        if (changed && !skipLog) {
          logDebug(`Background colour set to ${normalized.toUpperCase()}`);
        }
        if (changed && !options.skipAutosave) {
          scheduleAutosave("background-colour");
        }
        return normalized;
      }

      function updateOptionOutputs() {
        if (optionOutputs.colorCount) optionOutputs.colorCount.textContent = String(colorCountEl.value);
        if (optionOutputs.minRegion) optionOutputs.minRegion.textContent = `${minRegionEl.value} px¬≤`;
        if (optionOutputs.detail) optionOutputs.detail.textContent = `${detailEl.value} px`;
        if (optionOutputs.sample) optionOutputs.sample.textContent = `${sampleRateEl.value}%`;
        if (optionOutputs.iterations) optionOutputs.iterations.textContent = String(kmeansItersEl.value);
        if (optionOutputs.smoothing) optionOutputs.smoothing.textContent = String(smoothingEl.value);
        if (optionOutputs.uiScale) {
          const source = uiScaleInput ? parseFloat(uiScaleInput.value) : NaN;
          const value = Number.isFinite(source) ? source : state.settings.uiScale || 1;
          optionOutputs.uiScale.textContent = `${Math.round(value * 100)}%`;
        }
      }

      function markOptionsDirty() {
        if (!state.puzzle || !state.sourceUrl) {
          applyBtn.disabled = true;
          return;
        }
        const current = getCurrentOptions();
        const last = state.lastOptions;
        const dirty =
          !last ||
          current.targetColors !== last.targetColors ||
          current.minRegion !== last.minRegion ||
          current.maxSize !== last.maxSize ||
          current.sampleRate !== last.sampleRate ||
          current.kmeansIters !== last.kmeansIters ||
          current.smoothingPasses !== last.smoothingPasses;
        applyBtn.disabled = !dirty;
      }

      function getCurrentOptions() {
        return {
          targetColors: clamp(Number(colorCountEl.value) || 16, 4, 64),
          minRegion: clamp(Number(minRegionEl.value) || 80, 1, 5000),
          maxSize: clamp(Number(detailEl.value) || 768, 256, 2000),
          sampleRate: clamp(Number(sampleRateEl.value) || 65, 10, 100) / 100,
          kmeansIters: clamp(Number(kmeansItersEl.value) || 12, 1, 64),
          smoothingPasses: clamp(Number(smoothingEl.value) || 1, 0, 6),
        };
      }

      function regenerateFromSource() {
        if (!state.sourceUrl) return;
        loadImage(state.sourceUrl);
      }

      function handleFile(file) {
        if (file.type === "application/json" || file.name.toLowerCase().endsWith(".json")) {
          resetPuzzleUI();
          const reader = new FileReader();
          reader.onload = () => {
            try {
              const payload = JSON.parse(reader.result);
              const providedTitle =
                typeof payload.title === "string" && payload.title.trim() ? payload.title.trim() : null;
              const fallbackTitle = file.name || "Imported puzzle";
              const resolvedTitle = providedTitle || fallbackTitle;
              state.sourceTitle = resolvedTitle;
              const applied = applyPuzzleResult(payload, {
                options: payload.options || getCurrentOptions(),
                filled: payload.filled,
                activeColor: payload.activeColor,
                backgroundColor: payload.backgroundColor,
                title: resolvedTitle,
              });
              if (applied) {
                startHint.classList.add("hidden");
                state.sourceUrl = payload.sourceUrl || null;
                logDebug(`Imported puzzle from JSON: ${resolvedTitle}`);
              } else {
                setProgressMessage("idle");
              }
            } catch (error) {
              console.error(error);
              setProgressMessage("idle");
            }
          };
          reader.onerror = () => {
            console.error("Unable to read that file.");
            setProgressMessage("idle");
          };
          reader.readAsText(file);
          return;
        }
        resetPuzzleUI();
        const reader = new FileReader();
        reader.onload = () => {
          const result = reader.result;
          if (typeof result === "string") {
            state.sourceUrl = result;
            state.sourceTitle = file.name || "Imported image";
            startHint.classList.add("hidden");
            logDebug(`Generating puzzle from image: ${state.sourceTitle}`);
            loadImage(result);
          } else {
            console.error("Unsupported file format");
            setProgressMessage("idle");
          }
        };
        reader.onerror = () => {
          console.error("Unable to read that file.");
          setProgressMessage("idle");
        };
        reader.readAsDataURL(file);
      }

      function loadImage(url, loadOptions = {}) {
        const { logMessage, completionMessage, skipDefaultLog } = loadOptions;
        if (logMessage) {
          logDebug(logMessage);
        }
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = async () => {
          try {
            const options = getCurrentOptions();
            const data = await createPuzzleData(img, options);
            const title = state.sourceTitle || "Generated puzzle";
            const applied = applyPuzzleResult(data, {
              options,
              title,
              backgroundColor: state.settings.backgroundColor,
              logMessage: completionMessage,
              skipDefaultLog,
            });
            if (!applied) {
              setProgressMessage("idle");
            }
          } catch (error) {
            console.error("Failed to create puzzle", error);
            setProgressMessage("idle");
          }
        };
        img.onerror = () => {
          console.error("Unable to read that image.");
          setProgressMessage("idle");
        };
        img.src = url;
      }

      function resetPuzzleUI() {
        if (colorFlashTimer) {
          clearTimeout(colorFlashTimer);
          colorFlashTimer = null;
        }
        delete canvasStage.dataset.flashingColor;
        state.puzzle = null;
        state.activeColor = null;
        state.filled = new Set();
        state.sourceUrl = null;
        state.sourceTitle = null;
        if (paletteEl) {
          paletteEl.innerHTML = "";
        }
        if (paletteSortEl) {
          paletteSortEl.disabled = true;
        }
        setProgressMessage("loading");
        puzzleCtx.clearRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);
        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        state.previewImageData = null;
        state.puzzleImageData = null;
        state.previewVisible = false;
        updatePreviewState();
        updateCommandStates();
        activeTouches.clear();
        pinchSession = null;
        panPointerId = null;
        panCandidate = null;
        isPanning = false;
        document.body.classList.remove("panning");
        resetView({ recenter: true });
        hideCustomCursor();
      }

      async function createPuzzleData(image, options) {
        const { targetColors, minRegion, maxSize, sampleRate, kmeansIters, smoothingPasses } = options;
        const scale = Math.min(maxSize / image.width, maxSize / image.height, 1);
        const width = Math.max(8, Math.round(image.width * scale));
        const height = Math.max(8, Math.round(image.height * scale));
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        ctx.drawImage(image, 0, 0, width, height);
        const imageData = ctx.getImageData(0, 0, width, height);
        const pixels = imageData.data;
        const { centroids, assignments } = kmeansQuantize(pixels, width, height, targetColors, kmeansIters, sampleRate);
        let workingAssignments = assignments;
        if (smoothingPasses > 0) {
          workingAssignments = smoothAssignments(assignments, width, height, smoothingPasses);
        }
        const { regionMap, regions } = segmentRegions(width, height, workingAssignments, minRegion);
        for (const region of regions) {
          let sumX = 0;
          let sumY = 0;
          for (const idx of region.pixels) {
            sumX += idx % width;
            sumY += (idx / width) | 0;
          }
          region.cx = sumX / region.pixelCount;
          region.cy = sumY / region.pixelCount;
          region.colorId += 1;
        }
        const palette = centroids.map((c, idx) => {
          const hex = `#${toHex(c[0])}${toHex(c[1])}${toHex(c[2])}`;
          return {
            id: idx + 1,
            hex,
            rgba: c,
            name: hex.toUpperCase(),
          };
        });
        return {
          width,
          height,
          palette,
          regions,
          regionMap,
        };
      }

      function applyPuzzleResult(data, metadata = {}) {
        if (!data || typeof data.width !== "number" || typeof data.height !== "number") {
          console.error("Puzzle data missing required dimensions.");
          setProgressMessage("idle");
          return false;
        }
        if (!Array.isArray(data.palette) || !Array.isArray(data.regions)) {
          console.error("Puzzle data missing palette information.");
          setProgressMessage("idle");
          return false;
        }
        const expectedCells = data.width * data.height;
        const regionMapSource =
          unpackRegionMap(data.regionMapPacked, expectedCells) ||
          unpackRegionMap(data.regionMap, expectedCells);
        if (!regionMapSource || regionMapSource.length !== expectedCells) {
          console.error("Puzzle data is inconsistent.");
          setProgressMessage("idle");
          return false;
        }
        let needsPixelHydration = false;
        for (const region of data.regions) {
          if (!Array.isArray(region.pixels) || region.pixels.length === 0) {
            needsPixelHydration = true;
            break;
          }
        }
        let hydratedPixels = null;
        if (needsPixelHydration) {
          hydratedPixels = new Map();
          for (let i = 0; i < data.regions.length; i++) {
            const region = data.regions[i];
            const resolvedId = region.id != null ? region.id : i;
            hydratedPixels.set(resolvedId, []);
          }
          for (let idx = 0; idx < regionMapSource.length; idx++) {
            const regionId = regionMapSource[idx];
            if (hydratedPixels.has(regionId)) {
              hydratedPixels.get(regionId).push(idx);
            }
          }
        }
        const palette = data.palette.map((entry, index) => {
          const hex = entry.hex ?? "#ffffff";
          const rgba = Array.isArray(entry.rgba) ? entry.rgba.slice(0, 3) : hexToRgb(hex);
          const providedName =
            typeof entry.name === "string" && entry.name.trim()
              ? entry.name.trim()
              : typeof entry.label === "string" && entry.label.trim()
              ? entry.label.trim()
              : typeof entry.title === "string" && entry.title.trim()
              ? entry.title.trim()
              : null;
          const id = entry.id ?? index + 1;
          const fallbackName = typeof hex === "string" ? hex.toUpperCase() : `Colour ${id}`;
          return {
            id,
            hex,
            rgba,
            name: providedName || fallbackName,
          };
        });
        const regions = data.regions.map((region, index) => {
          const resolvedId = region.id != null ? region.id : index;
          const pixelsSource =
            Array.isArray(region.pixels) && region.pixels.length > 0
              ? region.pixels
              : hydratedPixels?.get(resolvedId) || [];
          const pixels = Array.from(pixelsSource);
          const pixelCount = region.pixelCount ?? pixels.length;
          let cx = typeof region.cx === "number" ? region.cx : null;
          let cy = typeof region.cy === "number" ? region.cy : null;
          if (pixels.length && (cx == null || cy == null)) {
            let sumX = 0;
            let sumY = 0;
            for (const idx of pixels) {
              sumX += idx % data.width;
              sumY += (idx / data.width) | 0;
            }
            cx = sumX / pixels.length;
            cy = sumY / pixels.length;
          }
          return {
            id: resolvedId,
            colorId: region.colorId ?? 1,
            pixels,
            pixelCount,
            cx: cx ?? 0,
            cy: cy ?? 0,
          };
        });
        const regionMap = regionMapSource instanceof Int32Array
          ? regionMapSource
          : new Int32Array(regionMapSource);
        const metadataTitle =
          typeof metadata.title === "string" && metadata.title.trim() ? metadata.title.trim() : null;
        const completionLog =
          metadata.logMessage != null && metadata.logMessage !== ""
            ? String(metadata.logMessage)
            : null;
        const skipLoadLog = Boolean(metadata.skipDefaultLog);
        if (metadataTitle) {
          state.sourceTitle = metadataTitle;
        } else if (typeof data.title === "string" && data.title.trim()) {
          state.sourceTitle = data.title.trim();
        }
        const paletteIds = new Set(palette.map((entry) => entry.id));
        const requestedColor = metadata.activeColor ?? palette[0]?.id ?? null;
        const backgroundHex = sanitizeHexColor(
          metadata.backgroundColor ?? data.backgroundColor ?? state.settings.backgroundColor ?? DEFAULT_BACKGROUND_HEX,
          state.settings.backgroundColor ?? DEFAULT_BACKGROUND_HEX
        );
        state.puzzle = {
          width: data.width,
          height: data.height,
          palette,
          regions,
          regionMap,
        };
        state.puzzle.backgroundColor = backgroundHex;
        state.activeColor =
          requestedColor != null && paletteIds.has(requestedColor)
            ? requestedColor
            : palette[0]?.id ?? null;
        state.filled = new Set(metadata.filled ?? []);
        state.lastOptions = metadata.options ?? getCurrentOptions();
        const resolvedSettings = metadata.settings ?? data.settings;
        if (resolvedSettings) {
          applyGameplaySettings(resolvedSettings);
        }
        applyBackgroundColor(backgroundHex, { skipRender: true, skipLog: true });
        puzzleCanvas.width = data.width;
        puzzleCanvas.height = data.height;
        previewCanvas.width = data.width;
        previewCanvas.height = data.height;
        renderPreview();
        initializePuzzleImage();
        renderPuzzle();
        renderPalette();
        if (state.activeColor != null) {
          flashColorRegions(state.activeColor, { duration: 360 });
        }
        updateProgress();
        updateCommandStates();
        updatePreviewState();
        markOptionsDirty();
        const restoredViewport = metadata.viewport ?? data.viewport;
        if (!restoreViewport(restoredViewport)) {
          resetView({ recenter: true });
        }
        const paletteCount = palette.length;
        const regionCount = regions.length;
        const descriptor =
          metadataTitle ||
          (typeof data.title === "string" && data.title.trim()) ||
          (state.sourceTitle && state.sourceTitle.trim()) ||
          "Puzzle";
        if (completionLog) {
          logDebug(completionLog);
        } else if (!skipLoadLog) {
          logDebug(
            `Loaded ${descriptor} (${data.width}√ó${data.height}, ${paletteCount} colours, ${regionCount} regions)`
          );
        }
        scheduleAutosave("puzzle-load", { immediate: true });
        return true;
      }

      function loadPuzzleFixtureData(puzzle) {
        if (!puzzle) return false;
        resetPuzzleUI();
        const resolvedTitle =
          (typeof puzzle.name === "string" && puzzle.name.trim()) ||
          (typeof puzzle.title === "string" && puzzle.title.trim()) ||
          "Fixture puzzle";
        state.sourceTitle = resolvedTitle;
        const applied = applyPuzzleResult(puzzle, {
          options: getCurrentOptions(),
          filled: puzzle.filled,
          activeColor: puzzle.activeColor,
          backgroundColor: puzzle.backgroundColor,
          title: resolvedTitle,
        });
        if (applied) {
          startHint.classList.add("hidden");
        }
        return applied;
      }

      function renderPreview() {
        if (!state.puzzle) return;
        const { width, height, regions, palette } = state.puzzle;
        const imageData = previewCtx.createImageData(width, height);
        const data = imageData.data;
        for (const region of regions) {
          const color = palette[region.colorId - 1];
          if (!color) continue;
          const rgba = color.rgba;
          for (const idx of region.pixels) {
            const base = idx * 4;
            data[base] = rgba[0];
            data[base + 1] = rgba[1];
            data[base + 2] = rgba[2];
            data[base + 3] = 255;
          }
        }
        previewCtx.putImageData(imageData, 0, 0);
        state.previewImageData = imageData;
      }

      function initializePuzzleImage() {
        if (!state.puzzle) return;
        const { width, height } = state.puzzle;
        const imageData = new ImageData(width, height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          data[i] = backgroundPixel[0];
          data[i + 1] = backgroundPixel[1];
          data[i + 2] = backgroundPixel[2];
          data[i + 3] = backgroundPixel[3];
        }
        state.puzzleImageData = imageData;
        if (state.filled.size > 0) {
          applyFilledRegionsToImage();
        }
      }

      function applyFilledRegionsToImage() {
        if (!state.puzzle || !state.puzzleImageData) return;
        for (const regionId of state.filled) {
          applyRegionToImage(regionId);
        }
      }

      function applyRegionToImage(regionId) {
        if (!state.puzzle || !state.previewImageData || !state.puzzleImageData) return;
        const region = state.puzzle.regions[regionId];
        if (!region) return;
        const previewData = state.previewImageData.data;
        const targetData = state.puzzleImageData.data;
        for (const idx of region.pixels) {
          const base = idx * 4;
          targetData[base] = previewData[base];
          targetData[base + 1] = previewData[base + 1];
          targetData[base + 2] = previewData[base + 2];
          targetData[base + 3] = 255;
        }
      }

      function renderPuzzle() {
        if (!state.puzzle) return;
        const { width, height } = state.puzzle;
        if (
          !state.puzzleImageData ||
          state.puzzleImageData.width !== width ||
          state.puzzleImageData.height !== height
        ) {
          initializePuzzleImage();
        }
        if (state.puzzleImageData) {
          puzzleCtx.putImageData(state.puzzleImageData, 0, 0);
        } else {
          puzzleCtx.fillStyle = state.settings.backgroundColor || DEFAULT_BACKGROUND_HEX;
          puzzleCtx.fillRect(0, 0, width, height);
        }
        drawOutlines();
        drawNumbers();
      }

      function drawNumbers() {
        if (!state.puzzle) return;
        puzzleCtx.save();
        const fallbackNumberInk = backgroundInk.number;
        const fallbackOutlineInk = backgroundInk.outline;
        puzzleCtx.textAlign = "center";
        puzzleCtx.textBaseline = "middle";
        puzzleCtx.strokeStyle = fallbackOutlineInk;
        puzzleCtx.lineJoin = "round";
        puzzleCtx.lineCap = "round";
        for (const region of state.puzzle.regions) {
          if (state.filled.has(region.id)) continue;
          const layout = getRegionLabelLayout(region);
          if (!layout) continue;
          const paletteColor = getPaletteEntry(region.colorId);
          const regionInk =
            paletteColor?.hex && typeof paletteColor.hex === "string"
              ? rgbaFromHex(paletteColor.hex, 1)
              : fallbackNumberInk;
          puzzleCtx.fillStyle = regionInk;
          puzzleCtx.font = layout.font;
          if (layout.strokeWidth) {
            puzzleCtx.lineWidth = layout.strokeWidth;
            puzzleCtx.strokeText(layout.text, layout.x, layout.y);
          }
          puzzleCtx.fillText(layout.text, layout.x, layout.y);
        }
        puzzleCtx.restore();
      }

      function getRegionLabelLayout(region) {
        if (!region || !state.puzzle) return null;
        if (!region.labelLayout) {
          region.labelLayout = computeRegionLabelLayout(region);
        }
        return region.labelLayout;
      }

      function computeRegionLabelLayout(region) {
        if (!state.puzzle) return null;
        if (!Array.isArray(region.pixels) || region.pixels.length === 0) return null;
        const { width, height, regionMap } = state.puzzle;
        const bounds = ensureRegionBounds(region, width);
        if (!bounds) return null;
        const text = String(region.colorId);
        const area = Math.max(1, region.pixelCount || region.pixels.length);
        const MIN_LABEL_SIZE = 1.75;
        const MAX_LABEL_SIZE = 96;
        const safeWidth = Math.max(1, bounds.width - 0.75);
        const safeHeight = Math.max(1, bounds.height - 0.75);
        if (safeWidth <= 0 || safeHeight <= 0) return null;
        const approxCharacters = text.length <= 1 ? 1 : text.length * 0.62 + 0.4;
        const widthLimit = safeWidth / approxCharacters;
        const heightLimit = safeHeight * 0.92;
        const areaLimit = Math.sqrt(area) * 0.9;
        const theoreticalMax = Math.max(
          MIN_LABEL_SIZE + 0.15,
          Math.min(widthLimit, heightLimit, areaLimit, MAX_LABEL_SIZE)
        );
        const floorCandidate = Math.min(
          theoreticalMax,
          Math.max(MIN_LABEL_SIZE, Math.min(widthLimit, heightLimit, areaLimit * 0.92))
        );
        const minAttemptSize = Math.max(MIN_LABEL_SIZE, Math.min(floorCandidate, theoreticalMax));
        const attempts = [];
        let nextSize = theoreticalMax;
        while (nextSize >= minAttemptSize && attempts.length < 9) {
          attempts.push(nextSize);
          nextSize *= 0.86;
        }
        if (attempts.length === 0) {
          attempts.push(minAttemptSize);
        } else {
          const last = attempts[attempts.length - 1];
          if (last > minAttemptSize) {
            attempts.push(minAttemptSize);
          }
        }
        const smallest = Math.max(MIN_LABEL_SIZE, minAttemptSize * 0.88);
        if (attempts[attempts.length - 1] > smallest + 0.05) {
          attempts.push(smallest);
        }
        for (const size of attempts) {
          const metrics = measureLabelMetrics(text, size);
          if (!metrics) continue;
          if (metrics.paddedWidth > safeWidth + 2 || metrics.paddedHeight > safeHeight + 2) {
            continue;
          }
          const anchor = findRegionLabelAnchor(
            region,
            metrics.halfWidth,
            metrics.halfHeight,
            bounds,
            width,
            height,
            regionMap
          );
          if (anchor) {
            return {
              text,
              fontSize: size,
              font: metrics.font,
              x: anchor.x,
              y: anchor.y,
              strokeWidth: metrics.strokeWidth,
            };
          }
        }
        return null;
      }

      function ensureRegionBounds(region, width) {
        if (region.bounds && Number.isFinite(region.bounds.minX)) {
          return region.bounds;
        }
        const bounds = calculateRegionBounds(region.pixels, width);
        region.bounds = bounds;
        return bounds;
      }

      function calculateRegionBounds(pixels, width) {
        if (!Array.isArray(pixels) || pixels.length === 0) {
          return { minX: 0, maxX: 0, minY: 0, maxY: 0, width: 0, height: 0 };
        }
        let minX = width;
        let minY = Number.POSITIVE_INFINITY;
        let maxX = 0;
        let maxY = 0;
        for (const idx of pixels) {
          const x = idx % width;
          const y = (idx / width) | 0;
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
        if (!Number.isFinite(minY)) {
          return { minX: 0, maxX: 0, minY: 0, maxY: 0, width: 0, height: 0 };
        }
        return {
          minX,
          maxX,
          minY,
          maxY,
          width: maxX - minX + 1,
          height: maxY - minY + 1,
        };
      }

      function measureLabelMetrics(text, size) {
        if (!text || size <= 0) return null;
        const font = `${size}px "Inter", "Segoe UI", sans-serif`;
        puzzleCtx.font = font;
        const metrics = puzzleCtx.measureText(text);
        const textWidth = metrics.width || size;
        const ascent = metrics.actualBoundingBoxAscent || size * 0.78;
        const descent = metrics.actualBoundingBoxDescent || size * 0.22;
        const textHeight = ascent + descent;
        const strokeWidth = clamp(size * 0.18, 0.65, Math.max(2.6, size * 0.24));
        const paddingX = clamp(
          size <= 7 ? size * 0.26 : size * 0.32,
          0.85,
          Math.max(3.6, size * 0.42)
        );
        const paddingY = clamp(
          size <= 7 ? size * 0.22 : size * 0.28,
          0.7,
          Math.max(3, size * 0.36)
        );
        const paddedWidth = textWidth + paddingX * 2 + strokeWidth;
        const paddedHeight = textHeight + paddingY * 2 + strokeWidth;
        return {
          font,
          paddedWidth,
          paddedHeight,
          halfWidth: paddedWidth / 2,
          halfHeight: paddedHeight / 2,
          strokeWidth,
        };
      }

      function findRegionLabelAnchor(region, halfWidth, halfHeight, bounds, width, height, regionMap) {
        const marginX = Math.max(0, Math.ceil(halfWidth - 0.5));
        const marginY = Math.max(0, Math.ceil(halfHeight - 0.5));
        const minCenterX = Math.max(bounds.minX + halfWidth, halfWidth);
        const maxCenterX = Math.min(bounds.maxX + 1 - halfWidth, width - halfWidth);
        const minCenterY = Math.max(bounds.minY + halfHeight, halfHeight);
        const maxCenterY = Math.min(bounds.maxY + 1 - halfHeight, height - halfHeight);
        if (minCenterX > maxCenterX || minCenterY > maxCenterY) return null;
        const centroidX = Number.isFinite(region.cx)
          ? region.cx
          : (bounds.minX + bounds.maxX + 1) / 2;
        const centroidY = Number.isFinite(region.cy)
          ? region.cy
          : (bounds.minY + bounds.maxY + 1) / 2;
        const seen = new Set();
        const candidates = [];
        const addCandidate = (x, y, weight = 1) => {
          const clampedX = clamp(x, minCenterX, maxCenterX);
          const clampedY = clamp(y, minCenterY, maxCenterY);
          const key = `${clampedX.toFixed(3)}:${clampedY.toFixed(3)}`;
          if (seen.has(key)) return;
          seen.add(key);
          candidates.push({ x: clampedX, y: clampedY, weight });
        };
        addCandidate(centroidX, centroidY, 2);
        const minY = Math.max(bounds.minY + marginY, 0);
        const maxY = Math.min(bounds.maxY - marginY, height - 1);
        const startX = Math.max(bounds.minX, Math.floor(minCenterX - halfWidth));
        const endX = Math.min(bounds.maxX, Math.ceil(maxCenterX + halfWidth) - 1);
        for (let y = minY; y <= maxY; y++) {
          const rowOffset = y * width;
          let runStart = null;
          for (let x = startX; x <= endX; x++) {
            const belongs = regionMap[rowOffset + x] === region.id;
            if (belongs && runStart == null) {
              runStart = x;
            }
            const isRunEnd = !belongs || x === endX;
            if (runStart != null && isRunEnd) {
              const runEnd = belongs ? x : x - 1;
              const safeStart = Math.max(runStart, Math.floor(minCenterX - halfWidth));
              const safeEnd = Math.min(runEnd, Math.ceil(maxCenterX + halfWidth) - 1);
              if (safeStart <= safeEnd) {
                const runWidth = safeEnd - safeStart + 1;
                const rowY = y + 0.5;
                const centerX = safeStart + runWidth / 2;
                addCandidate(centerX, rowY, runWidth);
                if (runWidth > halfWidth * 2 + 1) {
                  const offset = Math.min(runWidth / 2 - 0.5, Math.max(1, halfWidth));
                  addCandidate(safeStart + 0.5 + offset, rowY, runWidth / 2);
                  addCandidate(safeEnd + 0.5 - offset, rowY, runWidth / 2);
                }
              }
              runStart = null;
            }
          }
        }
        if (candidates.length === 0) {
          for (let y = minY; y <= maxY; y++) {
            const rowOffset = y * width;
            for (let x = startX; x <= endX; x++) {
              if (regionMap[rowOffset + x] !== region.id) continue;
              addCandidate(x + 0.5, y + 0.5, 0.5);
            }
          }
        }
        candidates.sort((a, b) => {
          const aDist = (a.x - centroidX) * (a.x - centroidX) + (a.y - centroidY) * (a.y - centroidY);
          const bDist = (b.x - centroidX) * (b.x - centroidX) + (b.y - centroidY) * (b.y - centroidY);
          if (aDist === bDist) {
            return b.weight - a.weight;
          }
          return aDist - bDist;
        });
        let best = null;
        let bestScore = Number.POSITIVE_INFINITY;
        for (const candidate of candidates) {
          if (
            !rectangleFitsRegion(
              region.id,
              candidate.x,
              candidate.y,
              halfWidth,
              halfHeight,
              width,
              height,
              regionMap
            )
          ) {
            continue;
          }
          const dx = candidate.x - centroidX;
          const dy = candidate.y - centroidY;
          const slack = estimateAnchorSlack(
            region.id,
            candidate.x,
            candidate.y,
            halfWidth,
            halfHeight,
            width,
            height,
            regionMap
          );
          const score = dx * dx + dy * dy - slack * 4 - candidate.weight * 0.05;
          if (score < bestScore) {
            bestScore = score;
            best = { x: candidate.x, y: candidate.y };
            if (score <= 0) {
              break;
            }
          }
        }
        return best;
      }

      function rectangleFitsRegion(regionId, centerX, centerY, halfWidth, halfHeight, width, height, regionMap) {
        const minX = Math.max(0, Math.floor(centerX - halfWidth));
        const maxX = Math.min(width - 1, Math.ceil(centerX + halfWidth));
        const minY = Math.max(0, Math.floor(centerY - halfHeight));
        const maxY = Math.min(height - 1, Math.ceil(centerY + halfHeight));
        for (let y = minY; y <= maxY; y++) {
          const rowOffset = y * width;
          for (let x = minX; x <= maxX; x++) {
            if (regionMap[rowOffset + x] !== regionId) {
              return false;
            }
          }
        }
        return true;
      }

      function estimateAnchorSlack(regionId, centerX, centerY, halfWidth, halfHeight, width, height, regionMap) {
        let slack = 0;
        const steps = [0.25, 0.5, 0.75, 1, 1.5, 2];
        for (const step of steps) {
          if (
            rectangleFitsRegion(
              regionId,
              centerX,
              centerY,
              halfWidth + step,
              halfHeight + step,
              width,
              height,
              regionMap
            )
          ) {
            slack = step;
          } else {
            break;
          }
        }
        return slack;
      }

      function drawOutlines() {
        if (!state.puzzle) return;
        const { width, height, regionMap } = state.puzzle;
        puzzleCtx.fillStyle = backgroundInk.outline;
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            const id = regionMap[idx];
            const left = x > 0 ? regionMap[idx - 1] : id;
            const right = x < width - 1 ? regionMap[idx + 1] : id;
            const up = y > 0 ? regionMap[idx - width] : id;
            const down = y < height - 1 ? regionMap[idx + width] : id;
            if (left !== id || right !== id || up !== id || down !== id) {
              puzzleCtx.fillRect(x, y, 1, 1);
            }
          }
        }
      }

      function activateColor(colorId, options = {}) {
        if (!state.puzzle) return false;
        if (colorId == null) return false;
        const { flash = true, redraw = true } = options;
        const hasColour = state.puzzle.palette.some((entry) => entry.id === colorId);
        if (!hasColour) return false;
        const changed = state.activeColor !== colorId;
        state.activeColor = colorId;
        if (redraw) {
          renderPalette();
        }
        if (flash) {
          flashColorRegions(colorId);
        }
        const remaining = getRegionsByColor(colorId, { includeFilled: false }).length;
        const suffix = remaining > 0 ? `${remaining} regions remaining` : "complete";
        if (changed) {
          scheduleAutosave("color-select");
        }
        logDebug(`${changed ? "Selected" : "Re-selected"} colour #${colorId} (${suffix})`);
        refreshCustomCursorHighlight();
        return changed;
      }

      function renderPalette() {
        if (!paletteEl) return;
        paletteEl.innerHTML = "";
        if (!state.puzzle) {
          if (paletteSortEl) {
            paletteSortEl.disabled = true;
          }
          return;
        }
        if (paletteSortEl) {
          paletteSortEl.disabled = false;
        }
        const totalByColor = new Map();
        const remainingByColor = new Map();
        for (const region of state.puzzle.regions) {
          const total = totalByColor.get(region.colorId) || 0;
          totalByColor.set(region.colorId, total + 1);
          if (!state.filled.has(region.id)) {
            const remaining = remainingByColor.get(region.colorId) || 0;
            remainingByColor.set(region.colorId, remaining + 1);
          }
        }
        const paletteEntries = [...state.puzzle.palette];
        const sortMode = state.paletteSort || "region";
        const hueCache = new Map();
        const getHue = (color) => {
          if (!color) return 0;
          if (hueCache.has(color.id)) {
            return hueCache.get(color.id);
          }
          const value = hueFromHex(color.hex);
          hueCache.set(color.id, value);
          return value;
        };
        paletteEntries.sort((a, b) => {
          if (sortMode === "hue") {
            const hueDelta = getHue(a) - getHue(b);
            if (Math.abs(hueDelta) > 0.0001) {
              return hueDelta;
            }
            return a.id - b.id;
          }
          if (sortMode === "remaining") {
            const remainingDelta =
              (remainingByColor.get(b.id) || 0) - (remainingByColor.get(a.id) || 0);
            if (remainingDelta !== 0) {
              return remainingDelta;
            }
            const totalDelta = (totalByColor.get(b.id) || 0) - (totalByColor.get(a.id) || 0);
            if (totalDelta !== 0) {
              return totalDelta;
            }
            return a.id - b.id;
          }
          return a.id - b.id;
        });

        for (const color of paletteEntries) {
          const remaining = remainingByColor.get(color.id) || 0;
          const total = totalByColor.get(color.id) || 0;
          const labelText =
            (typeof color.name === "string" && color.name.trim()) ||
            (typeof color.hex === "string" ? color.hex.toUpperCase() : `Colour ${color.id}`);
          const swatch = document.createElement("button");
          swatch.type = "button";
          swatch.className = "swatch";
          swatch.dataset.testid = "palette-swatch";
          swatch.dataset.colorId = String(color.id);
          swatch.setAttribute("role", "listitem");
          swatch.setAttribute(
            "aria-label",
            `Colour ${color.id}: ${labelText}. ${remaining} of ${total} regions remaining.`
          );
          swatch.title = `${labelText} ¬∑ ${remaining} of ${total} remaining`;
          if (state.activeColor === color.id) swatch.classList.add("active");
          if (remaining === 0) swatch.classList.add("done");
          swatch.style.setProperty("--swatch-color", color.hex || "transparent");
          const labelStyles = computeSwatchLabelStyles(color.hex);
          swatch.style.setProperty("--swatch-label-color", labelStyles.color);
          swatch.style.setProperty("--swatch-label-border", labelStyles.border);
          swatch.style.setProperty("--swatch-label-shadow", labelStyles.shadow);
          swatch.style.setProperty("--swatch-label-text-shadow", labelStyles.textShadow);
          swatch.innerHTML = `
            <span class="label">
              <strong>${color.id}</strong>
            </span>
          `;
          swatch.addEventListener("click", () => {
            activateColor(color.id);
          });
          paletteEl.appendChild(swatch);
        }
      }

      function handlePaletteWheel(event) {
        if (!paletteEl) return;
        if (event.defaultPrevented) return;
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          return;
        }
        const { deltaX, deltaY, deltaMode } = event;
        if (Math.abs(deltaX) >= Math.abs(deltaY) || deltaY === 0) {
          return;
        }
        event.preventDefault();
        const WHEEL_DELTA_LINE = 1;
        const WHEEL_DELTA_PAGE = 2;
        let delta = deltaY;
        if (deltaMode === WHEEL_DELTA_LINE) {
          delta *= 24;
        } else if (deltaMode === WHEEL_DELTA_PAGE) {
          delta *= paletteEl.clientWidth;
        }
        paletteEl.scrollLeft += delta;
      }

      function setProgressMessage(status, customMessage) {
        const message =
          typeof customMessage === "string" && customMessage.length > 0
            ? customMessage
            : PROGRESS_MESSAGES[status] || PROGRESS_MESSAGES.idle;
        if (!progressEl) return;
        progressEl.textContent = message;
        progressEl.setAttribute("data-status", status || "idle");
      }

      function updateProgress() {
        if (!state.puzzle) {
          setProgressMessage("idle");
          if (paletteSortEl) {
            paletteSortEl.disabled = true;
          }
          return;
        }
        const total = state.puzzle.regions.length;
        const done = state.filled.size;
        if (!Number.isFinite(total) || total <= 0) {
          setProgressMessage("idle");
          return;
        }
        const remaining = Math.max(0, total - done);
        if (done >= total) {
          setProgressMessage("complete");
        } else {
          const summary = `${done} / ${total} filled ¬∑ ${remaining} remaining`;
          setProgressMessage("active", summary);
        }
      }

      function applyPaletteSort(sort, { skipLog } = {}) {
        const allowed = new Set(["region", "hue", "remaining"]);
        const next = allowed.has(sort) ? sort : "region";
        if (state.paletteSort === next) {
          if (paletteSortEl && paletteSortEl.value !== next) {
            paletteSortEl.value = next;
          }
          return;
        }
        state.paletteSort = next;
        if (paletteSortEl && paletteSortEl.value !== next) {
          paletteSortEl.value = next;
        }
        renderPalette();
        if (!skipLog) {
          const label =
            next === "hue"
              ? "colour hue"
              : next === "remaining"
              ? "remaining regions"
              : "region number";
          logDebug(`Palette sorted by ${label}`);
        }
      }

      function handleKeyDown(event) {
        const target = event.target;
        if (event.ctrlKey || event.metaKey) {
          return;
        }
        if (
          target instanceof HTMLInputElement ||
          target instanceof HTMLTextAreaElement ||
          (target instanceof HTMLElement && target.isContentEditable)
        ) {
          return;
        }

        if (event.code === "Space") {
          if (!event.repeat) {
            spacePressed = true;
          }
          if (
            target === document.body ||
            target === viewportEl ||
            target === canvasStage ||
            target === canvasTransform ||
            target === puzzleCanvas
          ) {
            event.preventDefault();
          }
          return;
        }

        if (!state.puzzle) return;

        const key = event.key;
        if (key === "+" || key === "=" || event.code === "Equal" || event.code === "NumpadAdd") {
          event.preventDefault();
          applyZoom(1.1);
          return;
        }

        if (key === "-" || event.code === "Minus" || event.code === "NumpadSubtract") {
          event.preventDefault();
          applyZoom(0.9);
        }
      }

      function handleKeyUp(event) {
        if (event.code === "Space") {
          spacePressed = false;
        }
      }

      function beginPanSession(pointerId, originX, originY, startPanX, startPanY) {
        panPointerId = pointerId;
        panOrigin.x = originX;
        panOrigin.y = originY;
        panOrigin.panX = startPanX;
        panOrigin.panY = startPanY;
        panCandidate = null;
        isPanning = true;
        document.body.classList.add("panning");
        logDebug("Began panning view");
        hideCustomCursor();
        try {
          canvasStage.setPointerCapture(pointerId);
        } catch (error) {}
      }

      function handlePanStart(event) {
        if (!state.puzzle) return;
        panCandidate = null;
        const isTouch = event.pointerType === "touch";
        if (isTouch) {
          event.preventDefault();
          hideCustomCursor();
          activeTouches.set(event.pointerId, { x: event.clientX, y: event.clientY });
          if (!pinchSession && activeTouches.size >= 2) {
            const entries = Array.from(activeTouches.entries()).slice(0, 2);
            const first = entries[0];
            const second = entries[1];
            if (first && second) {
              const a = first[1];
              const b = second[1];
              const distance = Math.max(10, Math.hypot(b.x - a.x, b.y - a.y));
              pinchSession = {
                ids: [first[0], second[0]],
                initialDistance: distance,
                initialZoom: viewState.zoom,
                initialPanX: viewState.panX,
                initialPanY: viewState.panY,
                centerX: (a.x + b.x) / 2,
                centerY: (a.y + b.y) / 2,
                hasChanged: false,
              };
              document.body.classList.add("panning");
              isPanning = true;
              logDebug("Pinch zoom started");
            }
          } else if (!pinchSession) {
            panCandidate = {
              pointerId: event.pointerId,
              startX: event.clientX,
              startY: event.clientY,
              panX: viewState.panX,
              panY: viewState.panY,
              pointerType: "touch",
            };
          }
          return;
        }
        const usesModifier = spacePressed || event.altKey || event.ctrlKey || event.metaKey;
        const auxButton = event.button === 1 || event.button === 2;
        if (auxButton || usesModifier) {
          event.preventDefault();
          beginPanSession(
            event.pointerId,
            event.clientX,
            event.clientY,
            viewState.panX,
            viewState.panY
          );
          return;
        }
        if (event.button === 0) {
          panCandidate = {
            pointerId: event.pointerId,
            startX: event.clientX,
            startY: event.clientY,
            panX: viewState.panX,
            panY: viewState.panY,
            pointerType: "mouse",
          };
        }
      }

      function handlePanMove(event) {
        const isTouch = event.pointerType === "touch";
        if (isTouch) {
          if (activeTouches.has(event.pointerId)) {
            activeTouches.set(event.pointerId, { x: event.clientX, y: event.clientY });
          }
          if (
            pinchSession &&
            pinchSession.ids.every((id) => activeTouches.has(id))
          ) {
            event.preventDefault();
            const [firstId, secondId] = pinchSession.ids;
            const first = activeTouches.get(firstId);
            const second = activeTouches.get(secondId);
            if (first && second) {
              const distance = Math.max(10, Math.hypot(second.x - first.x, second.y - first.y));
              const ratio = distance / pinchSession.initialDistance;
              const currentZoom = viewState.zoom;
              const targetZoom = clamp(pinchSession.initialZoom * ratio, 0.2, 6);
              if (Math.abs(targetZoom - currentZoom) > 0.0001) {
                pinchSession.hasChanged = true;
                const multiplier = targetZoom / currentZoom;
                const centerX = (first.x + second.x) / 2;
                const centerY = (first.y + second.y) / 2;
                applyZoom(multiplier, centerX, centerY, { skipLog: true });
              }
              const centerX = (first.x + second.x) / 2;
              const centerY = (first.y + second.y) / 2;
              viewState.panX = pinchSession.initialPanX + (centerX - pinchSession.centerX);
              viewState.panY = pinchSession.initialPanY + (centerY - pinchSession.centerY);
              applyViewTransform();
            }
            return;
          }
        }
        if (panPointerId === event.pointerId && isPanning) {
          event.preventDefault();
          const dx = event.clientX - panOrigin.x;
          const dy = event.clientY - panOrigin.y;
          viewState.panX = panOrigin.panX + dx;
          viewState.panY = panOrigin.panY + dy;
          applyViewTransform();
          return;
        }
        if (!panCandidate || panCandidate.pointerId !== event.pointerId) return;
        const dx = event.clientX - panCandidate.startX;
        const dy = event.clientY - panCandidate.startY;
        const distance = Math.hypot(dx, dy);
        const threshold = panCandidate.pointerType === "touch" ? 6 : 4;
        if (distance < threshold) return;
        event.preventDefault();
        beginPanSession(
          event.pointerId,
          panCandidate.startX,
          panCandidate.startY,
          panCandidate.panX,
          panCandidate.panY
        );
        panCandidate = null;
        handlePanMove(event);
      }

      function handlePanEnd(event) {
        if (event.pointerType === "touch") {
          activeTouches.delete(event.pointerId);
          if (pinchSession && !pinchSession.ids.every((id) => activeTouches.has(id))) {
            const changed = pinchSession.hasChanged;
            pinchSession = null;
            if (isPanning && panPointerId == null) {
              document.body.classList.remove("panning");
              isPanning = false;
            }
            if (changed) {
              logDebug(`Pinch zoom ended at ${(viewState.zoom * 100).toFixed(0)}%`);
            } else {
              logDebug("Pinch zoom ended");
            }
            if (activeTouches.size === 1) {
              const [nextId, point] = activeTouches.entries().next().value || [];
              if (nextId != null && point) {
                panCandidate = {
                  pointerId: nextId,
                  startX: point.x,
                  startY: point.y,
                  panX: viewState.panX,
                  panY: viewState.panY,
                  pointerType: "touch",
                };
              }
            }
          }
        }
        if (panCandidate && panCandidate.pointerId === event.pointerId) {
          panCandidate = null;
        }
        if (event.pointerId !== panPointerId) return;
        panPointerId = null;
        if (isPanning) {
          isPanning = false;
          document.body.classList.remove("panning");
          logDebug("Stopped panning view");
        }
        try {
          canvasStage.releasePointerCapture(event.pointerId);
        } catch (error) {}
        if (event.pointerType === "touch") {
          hideCustomCursor();
        } else {
          updateCustomCursor(event);
        }
      }

      function hideCustomCursor() {
        if (!cursorOverlay) return;
        cursorOverlay.classList.remove("active", "matching", "mismatch", "filled");
        cursorOverlay.style.setProperty("--cursor-x", "-9999px");
        cursorOverlay.style.setProperty("--cursor-y", "-9999px");
        cursorOverlay.style.removeProperty("--cursor-ring");
        cursorOverlay.style.removeProperty("--cursor-fill");
        cursorOverlay.style.removeProperty("--cursor-swatch");
        if (cursorNumberEl) {
          cursorNumberEl.textContent = "";
          cursorNumberEl.style.removeProperty("color");
        }
        cursorHoverRegionId = null;
        cursorLastClientX = null;
        cursorLastClientY = null;
      }

      function applyCustomCursor(region, paletteColor, clientX, clientY) {
        if (!cursorOverlay) return;
        const hasPoint = typeof clientX === "number" && typeof clientY === "number";
        if (hasPoint) {
          cursorLastClientX = clientX;
          cursorLastClientY = clientY;
        }
        cursorHoverRegionId = region.id;
        if (!document.body.classList.contains("custom-cursor")) {
          return;
        }
        if (cursorLastClientX == null || cursorLastClientY == null) {
          return;
        }
        cursorOverlay.style.setProperty("--cursor-x", `${cursorLastClientX}px`);
        cursorOverlay.style.setProperty("--cursor-y", `${cursorLastClientY}px`);
        const colorId = paletteColor?.id ?? region.colorId;
        if (cursorNumberEl) {
          cursorNumberEl.textContent = String(colorId);
          if (paletteColor?.hex) {
            cursorNumberEl.style.color = paletteColor.hex;
          } else {
            cursorNumberEl.style.removeProperty("color");
          }
        }
        const fillTint = paletteColor?.hex ? rgbaFromHex(paletteColor.hex, 0.3) : "rgba(148, 163, 184, 0.3)";
        const ringTint = paletteColor?.hex ? rgbaFromHex(paletteColor.hex, 0.85) : "rgba(226, 232, 240, 0.95)";
        cursorOverlay.style.setProperty("--cursor-fill", fillTint);
        cursorOverlay.style.setProperty("--cursor-ring", ringTint);
        cursorOverlay.style.setProperty("--cursor-swatch", paletteColor?.hex || "transparent");
        const isFilled = state.filled.has(region.id);
        const matchesActive =
          !isFilled && state.activeColor != null && state.activeColor === region.colorId;
        const mismatchActive =
          !isFilled && state.activeColor != null && state.activeColor !== region.colorId;
        cursorOverlay.classList.toggle("filled", isFilled);
        cursorOverlay.classList.toggle("matching", matchesActive);
        cursorOverlay.classList.toggle("mismatch", mismatchActive);
        cursorOverlay.classList.add("active");
      }

      function updateCustomCursor(event) {
        if (!cursorOverlay || !puzzleCanvas) return;
        if (!state.puzzle || state.previewVisible) {
          hideCustomCursor();
          return;
        }
        if (event && event.pointerType === "touch") {
          hideCustomCursor();
          return;
        }
        if (isPanning) {
          return;
        }
        const rect = puzzleCanvas.getBoundingClientRect();
        if (!rect || rect.width <= 0 || rect.height <= 0) {
          hideCustomCursor();
          return;
        }
        const withinX = event.clientX >= rect.left && event.clientX <= rect.right;
        const withinY = event.clientY >= rect.top && event.clientY <= rect.bottom;
        if (!withinX || !withinY) {
          hideCustomCursor();
          return;
        }
        const scaleX = puzzleCanvas.width / rect.width;
        const scaleY = puzzleCanvas.height / rect.height;
        const x = Math.floor((event.clientX - rect.left) * scaleX);
        const y = Math.floor((event.clientY - rect.top) * scaleY);
        if (x < 0 || y < 0 || x >= puzzleCanvas.width || y >= puzzleCanvas.height) {
          hideCustomCursor();
          return;
        }
        const idx = y * puzzleCanvas.width + x;
        const regionId = state.puzzle.regionMap[idx];
        const region = state.puzzle.regions[regionId];
        if (!region) {
          hideCustomCursor();
          return;
        }
        const paletteColor = getPaletteEntry(region.colorId);
        applyCustomCursor(region, paletteColor, event.clientX, event.clientY);
      }

      function refreshCustomCursorHighlight() {
        if (!cursorOverlay) return;
        if (cursorHoverRegionId == null) return;
        if (!state.puzzle) {
          hideCustomCursor();
          return;
        }
        const region = state.puzzle.regions[cursorHoverRegionId];
        if (!region) {
          hideCustomCursor();
          return;
        }
        const paletteColor = getPaletteEntry(region.colorId);
        applyCustomCursor(region, paletteColor);
      }

      function setupCustomCursorPreference() {
        if (!cursorOverlay) return;
        if (typeof window === "undefined") return;
        const applyPreference = (matches) => {
          if (matches) {
            document.body.classList.add("custom-cursor");
            refreshCustomCursorHighlight();
          } else {
            document.body.classList.remove("custom-cursor");
            hideCustomCursor();
          }
        };
        if (!window.matchMedia) {
          applyPreference(true);
          return;
        }
        const pointerQuery = window.matchMedia("(pointer: fine)");
        applyPreference(pointerQuery.matches);
        const listener = (event) => applyPreference(event.matches);
        if (typeof pointerQuery.addEventListener === "function") {
          pointerQuery.addEventListener("change", listener);
        } else if (typeof pointerQuery.addListener === "function") {
          pointerQuery.addListener(listener);
        }
      }

      function applyZoom(multiplier, clientX, clientY, options = {}) {
        if (!state.puzzle) return;
        const previousZoom = viewState.zoom;
        const nextZoom = clamp(previousZoom * multiplier, 0.2, 6);
        const change = nextZoom / previousZoom;
        if (!Number.isFinite(change) || change === 1) return;
        const significant = Math.abs(nextZoom - previousZoom) >= 0.01;
        const viewportRect = viewportEl.getBoundingClientRect();
        const centerX = viewportRect.left + viewportRect.width / 2;
        const centerY = viewportRect.top + viewportRect.height / 2;
        const anchorX = typeof clientX === "number" ? clientX : centerX;
        const anchorY = typeof clientY === "number" ? clientY : centerY;
        const offsetX = anchorX - centerX - viewState.panX;
        const offsetY = anchorY - centerY - viewState.panY;
        viewState.panX += offsetX - offsetX * change;
        viewState.panY += offsetY - offsetY * change;
        viewState.zoom = nextZoom;
        applyViewTransform();
        if (significant && !options.skipLog) {
          logDebug(`Zoom set to ${(viewState.zoom * 100).toFixed(0)}%`);
        }
      }

      function handleWheel(event) {
        if (!state.puzzle) return;
        event.preventDefault();
        const multiplier = event.deltaY > 0 ? 0.9 : 1.1;
        applyZoom(multiplier, event.clientX, event.clientY);
      }

      function applyViewTransform() {
        const zoomValue = Math.max(0.05, viewState.baseScale * viewState.zoom);
        canvasStage.style.setProperty("--pan-x", `${viewState.panX}px`);
        canvasStage.style.setProperty("--pan-y", `${viewState.panY}px`);
        canvasTransform.style.setProperty("--zoom", zoomValue.toFixed(4));
      }

      function computeFitScale() {
        if (!state.puzzle) return 1;
        const styles = window.getComputedStyle(viewportEl);
        const paddingX =
          parseFloat(styles.paddingLeft || "0") + parseFloat(styles.paddingRight || "0");
        const paddingY =
          parseFloat(styles.paddingTop || "0") + parseFloat(styles.paddingBottom || "0");
        const availableWidth = Math.max(1, viewportEl.clientWidth - paddingX);
        const availableHeight = Math.max(1, viewportEl.clientHeight - paddingY);
        const widthScale = availableWidth / state.puzzle.width;
        const heightScale = availableHeight / state.puzzle.height;
        const fit = Math.min(widthScale, heightScale);
        if (!Number.isFinite(fit) || fit <= 0) {
          return 1;
        }
        return fit;
      }

      function resetView(options = {}) {
        const { preserveZoom = false, recenter = false } = options;
        if (!state.puzzle) {
          viewState.panX = 0;
          viewState.panY = 0;
          viewState.zoom = 1;
          viewState.baseScale = 1;
          applyViewTransform();
          return;
        }
        const nextBase = computeFitScale();
        if (preserveZoom && viewState.baseScale > 0) {
          const ratio = nextBase / viewState.baseScale;
          if (Number.isFinite(ratio)) {
            viewState.panX *= ratio;
            viewState.panY *= ratio;
          }
          if (recenter) {
            viewState.panX = 0;
            viewState.panY = 0;
          }
        } else {
          viewState.panX = 0;
          viewState.panY = 0;
          viewState.zoom = 1;
        }
        if (recenter && !preserveZoom) {
          viewState.panX = 0;
          viewState.panY = 0;
        }
        viewState.baseScale = nextBase;
        applyViewTransform();
      }

      function restoreViewport(viewport = {}) {
        if (!state.puzzle) return false;
        if (!viewport || typeof viewport !== "object") return false;
        const hasZoom = typeof viewport.zoom === "number";
        const hasBase = typeof viewport.baseScale === "number";
        const hasPanX = typeof viewport.panX === "number";
        const hasPanY = typeof viewport.panY === "number";
        if (!hasZoom && !hasBase && !hasPanX && !hasPanY) return false;
        const nextBase = computeFitScale();
        const savedBase = hasBase && Number.isFinite(viewport.baseScale) && viewport.baseScale > 0
          ? viewport.baseScale
          : nextBase;
        const scaleRatio =
          savedBase && Number.isFinite(savedBase) && nextBase > 0 ? nextBase / savedBase : 1;
        const savedZoom = hasZoom && Number.isFinite(viewport.zoom) && viewport.zoom > 0
          ? viewport.zoom
          : 1;
        const targetZoom = Number.isFinite(scaleRatio) && scaleRatio > 0 ? savedZoom * scaleRatio : savedZoom;
        viewState.baseScale = nextBase;
        viewState.zoom = clamp(targetZoom, 0.2, 6);
        viewState.panX = hasPanX && Number.isFinite(viewport.panX) ? viewport.panX * scaleRatio : 0;
        viewState.panY = hasPanY && Number.isFinite(viewport.panY) ? viewport.panY * scaleRatio : 0;
        applyViewTransform();
        return true;
      }

      function useHint() {
        if (!state.puzzle) return;
        const candidates = state.puzzle.regions.filter((region) => !state.filled.has(region.id));
        if (candidates.length === 0) {
          logDebug("Hint requested, but puzzle is complete");
          return;
        }
        let target = candidates
          .filter((region) => region.colorId === state.activeColor)
          .sort((a, b) => a.pixelCount - b.pixelCount)[0];
        if (!target) {
          target = candidates.sort((a, b) => a.pixelCount - b.pixelCount)[0];
          activateColor(target.colorId, { flash: false });
        }
        if (state.settings.animateHints) {
          flashRegion(target.id, "rgba(59, 130, 246, 0.45)");
        }
        logDebug(`Hint spotlighted region ${target.id} (colour #${target.colorId})`);
      }

      function flashColorRegions(colorId, options = {}) {
        if (!state.puzzle) return;
        if (colorId == null) return;
        const paletteColor = getPaletteEntry(colorId);
        const duration =
          typeof options.duration === "number" && Number.isFinite(options.duration)
            ? options.duration
            : 280;
        const alpha =
          typeof options.alpha === "number" && Number.isFinite(options.alpha)
            ? clamp(options.alpha, 0.05, 1)
            : 0.45;
        const tint =
          options.tint ||
          (paletteColor ? rgbaFromHex(paletteColor.hex, alpha) : "rgba(96, 165, 250, 0.32)");
        const unfinished = getRegionsByColor(colorId, { includeFilled: false });
        const targets = unfinished.length > 0 ? unfinished : getRegionsByColor(colorId, { includeFilled: true });
        if (targets.length === 0) {
          delete canvasStage.dataset.flashingColor;
          return;
        }
        if (colorFlashTimer) {
          clearTimeout(colorFlashTimer);
          colorFlashTimer = null;
        }
        renderPuzzle();
        canvasStage.dataset.flashingColor = String(colorId);
        paintRegions(targets, tint);
        colorFlashTimer = window.setTimeout(() => {
          colorFlashTimer = null;
          delete canvasStage.dataset.flashingColor;
          renderPuzzle();
        }, duration);
      }

      function flashRegion(regionId, color) {
        if (!state.puzzle) return;
        const region = state.puzzle.regions[regionId];
        if (!region) return;
        paintRegions([region], color);
        window.setTimeout(() => {
          renderPuzzle();
        }, 220);
      }

      function autoAdvanceColor(currentColorId) {
        if (!state.puzzle) return;
        const remainingForColor = getRegionsByColor(currentColorId, { includeFilled: false });
        if (remainingForColor.length > 0) return;
        const nextColour = state.puzzle.palette.find((color) =>
          getRegionsByColor(color.id, { includeFilled: false }).length > 0
        );
        if (nextColour) {
          activateColor(nextColour.id);
        }
      }

      // Helper to collect regions for a colour with optional filtering of filled cells.
      function getRegionsByColor(colorId, options = {}) {
        const { includeFilled = true } = options;
        if (!state.puzzle) return [];
        return state.puzzle.regions.filter((region) => {
          if (region.colorId !== colorId) return false;
          if (!includeFilled && state.filled.has(region.id)) return false;
          return true;
        });
      }

      function getPaletteEntry(colorId) {
        if (!state.puzzle) return null;
        return state.puzzle.palette.find((entry) => entry.id === colorId) || null;
      }

      // Shared renderer for flashing overlays (hints + colour selection pulses).
      function paintRegions(regions, fillStyle) {
        if (!state.puzzle || regions.length === 0) return;
        puzzleCtx.save();
        puzzleCtx.fillStyle = fillStyle;
        for (const region of regions) {
          for (const idx of region.pixels) {
            const x = idx % state.puzzle.width;
            const y = (idx / state.puzzle.width) | 0;
            puzzleCtx.fillRect(x, y, 1, 1);
          }
        }
        puzzleCtx.restore();
      }

      function flashPaletteSwatch(colorId, options = {}) {
        if (!paletteEl) return;
        const swatch = paletteEl.querySelector(`.swatch[data-color-id="${colorId}"]`);
        if (!swatch) return;
        const hex = typeof options.hex === "string" && options.hex ? options.hex : null;
        if (hex) {
          swatch.style.setProperty("--flash-color", rgbaFromHex(hex, 0.6));
          swatch.style.setProperty("--flash-border", rgbaFromHex(hex, 0.95));
        } else {
          swatch.style.removeProperty("--flash-color");
          swatch.style.removeProperty("--flash-border");
        }
        swatch.classList.remove("flash");
        void swatch.offsetWidth;
        swatch.classList.add("flash");
        window.setTimeout(() => {
          swatch.classList.remove("flash");
          if (hex) {
            swatch.style.removeProperty("--flash-color");
            swatch.style.removeProperty("--flash-border");
          }
        }, 480);
      }

      function serializeCurrentPuzzle() {
        if (!state.puzzle) return {};
        const regionMapPacked = packRegionMap(state.puzzle.regionMap);
        const payload = {
          format: "capy-puzzle@2",
          title: state.sourceTitle || "capy-puzzle",
          width: state.puzzle.width,
          height: state.puzzle.height,
          palette: state.puzzle.palette.map((p) => ({
            id: p.id,
            hex: p.hex,
            rgba: p.rgba,
            name: p.name,
          })),
          regions: state.puzzle.regions.map((region) => ({
            id: region.id,
            colorId: region.colorId,
            pixelCount: region.pixelCount,
            cx: region.cx,
            cy: region.cy,
          })),
          filled: Array.from(state.filled),
          options: state.lastOptions,
          sourceUrl: state.sourceUrl,
          activeColor: state.activeColor,
          backgroundColor: state.settings.backgroundColor,
          viewport: {
            panX: viewState.panX,
            panY: viewState.panY,
            zoom: viewState.zoom,
            baseScale: viewState.baseScale,
          },
          settings: {
            autoAdvance: Boolean(state.settings.autoAdvance),
            animateHints: Boolean(state.settings.animateHints),
            uiScale: Number(state.settings.uiScale) || 1,
            artPrompt: state.settings.artPrompt || "",
          },
        };
        if (regionMapPacked) {
          payload.regionMapPacked = regionMapPacked;
        } else if (state.puzzle.regionMap) {
          payload.regionMap = Array.from(state.puzzle.regionMap);
        }
        return payload;
      }

      function scheduleAutosave(reason, options = {}) {
        if (!state.puzzle) return null;
        const { immediate = false, delay = 350 } = options;
        const resolvedReason = reason || pendingAutosaveReason || "update";
        if (immediate) {
          pendingAutosaveReason = null;
          if (autosaveTimer) {
            window.clearTimeout(autosaveTimer);
            autosaveTimer = null;
          }
          return persistAutosave(resolvedReason);
        }
        pendingAutosaveReason = resolvedReason;
        if (autosaveTimer) {
          window.clearTimeout(autosaveTimer);
        }
        const timeout = Math.max(120, delay);
        autosaveTimer = window.setTimeout(() => {
          autosaveTimer = null;
          const finalReason = pendingAutosaveReason || "update";
          pendingAutosaveReason = null;
          persistAutosave(finalReason);
        }, timeout);
        return null;
      }

      function persistAutosave(reason = "update") {
        if (!state.puzzle) return null;
        const snapshot = serializeCurrentPuzzle();
        const record = {
          version: 1,
          timestamp: Date.now(),
          reason,
          title: snapshot.title || state.sourceTitle || "capy-puzzle",
          data: snapshot,
        };
        try {
          localStorage.setItem(AUTOSAVE_STORAGE_KEY, JSON.stringify(record));
        } catch (error) {
          console.error("Failed to persist autosave", error);
          if (error && error.name === "QuotaExceededError") {
            logDebug("Storage full: unable to write autosave. Delete old saves or exports and retry.");
          }
        }
        if (cloudSync && typeof cloudSync.persist === "function") {
          cloudSync.persist(record);
        }
        return record;
      }

      function loadAutosave() {
        try {
          const raw = localStorage.getItem(AUTOSAVE_STORAGE_KEY);
          if (!raw) return null;
          const parsed = JSON.parse(raw);
          if (parsed && parsed.data) {
            return parsed;
          }
        } catch (error) {
          console.error("Failed to load autosave", error);
        }
        return null;
      }

      function getLatestBackupRecord() {
        const candidates = [];
        const autosave = loadAutosave();
        if (autosave && autosave.data) {
          candidates.push({ ...autosave, origin: "local autosave" });
        }
        const cloudRecord = cloudSync && typeof cloudSync.getSnapshot === "function"
          ? cloudSync.getSnapshot()
          : null;
        if (cloudRecord && cloudRecord.data) {
          candidates.push({ ...cloudRecord, origin: "cloud backup" });
        }
        if (Array.isArray(state.saves) && state.saves.length > 0) {
          const [latestManual] = [...state.saves].sort(
            (a, b) => (b.timestamp || 0) - (a.timestamp || 0)
          );
          if (latestManual && latestManual.data) {
            candidates.push({
              timestamp: latestManual.timestamp,
              data: latestManual.data,
              title: latestManual.title,
              origin: "manual save",
            });
          }
        }
        if (candidates.length === 0) return null;
        candidates.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
        return candidates[0];
      }

      function loadInitialSession() {
        const latest = getLatestBackupRecord();
        if (latest && latest.data) {
          const descriptor =
            latest.title ||
            latest.data.title ||
            state.sourceTitle ||
            "Puzzle";
          const applied = applyPuzzleResult(latest.data, {
            options: latest.data.options,
            filled: latest.data.filled,
            activeColor: latest.data.activeColor,
            backgroundColor: latest.data.backgroundColor,
            viewport: latest.data.viewport,
            settings: latest.data.settings,
            title: descriptor,
            logMessage: `Restoring ${descriptor} from backup`,
            skipDefaultLog: true,
          });
          if (applied) {
            state.sourceUrl = latest.data.sourceUrl ?? null;
            state.sourceTitle = descriptor;
            startHint.classList.add("hidden");
            logDebug(`Restored previous session from ${latest.origin || "backup storage"}`);
            return true;
          }
        }
        return false;
      }

      function packRegionMap(map) {
        if (!map || typeof map.length !== "number") return null;
        try {
          const typed =
            map instanceof Int32Array
              ? new Int32Array(map)
              : map instanceof Uint32Array
              ? new Int32Array(map)
              : new Int32Array(Array.from(map));
          const bytes = new Uint8Array(typed.buffer);
          let binary = "";
          for (let i = 0; i < bytes.length; i++) {
            binary += String.fromCharCode(bytes[i]);
          }
          return btoa(binary);
        } catch (error) {
          console.error("Failed to pack region map", error);
          return null;
        }
      }

      function unpackRegionMap(source, expectedLength) {
        if (!source) return null;
        try {
          if (typeof source === "string") {
            const binary = atob(source);
            const buffer = new ArrayBuffer(binary.length);
            const bytes = new Uint8Array(buffer);
            for (let i = 0; i < binary.length; i++) {
              bytes[i] = binary.charCodeAt(i);
            }
            if (typeof expectedLength === "number" && buffer.byteLength / 4 !== expectedLength) {
              return null;
            }
            return new Int32Array(buffer);
          }
          if (source instanceof Int32Array) {
            if (typeof expectedLength === "number" && source.length !== expectedLength) {
              return null;
            }
            return new Int32Array(source);
          }
          if (source instanceof Uint32Array) {
            const copy = new Int32Array(source);
            if (typeof expectedLength === "number" && copy.length !== expectedLength) {
              return null;
            }
            return copy;
          }
          if (Array.isArray(source) || ArrayBuffer.isView(source)) {
            const array = Array.isArray(source) ? source : Array.from(source);
            if (typeof expectedLength === "number" && array.length !== expectedLength) {
              return null;
            }
            return new Int32Array(array);
          }
        } catch (error) {
          console.error("Failed to unpack region map", error);
          return null;
        }
        return null;
      }

      function createCloudSync() {
        const subscribers = new Set();
        const key = CLOUD_STORAGE_KEY;
        let lastRecord = null;
        const hasBroadcast = typeof BroadcastChannel !== "undefined";
        const channel = hasBroadcast ? new BroadcastChannel("capy-cloud-sync") : null;

        function readFromStorage() {
          try {
            const raw = localStorage.getItem(key);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed !== "object") return null;
            return parsed;
          } catch (error) {
            console.error("Failed to read cloud backup", error);
            return null;
          }
        }

        function notify(record) {
          lastRecord = record || null;
          subscribers.forEach((listener) => {
            try {
              listener(lastRecord);
            } catch (error) {
              console.error("Cloud sync listener failed", error);
            }
          });
        }

        function writeRecord(record) {
          if (record == null) {
            try {
              localStorage.removeItem(key);
            } catch (error) {
              console.error("Failed to clear cloud backup", error);
            }
            notify(null);
            if (channel) {
              channel.postMessage({ type: "cloud-sync", record: null });
            }
            return null;
          }
          try {
            localStorage.setItem(key, JSON.stringify(record));
          } catch (error) {
            console.error("Failed to persist cloud backup", error);
          }
          notify(record);
          if (channel) {
            channel.postMessage({ type: "cloud-sync", record });
          }
          return record;
        }

        if (channel) {
          channel.addEventListener("message", (event) => {
            if (!event || typeof event.data !== "object") return;
            if ("record" in event.data) {
              notify(event.data.record);
            }
          });
        }

        if (typeof window !== "undefined") {
          window.addEventListener("storage", (event) => {
            if (event.key === key) {
              if (event.newValue) {
                try {
                  notify(JSON.parse(event.newValue));
                } catch (error) {
                  console.error("Failed to parse cloud backup update", error);
                }
              } else {
                notify(null);
              }
            }
          });
        }

        const api = {
          persist(record) {
            return writeRecord(record);
          },
          getSnapshot() {
            return lastRecord;
          },
          subscribe(listener) {
            if (typeof listener !== "function") return () => {};
            subscribers.add(listener);
            if (lastRecord) {
              try {
                listener(lastRecord);
              } catch (error) {
                console.error("Cloud sync listener failed", error);
              }
            }
            return () => subscribers.delete(listener);
          },
          clear() {
            writeRecord(null);
          },
          hydrate() {
            const record = readFromStorage();
            if (record) {
              notify(record);
            }
            return record;
          },
        };

        if (typeof window !== "undefined") {
          window.capyCloudSync = {
            persist: api.persist,
            getSnapshot: api.getSnapshot,
            subscribe: api.subscribe,
            clear: api.clear,
            hydrate: api.hydrate,
          };
        }

        api.hydrate();
        return api;
      }

      function saveCurrentSnapshot() {
        const payload = serializeCurrentPuzzle();
        const id = `save-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
        const entry = {
          id,
          title: `Puzzle ${new Date().toLocaleTimeString()}`,
          timestamp: Date.now(),
          data: payload,
        };
        state.saves.unshift(entry);
        persistSaves();
        refreshSaveList();
        scheduleAutosave("manual-save", { immediate: true });
        logDebug(`Saved snapshot: ${entry.title}`);
      }

      function refreshSaveList() {
        saveList.innerHTML = "";
        for (const entry of state.saves) {
          const item = document.createElement("li");
          item.className = "save-entry";
          item.dataset.saveId = entry.id;
          const date = new Date(entry.timestamp);
          const doneCount = entry.data?.filled?.length ?? 0;
          const total = entry.data?.regions?.length ?? 0;
          item.innerHTML = `
            <header>
              <strong>${entry.title || "Untitled puzzle"}</strong>
              <time>${date.toLocaleString()}</time>
            </header>
            <div>${doneCount} of ${total} regions filled</div>
            <div class="save-actions">
              <button type="button" data-action="load">Load</button>
              <button type="button" data-action="rename">Rename</button>
              <button type="button" data-action="export">Export</button>
              <button type="button" data-action="delete">Delete</button>
            </div>
          `;
          saveList.appendChild(item);
        }
        updateCommandStates();
      }

      function persistSaves() {
        try {
          localStorage.setItem(SAVE_STORAGE_KEY, JSON.stringify(state.saves));
        } catch (error) {
          console.error("Failed to persist saves", error);
          if (error && error.name === "QuotaExceededError") {
            logDebug("Storage full: unable to write save snapshot. Delete old saves or exports and retry.");
          }
        }
      }

      function loadSavedEntries() {
        try {
          const raw = localStorage.getItem(SAVE_STORAGE_KEY);
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return [];
          return parsed.filter((entry) => entry && entry.data);
        } catch (error) {
          console.error("Failed to load saves", error);
          return [];
        }
      }

      function loadSaveEntry(id) {
        const entry = state.saves.find((item) => item.id === id);
        if (!entry) return;
        if (
          applyPuzzleResult(entry.data, {
            options: entry.data.options,
            filled: entry.data.filled,
            activeColor: entry.data.activeColor,
            backgroundColor: entry.data.backgroundColor,
            viewport: entry.data.viewport,
            settings: entry.data.settings,
            title: entry.title || entry.data.title,
          })
        ) {
          state.sourceUrl = entry.data.sourceUrl ?? null;
          state.sourceTitle = entry.title || state.sourceTitle;
          startHint.classList.add("hidden");
          logDebug(`Loaded save: ${entry.title || "Untitled puzzle"}`);
        }
      }

      function deleteSaveEntry(id) {
        const entry = state.saves.find((item) => item.id === id);
        state.saves = state.saves.filter((item) => item.id !== id);
        persistSaves();
        refreshSaveList();
        logDebug(`Deleted save: ${(entry && entry.title) || id}`);
      }

      function renameSaveEntry(id) {
        const entry = state.saves.find((item) => item.id === id);
        if (!entry) return;
        const next = prompt("Rename save", entry.title || "Untitled puzzle");
        if (typeof next === "string" && next.trim()) {
          entry.title = next.trim();
          entry.timestamp = Date.now();
          persistSaves();
          refreshSaveList();
          logDebug(`Renamed save to: ${entry.title}`);
        }
      }

      function exportSaveEntry(id) {
        const entry = state.saves.find((item) => item.id === id);
        if (!entry) return;
        const blob = new Blob([JSON.stringify(entry.data, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = `${entry.title || "capy-save"}.json`;
        document.body.appendChild(link);
        link.click();
        requestAnimationFrame(() => {
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        });
        logDebug(`Exported save: ${entry.title || "capy-save"}`);
      }

      function serializeAssignments(pixels, centroids) {
        const assignments = new Uint16Array(pixels.length / 4);
        for (let i = 0; i < assignments.length; i++) {
          const base = i * 4;
          let best = 0;
          let bestDist = Infinity;
          for (let c = 0; c < centroids.length; c++) {
            const centroid = centroids[c];
            const dr = pixels[base] - centroid[0];
            const dg = pixels[base + 1] - centroid[1];
            const db = pixels[base + 2] - centroid[2];
            const dist = dr * dr + dg * dg + db * db;
            if (dist < bestDist) {
              bestDist = dist;
              best = c;
            }
          }
          assignments[i] = best;
        }
        return assignments;
      }

      function kmeansQuantize(pixels, width, height, targetColors, iterations, sampleRate) {
        const totalPixels = width * height;
        const sampleCount = Math.max(targetColors * 4, Math.floor(totalPixels * clamp(sampleRate, 0.05, 1)));
        const sampleIndexes = new Uint32Array(Math.min(sampleCount, totalPixels));
        const step = Math.max(1, Math.floor(totalPixels / sampleIndexes.length));
        let pointer = 0;
        for (let idx = 0; idx < totalPixels && pointer < sampleIndexes.length; idx += step) {
          sampleIndexes[pointer++] = idx;
        }
        while (pointer < sampleIndexes.length) {
          sampleIndexes[pointer++] = Math.floor(Math.random() * totalPixels);
        }
        const centroids = [];
        for (let i = 0; i < targetColors; i++) {
          const sampleIdx = sampleIndexes[i % sampleIndexes.length];
          const base = sampleIdx * 4;
          centroids.push([
            pixels[base],
            pixels[base + 1],
            pixels[base + 2],
          ]);
        }
        const sampleAssignments = new Uint16Array(sampleIndexes.length);
        for (let iter = 0; iter < iterations; iter++) {
          for (let i = 0; i < sampleIndexes.length; i++) {
            const base = sampleIndexes[i] * 4;
            let best = 0;
            let bestDist = Infinity;
            for (let c = 0; c < centroids.length; c++) {
              const centroid = centroids[c];
              const dr = pixels[base] - centroid[0];
              const dg = pixels[base + 1] - centroid[1];
              const db = pixels[base + 2] - centroid[2];
              const dist = dr * dr + dg * dg + db * db;
              if (dist < bestDist) {
                bestDist = dist;
                best = c;
              }
            }
            sampleAssignments[i] = best;
          }
          const sums = Array.from({ length: centroids.length }, () => [0, 0, 0, 0]);
          for (let i = 0; i < sampleIndexes.length; i++) {
            const base = sampleIndexes[i] * 4;
            const target = sampleAssignments[i];
            const bucket = sums[target];
            bucket[0] += pixels[base];
            bucket[1] += pixels[base + 1];
            bucket[2] += pixels[base + 2];
            bucket[3] += 1;
          }
          for (let c = 0; c < centroids.length; c++) {
            const bucket = sums[c];
            if (bucket[3] === 0) continue;
            centroids[c][0] = bucket[0] / bucket[3];
            centroids[c][1] = bucket[1] / bucket[3];
            centroids[c][2] = bucket[2] / bucket[3];
          }
        }
        const rounded = centroids.map((c) => c.map((value) => Math.round(value)));
        const assignments = serializeAssignments(pixels, rounded);
        return { centroids: rounded, assignments };
      }

      function smoothAssignments(assignments, width, height, passes) {
        let current = new Uint16Array(assignments);
        for (let pass = 0; pass < passes; pass++) {
          const next = new Uint16Array(current);
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const idx = y * width + x;
              const histogram = new Map();
              const baseColor = current[idx];
              histogram.set(baseColor, (histogram.get(baseColor) || 0) + 2);
              if (x > 0) accumulate(histogram, current[idx - 1]);
              if (x < width - 1) accumulate(histogram, current[idx + 1]);
              if (y > 0) accumulate(histogram, current[idx - width]);
              if (y < height - 1) accumulate(histogram, current[idx + width]);
              let bestColor = baseColor;
              let bestScore = -Infinity;
              for (const [color, score] of histogram.entries()) {
                if (score > bestScore) {
                  bestScore = score;
                  bestColor = color;
                }
              }
              next[idx] = bestColor;
            }
          }
          current = next;
        }
        return current;
      }

      function accumulate(histogram, color) {
        histogram.set(color, (histogram.get(color) || 0) + 1);
      }

      function segmentRegions(width, height, assignments, minRegion) {
        const indexMap = new Uint16Array(assignments);
        let attempt = 0;
        let threshold = Math.max(1, minRegion);
        while (true) {
          const { regionMap, regions } = floodFill(width, height, indexMap);
          const tiny = regions.filter((region) => region.pixelCount < threshold);
          if (tiny.length === 0 || threshold <= 1) {
            return { regionMap, regions };
          }
          let changed = false;
          for (const region of tiny) {
            const colorVotes = new Map();
            for (const idx of region.pixels) {
              const x = idx % width;
              const y = (idx / width) | 0;
              const neighbors = neighborIndexes(x, y, width, height);
              for (const n of neighbors) {
                const color = indexMap[n];
                if (color === region.colorId) continue;
                colorVotes.set(color, (colorVotes.get(color) || 0) + 1);
              }
            }
            if (colorVotes.size === 0) continue;
            let bestColor = region.colorId;
            let bestVotes = -1;
            for (const [color, votes] of colorVotes.entries()) {
              if (votes > bestVotes) {
                bestVotes = votes;
                bestColor = color;
              }
            }
            if (bestColor !== region.colorId) {
              changed = true;
              for (const idx of region.pixels) {
                indexMap[idx] = bestColor;
              }
            }
          }
          attempt += 1;
          if (!changed || attempt > 6) {
            threshold = Math.max(1, Math.floor(threshold / 2));
          }
        }
      }

      function floodFill(width, height, indexMap) {
        const regionMap = new Int32Array(width * height);
        regionMap.fill(-1);
        const regions = [];
        let regionId = 0;
        const stack = [];
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const startIdx = y * width + x;
            if (regionMap[startIdx] !== -1) continue;
            const colorId = indexMap[startIdx];
            stack.push(startIdx);
            regionMap[startIdx] = regionId;
            const pixels = [];
            while (stack.length) {
              const idx = stack.pop();
              pixels.push(idx);
              const px = idx % width;
              const py = (idx / width) | 0;
              const neighbors = neighborIndexes(px, py, width, height);
              for (const n of neighbors) {
                if (regionMap[n] !== -1) continue;
                if (indexMap[n] !== colorId) continue;
                regionMap[n] = regionId;
                stack.push(n);
              }
            }
            regions.push({
              id: regionId,
              colorId,
              pixels,
              pixelCount: pixels.length,
            });
            regionId += 1;
          }
        }
        return { regionMap, regions };
      }

      function neighborIndexes(x, y, width, height) {
        const neighbors = [];
        if (x > 0) neighbors.push(y * width + (x - 1));
        if (x < width - 1) neighbors.push(y * width + (x + 1));
        if (y > 0) neighbors.push((y - 1) * width + x);
        if (y < height - 1) neighbors.push((y + 1) * width + x);
        return neighbors;
      }

      function sanitizeHexColor(value, fallback = DEFAULT_BACKGROUND_HEX) {
        if (typeof value !== "string") return fallback;
        const trimmed = value.trim();
        if (/^#[0-9a-fA-F]{6}$/.test(trimmed)) {
          return `#${trimmed.slice(1).toLowerCase()}`;
        }
        if (/^[0-9a-fA-F]{6}$/.test(trimmed)) {
          return `#${trimmed.toLowerCase()}`;
        }
        return fallback;
      }

      function computeInkStyles(hex) {
        const [r, g, b] = hexToRgb(hex);
        const luminance = relativeLuminance([r, g, b]);
        if (luminance < 0.45) {
          return {
            outline: "rgba(248, 250, 252, 0.75)",
            number: "rgba(248, 250, 252, 0.95)",
          };
        }
        return {
          outline: "rgba(15, 23, 42, 0.65)",
          number: "rgba(15, 23, 42, 0.95)",
        };
      }

      function computeSwatchLabelStyles(hex) {
        const lightLabel = {
          color: "rgba(15, 23, 42, 0.9)",
          border: "rgba(15, 23, 42, 0.38)",
          shadow: "0 1px 0 rgba(248, 250, 252, 0.55)",
          textShadow: "0 1px 0 rgba(255, 255, 255, 0.65)",
        };
        const darkLabel = {
          color: "rgba(248, 250, 252, 0.98)",
          border: "rgba(248, 250, 252, 0.55)",
          shadow: "0 1px 0 rgba(2, 6, 23, 0.7)",
          textShadow: "0 1px 1px rgba(2, 6, 23, 0.76)",
        };
        const sanitizedHex = sanitizeHexColor(hex, DEFAULT_BACKGROUND_HEX);
        const [r, g, b] = hexToRgb(sanitizedHex);
        const luminance = relativeLuminance([r, g, b]);
        const lightBackgroundLuminance = relativeLuminance([248, 250, 252]);
        const darkBackgroundLuminance = relativeLuminance([15, 23, 42]);
        if (!Number.isFinite(luminance)) {
          return darkLabel;
        }
        if (luminance <= 0.35) {
          return lightLabel;
        }
        if (luminance >= 0.6) {
          return darkLabel;
        }
        const contrastWithDark = contrastRatio(luminance, darkBackgroundLuminance);
        const contrastWithLight = contrastRatio(luminance, lightBackgroundLuminance);
        return contrastWithDark >= contrastWithLight ? darkLabel : lightLabel;
      }

      function relativeLuminance([r, g, b]) {
        const toLinear = (channel) => {
          const value = channel / 255;
          return value <= 0.03928 ? value / 12.92 : Math.pow((value + 0.055) / 1.055, 2.4);
        };
        const linearR = toLinear(r);
        const linearG = toLinear(g);
        const linearB = toLinear(b);
        return 0.2126 * linearR + 0.7152 * linearG + 0.0722 * linearB;
      }

      function contrastRatio(l1, l2) {
        const lighter = Math.max(l1, l2);
        const darker = Math.min(l1, l2);
        return (lighter + 0.05) / (darker + 0.05);
      }

      function hueFromHex(hex) {
        const [r, g, b] = hexToRgb(hex);
        const rn = r / 255;
        const gn = g / 255;
        const bn = b / 255;
        const max = Math.max(rn, gn, bn);
        const min = Math.min(rn, gn, bn);
        const delta = max - min;
        if (delta === 0) {
          return 0;
        }
        let hue;
        if (max === rn) {
          hue = (gn - bn) / delta + (gn < bn ? 6 : 0);
        } else if (max === gn) {
          hue = (bn - rn) / delta + 2;
        } else {
          hue = (rn - gn) / delta + 4;
        }
        hue *= 60;
        return Number.isFinite(hue) ? hue : 0;
      }

      function hexToRgb(hex) {
        if (typeof hex !== "string") return [255, 255, 255];
        const normalized = hex.replace("#", "").trim();
        if (normalized.length !== 6) {
          return [255, 255, 255];
        }
        const r = parseInt(normalized.slice(0, 2), 16);
        const g = parseInt(normalized.slice(2, 4), 16);
        const b = parseInt(normalized.slice(4, 6), 16);
        return [r, g, b];
      }

      function rgbaFromHex(hex, alpha = 1) {
        const [r, g, b] = hexToRgb(hex);
        const normalized = clamp(alpha, 0, 1);
        return `rgba(${r}, ${g}, ${b}, ${normalized})`;
      }

      function clamp(value, min, max) {
        if (Number.isNaN(value)) return min;
        if (value < min) return min;
        if (value > max) return max;
        return value;
      }

      function toHex(value) {
        return value.toString(16).padStart(2, "0");
      }
    </script>
  </body>
</html>
