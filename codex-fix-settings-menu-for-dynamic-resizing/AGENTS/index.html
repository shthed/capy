<!DOCTYPE html>
        <html lang="en">
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <title>Capy Agent Guide</title>
          <style>
            :root {
              color-scheme: light dark;
            }
            body {
              font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", sans-serif;
              margin: 0 auto;
              padding: 32px 16px 48px;
              max-width: 920px;
              line-height: 1.6;
              background: #f6f8fa;
              color: #1f2328;
            }
            a {
              color: #0969da;
            }
            .markdown-body {
              background: #fff;
              border-radius: 12px;
              padding: 32px;
              box-shadow: 0 16px 40px rgba(15, 23, 42, 0.08);
              border: 1px solid #d0d7de;
            }
            .page-meta {
              margin-top: 24px;
              font-size: 0.85em;
              color: #57606a;
              text-align: center;
            }
            pre {
              background: #0d1117;
              color: #f0f6fc;
              padding: 16px;
              border-radius: 8px;
              overflow-x: auto;
            }
            code {
              font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
            }
            @media (max-width: 720px) {
              .markdown-body {
                padding: 24px 20px;
              }
            }
          </style>
        </head>
        <body>
          <main class="markdown-body">
            <h1 dir="auto">Agent Instructions</h1>
    <p dir="auto">Capy lives at <a href="https://shthed.github.io/capy/" rel="nofollow">https://shthed.github.io/capy/</a> (repo: <a href="https://github.com/shthed/capy">https://github.com/shthed/capy</a>).</p>
    <p dir="auto">This file focuses on how we work. For technical architecture, UI behaviour, and<br>
    file-by-file references, consult <a href="./TECH.md"><code class="notranslate">TECH.md</code></a> and keep it in sync with<br>
    any feature or workflow changes you ship.</p>
    <h2 dir="auto">Development Workflow</h2>
    <ul dir="auto">
    <li><strong>Read onboarding.</strong> Start by skimming <code class="notranslate">ONBOARDING.md</code> so you follow the<br>
    expected setup steps, manual QA flow, and documentation touchpoints before<br>
    touching the runtime.</li>
    <li><strong>Session kick-off.</strong> Verify the canonical <code class="notranslate">origin</code> remote exists, then run<br>
    <code class="notranslate">git fetch --all --prune</code> followed by <code class="notranslate">git rebase origin/main</code> when resuming<br>
    prior work—do this before any scripts or edits to minimise merge conflicts.</li>
    <li><strong>Branch naming.</strong> Create short-lived branches named <code class="notranslate">automation/&lt;change&gt;</code> so<br>
    QA notes and preview URLs map directly to the experiment under review.</li>
    <li><strong>Draft PRs early.</strong> Open a draft PR as soon as you push. CI logs, manual QA<br>
    notes, and preview links stay centralised, which matters once the automation<br>
    suite returns.</li>
    <li><strong>Branch deployments.</strong> Branches with open PRs deploy automatically to GitHub<br>
    Pages under <code class="notranslate">/automation-&lt;slug&gt;/</code>; <code class="notranslate">main</code> deploys to the root. Preview links<br>
    arrive directly in PR comments so reviewers do not need a standalone index.</li>
    <li><strong>Manual deploy overrides.</strong> When triggering <code class="notranslate">Deploy GitHub Pages previews</code><br>
    by hand, run the workflow from <code class="notranslate">main</code>, set the <code class="notranslate">target_branch</code> input to the<br>
    branch you need, and tick <code class="notranslate">allow_without_pr</code> only if you intentionally want to<br>
    publish a branch without an open review.</li>
    <li><strong>Implementation simplicity.</strong> Prefer straightforward solutions over clever<br>
    abstractions; keep changes minimal and lines of code lean. Reach first for<br>
    native patterns (template cloning, event delegation, <code class="notranslate">dataset</code> flags) before<br>
    introducing new libraries.</li>
    <li><strong>Surface follow-ups.</strong> When you discover gaps during reviews, log them in<br>
    <code class="notranslate">project/TODO.md</code> (for actionable items) or <code class="notranslate">project/ROADMAP.md</code> (for<br>
    longer-term direction) so context is visible without chasing issues.</li>
    <li><strong>Repository reviews.</strong> When running a repo-wide review, reconcile any drift<br>
    between the runtime and handbook docs (<code class="notranslate">TECH.md</code>, <code class="notranslate">README.md</code>), refresh<br>
    <code class="notranslate">project/TODO.md</code>/<code class="notranslate">project/ROADMAP.md</code> with the findings, and keep the<br>
    zero-build constraint in mind before proposing new tooling.</li>
    <li><strong>Manual smoke tests.</strong> Exercise puzzle load, palette selection, painting, and<br>
    save/load flows in at least one desktop and one mobile browser before<br>
    requesting review.</li>
    <li><strong>Browser tooling.</strong> When you need UI screenshots or to verify hosted flows,<br>
    launch Playwright via <code class="notranslate">browser_container.run_playwright_script</code>. Install the<br>
    Chromium bundle with <code class="notranslate">npx playwright install --with-deps chromium</code> in the<br>
    main workspace (the installation is cached between calls). Forward the<br>
    relevant app port, save artifacts to a relative path (for example,<br>
    <code class="notranslate">artifacts/preview.png</code>), then surface them in the PR with standard Markdown<br>
    image syntax after fetching them through<br>
    <code class="notranslate">browser_container.open_image_artifact</code>.</li>
    <li><strong>Automation discipline.</strong> Record which tests ran, link the latest preview,<br>
    and attach Playwright artifacts (when available) before handing off for<br>
    review. Capture outcomes in the PR description so history remains searchable.</li>
    <li><strong>Fast-forward merges.</strong> Rebase onto <code class="notranslate">main</code>, rerun the quick manual checks,<br>
    and merge with <code class="notranslate">--ff-only</code> so history stays linear for the single-file<br>
    runtime.</li>
    <li><strong>Keep branches fresh.</strong> Before starting work—or dispatching any workflow—make<br>
    sure your branch has the latest <code class="notranslate">.github/workflows</code> files by rebasing or<br>
    pulling from <code class="notranslate">origin/main</code>.</li>
    <li><strong>Weekly automation sync.</strong> Summarise flaky runs, TODO updates, and follow-up<br>
    work in the standing Friday issue to keep the automation backlog visible.</li>
    </ul>
    <h2 dir="auto">Environment Setup</h2>
    <ol dir="auto">
    <li>Install Node.js 18 LTS or newer.</li>
    <li>From the new workspace (<code class="notranslate">cd project</code>), run <code class="notranslate">npm install</code> once to provision<br>
    Playwright browsers and the lightweight <code class="notranslate">http-server</code> used by local<br>
    previews.</li>
    <li>Launch the site with <code class="notranslate">npm run dev</code> inside <code class="notranslate">project/</code> (serves the repository<br>
    root at <a href="http://localhost:8000" rel="nofollow">http://localhost:8000</a>).</li>
    <li>Tests and docs assume the app is reachable at port 8000; if you change it,<br>
    update configuration files plus <code class="notranslate">TECH.md</code>.</li>
    </ol>
    <h2 dir="auto">Testing Expectations</h2>
    <ul dir="auto">
    <li>Primary test command: <code class="notranslate">npm test --silent</code> from within <code class="notranslate">project/</code> (currently<br>
    prints a skip notice while the Playwright suite is offline). Mention in the<br>
    final response if you cannot run it.</li>
    <li>Playwright flow: install browsers with <code class="notranslate">npm run setup:playwright</code> (or<br>
    <code class="notranslate">npx playwright install --with-deps chromium</code>) before running UI checks. If<br>
    downloads are blocked or cached binaries are busy (<code class="notranslate">ETXTBSY</code>), rerun the<br>
    install to refresh the bundle before retrying tests.</li>
    <li>Playwright browsers are <strong>not</strong> preinstalled. Before running any tests or<br>
    scripts that launch Playwright, execute<br>
    <code class="notranslate">npx playwright install --with-deps chromium</code> to provision the Chromium<br>
    bundle and avoid <code class="notranslate">browserType.launch</code> errors about missing executables.</li>
    <li>Targeted smoke run: <code class="notranslate">npm run test:smoke</code> for iterating on<br>
    <code class="notranslate">project/tests/ui-review.spec.js</code>, which now performs a single Chromium<br>
    page-load check.</li>
    <li>Workflow hygiene: When editing files under <code class="notranslate">.github/workflows/</code>, validate the<br>
    YAML with <code class="notranslate">npx yaml-lint &lt;file&gt;</code> before committing.</li>
    <li>UI verification: Keep Playwright expectations aligned with UI markup, palette<br>
    labels, and README imagery when making visual changes.</li>
    <li>Artifacts: Capture Playwright reports under <code class="notranslate">artifacts/ui-review/</code> for major<br>
    UI updates and surface them in PRs once the automated suite is reinstated.</li>
    <li>Changelog + screenshots: save UI screenshots under <code class="notranslate">project/artifacts/</code> and<br>
    link them from <code class="notranslate">project/changelog.md</code> so reviewers can compare against<br>
    deployed previews.</li>
    <li>Manual QA: <code class="notranslate">window.capyGenerator</code> exposes helpers (e.g.<br>
    <code class="notranslate">loadPuzzleFixture</code>, <code class="notranslate">togglePreview</code>). Document any new helpers in <code class="notranslate">TECH.md</code><br>
    plus relevant tests.</li>
    <li>Merge gates: Until automation returns, block merges on a recorded manual<br>
    smoke run. Once the suite is live again, require the automated check to pass<br>
    before landing.</li>
    </ul>
    <h2 dir="auto">Documentation Hygiene</h2>
    <ul dir="auto">
    <li>
    <p dir="auto">Update <code class="notranslate">TECH.md</code> alongside changes that affect gameplay, tooling, or release<br>
    workflows.</p>
    </li>
    <li>
    <p dir="auto">Add or refresh screenshots, segmentation guides, and UI walkthroughs when<br>
    you alter major flows.</p>
    </li>
    <li>
    <p dir="auto"><strong>Runtime constraints.</strong> Keep the runtime build-free: the shipped HTML and<br>
    modules must stay directly loadable without introducing bundlers or new build<br>
    steps. Optimisations should preserve the zero-build flow.</p>
    </li>
    <li>
    <p dir="auto"><strong>Documentation anchors.</strong> Sync <code class="notranslate">TECH.md</code>, <code class="notranslate">project/ROADMAP.md</code>, and<br>
    <code class="notranslate">project/TODO.md</code> with any change that affects runtime behaviour, QA<br>
    coverage, or planning so contributors land on a single, current source of<br>
    truth.</p>
    </li>
    </ul>
    <h2 dir="auto">Automation &amp; Git Preferences</h2>
    <ul dir="auto">
    <li>Sync with <code class="notranslate">main</code> (<code class="notranslate">git fetch --all --prune</code>) before starting work.</li>
    <li>Always add the upstream remote for this repository (<code class="notranslate">git remote add origin https://github.com/shthed/capy.git</code>) when setting up a workspace so fetches<br>
    and pushes target the canonical repo.</li>
    <li>Before making changes, fetch the latest <code class="notranslate">main</code>, pull, and rebase your branch<br>
    onto it to keep history current.</li>
    <li>Configure git identity locally if needed:
    <div class="highlight highlight-source-shell" dir="auto"><pre class="notranslate">git config user.name <span class="pl-s"><span class="pl-pds">"</span>Codex<span class="pl-pds">"</span></span>
    git config user.email <span class="pl-s"><span class="pl-pds">"</span>codex@openai.com<span class="pl-pds">"</span></span></pre></div>
    </li>
    <li>Keep <code class="notranslate">core.pager</code> set to <code class="notranslate">cat</code> for predictable output.</li>
    <li>Push after each commit so remote history mirrors local progress.</li>
    <li>Prefer rebasing feature branches onto <code class="notranslate">origin/main</code>; merge only when you must<br>
    avoid rewriting history. Recommended one-time configuration:
    <div class="highlight highlight-source-shell" dir="auto"><pre class="notranslate">git config --global pull.rebase <span class="pl-c1">true</span>
    git config --global rebase.autoStash <span class="pl-c1">true</span>
    git config --global rerere.enabled <span class="pl-c1">true</span></pre></div>
    </li>
    <li>Standard rebase flow:
    <div class="highlight highlight-source-shell" dir="auto"><pre class="notranslate">git fetch --all --prune
    git switch <span class="pl-k">&lt;</span>feature-branch<span class="pl-k">&gt;</span>
    git rebase origin/main
    <span class="pl-c"><span class="pl-c">#</span> resolve conflicts</span>
    git push --force-with-lease</pre></div>
    </li>
    <li>Conflict response when <code class="notranslate">origin/main</code> moves:
    <ul dir="auto">
    <li>Add the canonical remote if it is missing:
    <div class="highlight highlight-source-shell" dir="auto"><pre class="notranslate">git remote add origin https://github.com/shthed/capy.git</pre></div>
    </li>
    <li>Fetch and pull before resuming work, then rebase or merge right away so<br>
    merge conflicts are handled immediately instead of deferred.</li>
    <li>Capture any conflict-resolution steps (and outcomes) in notes or TODO items<br>
    so reviewers can trace the fixes.</li>
    </ul>
    </li>
    <li>Conflict shortcuts:
    <div class="highlight highlight-source-shell" dir="auto"><pre class="notranslate">git checkout --theirs package-lock.json yarn.lock pnpm-lock.yaml
    git checkout --ours .editorconfig .eslintrc.<span class="pl-k">*</span> .prettierrc<span class="pl-k">*</span>
    git add -A <span class="pl-k">&amp;&amp;</span> git rebase --continue   <span class="pl-c"><span class="pl-c">#</span> or: git merge --continue</span></pre></div>
    </li>
    <li>Abort a bad resolution with <code class="notranslate">git rebase --abort</code> (or <code class="notranslate">git merge --abort</code>).</li>
    </ul>
    <h2 dir="auto">Final Response &amp; PR Expectations</h2>
    <ul dir="auto">
    <li>Summaries should spotlight UI and workflow changes plus live preview URLs when<br>
    available.</li>
    <li>Explicitly list which tests ran (or why they were skipped) in the final<br>
    message.</li>
    <li>Follow repository-wide and nested <code class="notranslate">AGENTS.md</code> guidance for any files you<br>
    touch.</li>
    </ul>
    <h2 dir="auto">Branch Deployments</h2>
    <ul dir="auto">
    <li>Workflow: <code class="notranslate">.github/workflows/deploy-branch.yml</code> builds from every push.<br>
    Branches without open PRs exit early; <code class="notranslate">main</code> always deploys.</li>
    <li>Destinations: <code class="notranslate">main</code> publishes to the root of GitHub Pages. Other branches<br>
    land in <code class="notranslate">/automation-&lt;slug&gt;/</code> directories using sanitised branch names (e.g.,<br>
    <code class="notranslate">automation/feature</code> → <code class="notranslate">/automation-feature/</code>).</li>
    <li>Contents: Each deployment ships the runtime payload from the repository root<br>
    (<code class="notranslate">index.html</code>, <code class="notranslate">render.js</code>, <code class="notranslate">puzzle-generation.js</code>, and <code class="notranslate">capy.json</code>) plus a<br>
    generated <code class="notranslate">/README/index.html</code> so documentation mirrors the branch.</li>
    <li>Preview links: Deployment URLs post directly to the associated PRs, replacing<br>
    the old shared <code class="notranslate">branch.html</code> index.</li>
    <li>Cleanup: When a PR closes, the workflow prunes its corresponding deployment on<br>
    the next run—manual intervention is rarely needed.</li>
    <li>Post-deploy smoke tests: <code class="notranslate">.github/workflows/post-deploy-tests.yml</code> waits for a<br>
    successful deployment, reruns the Playwright smoke script against the hosted<br>
    preview, uploads any UI review artifacts, and comments on the PR with the<br>
    results and screenshot links.</li>
    </ul>

          </main>
          <footer class="page-meta">Generated from AGENTS.md · 2025-11-24 10:04 UTC</footer>
        </body>
        </html>

