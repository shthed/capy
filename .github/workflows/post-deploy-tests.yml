name: Post-deploy branch tests

on:
  workflow_run:
    workflows:
      - Deploy GitHub Pages previews
    types:
      - completed

permissions:
  contents: read
  actions: read
  pull-requests: write

jobs:
  slug:
    runs-on: ubuntu-latest
    outputs:
      branch_name: ${{ steps.slug.outputs.branch_name }}
      branch_slug: ${{ steps.slug.outputs.branch_slug }}
      pr_number: ${{ steps.slug.outputs.pr_number }}
      preview_url: ${{ steps.slug.outputs.preview_url }}
    steps:
      - name: Derive branch slug
        id: slug
        uses: actions/github-script@v7
        with:
          script: |
            const run = context.payload.workflow_run || {};

            const sanitize = (value) => (value || '').replace(/[^a-zA-Z0-9._-]/g, '-').trim();

            const branchName = run.inputs?.target_branch || run.head_branch || run.pull_requests?.[0]?.head?.ref || '';

            const findPullRequest = async (branch) => {
              if (!branch || branch === 'main') {
                return null;
              }

              const lookup = async (state) => {
                const { data } = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  head: `${context.repo.owner}:${branch}`,
                  state,
                  sort: 'updated',
                  direction: 'desc',
                  per_page: 1,
                });

                return Array.isArray(data) && data.length > 0 ? data[0] : null;
              };

              return (await lookup('open')) ?? (await lookup('closed')) ?? null;
            };

            const baseUrl = `https://${context.repo.owner}.github.io/${context.repo.repo}`;

            const pr = await findPullRequest(branchName);

            const previewUrl = branchName === 'main'
              ? `${baseUrl}/`
              : pr?.number
                ? `${baseUrl}/pull/${pr.number}/`
                : '';

            core.setOutput('branch_name', branchName);
            core.setOutput('branch_slug', sanitize(branchName));
            core.setOutput('pr_number', pr?.number ? String(pr.number) : '');
            core.setOutput('preview_url', previewUrl);

  review:
    needs: slug
    if: |
      github.event.workflow_run.conclusion == 'success' &&
      contains(fromJson('["push","workflow_dispatch"]'), github.event.workflow_run.event) &&
      needs.slug.outputs.branch_name != '' &&
      needs.slug.outputs.preview_url != ''
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: project
    concurrency:
      group: post-deploy-tests-${{ needs.slug.outputs.pr_number || needs.slug.outputs.branch_slug }}
      cancel-in-progress: true
    steps:
      - name: Checkout branch commit
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.slug.outputs.branch_name }}

      - name: Use Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: project/package-lock.json

      - name: Install dependencies
        working-directory: project
        run: npm ci

      - name: Install Playwright browsers
        working-directory: project
        run: npx playwright install --with-deps

      - name: Prepare UI review artifacts directory
        working-directory: project
        run: |
          set -euo pipefail
          rm -rf artifacts/ui-review
          mkdir -p artifacts/ui-review

      - name: Announce preview URL
        run: |
          echo "Preview URL: ${{ needs.slug.outputs.preview_url }}"
      - name: Run Playwright smoke tests
        id: smoke
        continue-on-error: true
        env:
          PREVIEW_URL: ${{ needs.slug.outputs.preview_url }}
          PLAYWRIGHT_BASE_URL: ${{ needs.slug.outputs.preview_url }}
        working-directory: project
        run: |
          set -euo pipefail
          npm test --silent 2>&1 | tee artifacts/ui-review/smoke.log

      - name: Capture preview screenshot
        if: always()
        env:
          PLAYWRIGHT_BASE_URL: ${{ needs.slug.outputs.preview_url }}
        working-directory: project
        run: |
          set -euo pipefail
          node ./scripts/capture-preview-screenshot.js

      - name: Collect smoke test errors
        id: smoke-summary
        if: always()
        working-directory: project
        run: |
          set -euo pipefail

          outcome="${{ steps.smoke.outcome }}"
          echo "outcome=${outcome}" >> "$GITHUB_OUTPUT"

          if [ "$outcome" != "success" ] && [ -f artifacts/ui-review/smoke.log ]; then
            {
              printf 'errors<<EOF\n'
              tail -n 40 artifacts/ui-review/smoke.log
              printf '\nEOF\n'
            } >> "$GITHUB_OUTPUT"
          else
            echo "errors=" >> "$GITHUB_OUTPUT"
          fi

      - name: Capture preview screenshot
        id: capture-screenshot
        if: always()
        continue-on-error: true
        env:
          PREVIEW_URL: ${{ needs.slug.outputs.preview_url }}
        working-directory: project
        run: |
          set -euo pipefail

          if [ -z "${PREVIEW_URL:-}" ]; then
            echo "Preview URL missing; skipping screenshot capture."
            exit 0
          fi

          node --input-type=module - <<'NODE'
          import { chromium } from 'playwright';

          const url = process.env.PREVIEW_URL;
          const outputPath = 'artifacts/ui-review/preview.png';

          const browser = await chromium.launch({ headless: true });
          const context = await browser.newContext({ viewport: { width: 1280, height: 720 } });
          const page = await context.newPage();

          try {
            await page.goto(url, { waitUntil: 'networkidle', timeout: 15000 });
            await page.screenshot({ path: outputPath, fullPage: true });
            console.log(`Captured preview screenshot at ${outputPath}`);
          } finally {
            await browser.close();
          }
          NODE

      - name: Detect UI review artifacts
        id: artifact-check
        if: always()
        working-directory: project
        run: |
          set -euo pipefail

          if [ -d "artifacts/ui-review" ] && find "artifacts/ui-review" -type f -print -quit | grep -q .; then
            echo "found=true" >> "$GITHUB_OUTPUT"
          else
            echo "found=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload UI review artifacts
        if: always()
        id: upload-ui-artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ui-review-${{ needs.slug.outputs.pr_number || needs.slug.outputs.branch_slug }}-${{ github.run_id }}
          path: project/artifacts/ui-review
          if-no-files-found: ignore

      - name: Share preview link on PR
        if: always()
        uses: actions/github-script@v7
        env:
          PREVIEW_URL: ${{ needs.slug.outputs.preview_url }}
          SMOKE_OUTCOME: ${{ steps.smoke-summary.outputs.outcome }}
          ERROR_MESSAGES: ${{ steps.smoke-summary.outputs.errors }}
          ARTIFACT_FOUND: ${{ steps.artifact-check.outputs.found }}
          ARTIFACT_URL: ${{ steps.upload-ui-artifacts.outputs.artifact-url }}
        with:
          script: |
            const pullRequests = context.payload.workflow_run?.pull_requests ?? [];
            if (!Array.isArray(pullRequests) || pullRequests.length === 0) {
              core.info('No pull requests attached to this run. Skipping comment.');
              return;
            }

            const previewUrl = process.env.PREVIEW_URL;
            const smokeOutcome = process.env.SMOKE_OUTCOME;
            const errors = process.env.ERROR_MESSAGES;
            const artifactFound = process.env.ARTIFACT_FOUND === 'true';
            const artifactUrl = process.env.ARTIFACT_URL;
            const rerunUrl = context.payload.workflow_run?.html_url;

            const marker = '<!-- capy-pages-preview -->';
            const timestamp = new Date().toISOString().replace('T', ' ').replace(/\.\d+Z$/, ' UTC');

            const entryLines = [`- ${timestamp}`];

            entryLines.push(`  - Preview: ${previewUrl || 'unavailable'}`);

            if (smokeOutcome) {
              entryLines.push(`  - Smoke: ${smokeOutcome}`);
            }

            if (artifactFound && artifactUrl) {
              entryLines.push(`  - UI review artifacts: ${artifactUrl}`);
            }

            if (errors) {
              const formattedErrors = errors
                .trimEnd()
                .split('\n')
                .map((line) => line ? `    ${line}` : '    ') 
                .join('\n');
              entryLines.push(`  - Errors:\n${formattedErrors}`);
            }

            if (rerunUrl) {
              entryLines.push(`  - Rerun Pages deploy: ${rerunUrl}`);
            }

            const newEntry = entryLines.join('\n');
            const header = 'Branch preview deployments';

            const findExistingComment = async (issueNumber) => {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                per_page: 100,
              });

              return comments.find(
                (comment) => comment.user?.login === 'github-actions[bot]' && comment.body?.includes(marker)
              );
            };

            for (const pr of pullRequests) {
              const existingComment = await findExistingComment(pr.number);
              let historicalEntries = [];

              if (existingComment?.body?.includes(marker)) {
                const [, tail = ''] = existingComment.body.split(marker);
                historicalEntries = tail
                  .trim()
                  .split('\n\n')
                  .filter(Boolean);
              }

              const body = [header, marker, newEntry, ...historicalEntries].join('\n\n');

              if (existingComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingComment.id,
                  body,
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  body,
                });
              }
            }
