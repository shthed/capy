name: Deploy GitHub Pages previews

on:
  push:
    branches:
      - '**'
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  deploy:
    if: github.ref != 'refs/heads/gh-pages'
    runs-on: ubuntu-latest
    concurrency:
      group: pages-deployments
      cancel-in-progress: false
    environment:
      name: github-pages
      url: ${{ steps.deploy-pages.outputs.page_url }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch open PR metadata
        id: pr-metadata
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pulls } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              sort: 'updated',
              direction: 'desc',
              per_page: 100
            });

            const branches = pulls.map(pr => ({
              branch: pr.head.ref,
              safeName: pr.head.ref.replace(/[^a-zA-Z0-9._-]/g, '-'),
              title: pr.title,
              number: pr.number,
              updatedAt: pr.updated_at,
              url: pr.html_url
            }));

            const currentBranch = (context.ref || '').replace('refs/heads/', '');
            const hasOpenPr = branches.some(pr => pr.branch === currentBranch);

            core.setOutput('has-open-pr', hasOpenPr ? 'true' : 'false');

            const fs = require('fs');
            fs.writeFileSync('pr-branches.json', JSON.stringify(branches, null, 2));

            return branches.length;

      - name: Determine deployment eligibility
        id: deployment-gate
        env:
          HAS_OPEN_PR: ${{ steps.pr-metadata.outputs.has-open-pr }}
        run: |
          set -euo pipefail

          BRANCH_NAME="${GITHUB_REF_NAME}"

          if [ "$BRANCH_NAME" = "main" ]; then
            echo "eligible=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ "${HAS_OPEN_PR}" = "true" ]; then
            echo "eligible=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "eligible=false" >> "$GITHUB_OUTPUT"

      - name: Skip deployment for branches without open PRs
        if: steps.deployment-gate.outputs.eligible != 'true'
        run: |
          echo "No open pull request detected for ${GITHUB_REF_NAME}; skipping deployment."

      - name: Fetch main branch commits
        if: steps.deployment-gate.outputs.eligible == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const { data: commits } = await github.rest.repos.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: 'main',
              per_page: 4
            });

            const commitsWithPRs = await Promise.all(commits.map(async (commit) => {
              let prs = [];
              try {
                const { data: prData } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  commit_sha: commit.sha
                });
                prs = prData.map(pr => ({
                  number: pr.number,
                  title: pr.title,
                  url: pr.html_url,
                  branch: pr.head?.ref ?? null
                }));
              } catch (error) {
                core.warning(`Could not fetch PRs for commit ${commit.sha}: ${error.message}`);
              }

              return {
                sha: commit.sha,
                shortSha: commit.sha.substring(0, 7),
                message: commit.commit.message,
                author: commit.commit.author?.name ?? commit.commit.committer?.name ?? 'Unknown author',
                date: commit.commit.author?.date ?? commit.commit.committer?.date ?? '',
                htmlUrl: commit.html_url,
                prs
              };
            }));

            const mainBranchData = {
              commits: commitsWithPRs,
              lastCommitDate: commits[0]?.commit.author?.date ?? commits[0]?.commit.committer?.date ?? null,
              deploymentTimestamp: Date.now()
            };

            fs.writeFileSync('main-branch-data.json', JSON.stringify(mainBranchData, null, 2));

            return mainBranchData.commits.length;

      - name: Fetch branch commit history
        if: steps.deployment-gate.outputs.eligible == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            let prBranches = [];
            try {
              prBranches = JSON.parse(fs.readFileSync('pr-branches.json', 'utf8'));
            } catch (error) {
              core.warning(`Could not read pr-branches.json: ${error.message}`);
            }

            const branchCommitData = {};

            const branches = Array.isArray(prBranches) ? prBranches : [];

            for (const pr of branches) {
              const branchName = pr?.branch;
              if (!branchName) {
                continue;
              }

              try {
                const { data: commits } = await github.rest.repos.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  sha: branchName,
                  per_page: 4
                });

                const prInfo = {
                  number: pr.number,
                  title: pr.title,
                  url: pr.url ?? pr.html_url ?? null,
                  branch: pr.branch ?? null
                };

                const commitsWithMetadata = commits.map((commit) => ({
                  sha: commit.sha,
                  shortSha: commit.sha.substring(0, 7),
                  message: commit.commit.message,
                  date: commit.commit.author?.date ?? commit.commit.committer?.date ?? '',
                  htmlUrl: commit.html_url,
                  prs: prInfo.number != null || prInfo.title || prInfo.url ? [prInfo] : []
                }));

                branchCommitData[branchName] = commitsWithMetadata;

                const safeName = typeof pr?.safeName === 'string' ? pr.safeName : branchName.replace(/[^a-zA-Z0-9._-]/g, '-');
                branchCommitData[safeName] = commitsWithMetadata;
              } catch (error) {
                core.warning(`Could not fetch commits for branch ${branchName}: ${error.message}`);
              }
            }

            fs.writeFileSync('branch-commits.json', JSON.stringify(branchCommitData, null, 2));

            return Object.keys(branchCommitData).length;

      - name: Sync branch to gh-pages
        if: steps.deployment-gate.outputs.eligible == 'true'
        id: sync
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMIT_MESSAGE: ${{ github.event.head_commit.message || '' }}
          COMMIT_TIMESTAMP: ${{ github.event.head_commit.timestamp || '' }}
        run: |
          set -euo pipefail

          BRANCH_NAME="${GITHUB_REF_NAME}"
          SAFE_NAME=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9._-]/-/g')
          TARGET_DIR="."
          TARGET_KEY="main"

          if [ "$BRANCH_NAME" = "main" ]; then
            SAFE_NAME=""
          else
            TARGET_DIR="$SAFE_NAME"
            TARGET_KEY="$SAFE_NAME"
          fi

          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          rm -rf pages
          if git ls-remote --exit-code origin gh-pages >/dev/null 2>&1; then
            git clone --depth=1 --branch gh-pages "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git" pages
          else
            mkdir pages
            git -C pages init
            git -C pages checkout -b gh-pages
            git -C pages remote add origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
            touch pages/.nojekyll
            git -C pages add .nojekyll
            git -C pages commit -m "Initialize gh-pages"
            git -C pages push origin gh-pages
          fi

          cd pages

          touch .nojekyll
          MANIFEST=".branch-manifest"
          touch "$MANIFEST"

          generate_readme_html() {
            local target_root="$1"
            local source_file="../README.md"

            if [ ! -f "$source_file" ]; then
              echo "README.md not found; skipping HTML conversion" >&2
              return 0
            fi

            local tmp_html
            tmp_html=$(mktemp)

            if ! npx --yes marked@9.1.3 --gfm --breaks "$source_file" > "$tmp_html"; then
              echo "Warning: README markdown to HTML conversion failed" >&2
              rm -f "$tmp_html"
              return 0
            fi

            local output_dir="$target_root/README"
            local output_file="$output_dir/index.html"
            rm -rf "$output_dir"
            mkdir -p "$output_dir"

            TEMP_HTML="$tmp_html" OUT_FILE="$output_file" python - <<'PY'
import datetime
import os
import pathlib

temp_html = pathlib.Path(os.environ["TEMP_HTML"])
out_file = pathlib.Path(os.environ["OUT_FILE"])

content = temp_html.read_text()
indented = "\n".join(f"    {line}" for line in content.splitlines())

generated = datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")

template = f"""<!DOCTYPE html>
<html lang=\"en\">
<head>
  <meta charset=\"utf-8\">
  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">
  <title>Capy README</title>
  <style>
    :root {{
      color-scheme: light dark;
    }}
    body {{
      font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen, Ubuntu, Cantarell, \"Open Sans\", sans-serif;
      margin: 0 auto;
      padding: 32px 16px 48px;
      max-width: 920px;
      line-height: 1.6;
      background: #f6f8fa;
      color: #1f2328;
    }}
    a {{
      color: #0969da;
    }}
    .markdown-body {{
      background: #fff;
      border-radius: 12px;
      padding: 32px;
      box-shadow: 0 16px 40px rgba(15, 23, 42, 0.08);
      border: 1px solid #d0d7de;
    }}
    .page-meta {{
      margin-top: 24px;
      font-size: 0.85em;
      color: #57606a;
      text-align: center;
    }}
    pre {{
      background: #0d1117;
      color: #f0f6fc;
      padding: 16px;
      border-radius: 8px;
      overflow-x: auto;
    }}
    code {{
      font-family: SFMono-Regular, Consolas, \"Liberation Mono\", Menlo, monospace;
    }}
    @media (max-width: 720px) {{
      .markdown-body {{
        padding: 24px 20px;
      }}
    }}
  </style>
</head>
<body>
  <main class=\"markdown-body\">
{indented}
  </main>
  <footer class=\"page-meta\">Generated from README.md · {generated}</footer>
</body>
</html>
"""

out_file.write_text(template)
PY

            rm -f "$tmp_html"
          }

          RSYNC_ARGS=(
            "--exclude=.git/"
            "--exclude=.github/"
            "--exclude=.github"
            "--exclude=node_modules/"
            "--exclude=pages/"
            "--exclude=.branch-manifest"
            "--exclude=deployments.json"
            "--exclude=branch.html"
            "--exclude=.gitignore"
            "--exclude=.gitattributes"
            "--exclude=.DS_Store"
          )

          if [ "$TARGET_DIR" = "." ]; then
            EXTRA_EXCLUDES=()
            while IFS= read -r entry; do
              [ -n "$entry" ] || continue
              EXTRA_EXCLUDES+=("--exclude=${entry}/")
            done < "$MANIFEST"

            rsync -a --delete "${RSYNC_ARGS[@]}" "${EXTRA_EXCLUDES[@]}" ../ ./
            generate_readme_html "."
          else
            rm -rf "$TARGET_DIR"
            mkdir -p "$TARGET_DIR"

            ESSENTIAL_FILES=(
              "index.html"
              "puzzle-generation.js"
              "capy.json"
            )

            for file in "${ESSENTIAL_FILES[@]}"; do
              if [ -e "../$file" ]; then
                cp -a "../$file" "$TARGET_DIR/"
              else
                echo "Warning: required file $file not found during branch deployment sync" >&2
              fi
            done
            generate_readme_html "$TARGET_DIR"
            if ! grep -qxF "$TARGET_KEY" "$MANIFEST"; then
              echo "$TARGET_KEY" >> "$MANIFEST"
            fi
          fi

          DEPLOY_DATA="deployments.json"
          if [ ! -f "$DEPLOY_DATA" ]; then
            echo '{}' > "$DEPLOY_DATA"
          fi

          MESSAGE="$COMMIT_MESSAGE"
          if [ -z "$MESSAGE" ]; then
            MESSAGE=$(git -C .. log -1 --pretty=%B | head -n 1)
          fi

          TIMESTAMP="$COMMIT_TIMESTAMP"
          if [ -z "$TIMESTAMP" ]; then
            TIMESTAMP=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
          fi

          jq --arg key "$TARGET_KEY" \
             --arg branch "$BRANCH_NAME" \
             --arg safe "$SAFE_NAME" \
             --arg commit "${GITHUB_SHA}" \
             --arg message "$MESSAGE" \
             --arg actor "${GITHUB_ACTOR}" \
             --arg timestamp "$TIMESTAMP" \
             --arg url "https://github.com/${GITHUB_REPOSITORY}/commit/${GITHUB_SHA}" \
             '.[$key] = {
               branch: $branch,
               safeName: $safe,
               commit: $commit,
               message: $message,
               actor: $actor,
               deployedAt: $timestamp,
               commitUrl: $url
             }' "$DEPLOY_DATA" > "$DEPLOY_DATA.tmp"
          mv "$DEPLOY_DATA.tmp" "$DEPLOY_DATA"

          cat > branch.html <<'HTML'
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <title>Capy Branch Deployments</title>
            <style>
              body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", sans-serif;
                max-width: 960px;
                margin: 40px auto;
                padding: 0 20px 40px;
                line-height: 1.6;
                color: #24292e;
                background: #f6f8fa;
              }
              h1 {
                margin-bottom: 16px;
              }
              ul.deployments {
                list-style: none;
                padding: 0;
                margin: 0;
                display: grid;
                gap: 16px;
              }
              li.card {
                background: #fff;
                border: 1px solid #d0d7de;
                border-radius: 8px;
                padding: 16px;
                box-shadow: 0 1px 0 rgba(31,35,40,0.04);
              }
              li.card.main {
                border-color: #4c8eda;
                box-shadow: 0 4px 12px rgba(76,142,218,0.12);
              }
              .branch-title {
                display: flex;
                flex-wrap: wrap;
                align-items: baseline;
                gap: 8px;
                margin-bottom: 12px;
              }
              .branch-name {
                font-size: 1.1em;
                font-weight: 600;
                color: #1f2328;
              }
              .branch-name a {
                color: inherit;
                text-decoration: none;
              }
              .branch-name a:hover {
                text-decoration: underline;
              }
              .commit-list {
                list-style: none;
                margin: 0;
                padding: 0;
                display: grid;
                gap: 10px;
              }
              .commit-item {
                font-size: 0.95em;
                color: #1f2328;
                display: flex;
                flex-wrap: wrap;
                align-items: baseline;
                gap: 10px;
              }
              .commit-item > * {
                flex-shrink: 0;
              }
              .commit-time {
                color: #57606a;
                font-weight: 600;
                font-variant-numeric: tabular-nums;
              }
              .commit-time time {
                color: inherit;
              }
              .commit-pr,
              .commit-branch,
              .commit-sha {
                font-family: ui-monospace, SFMono-Regular, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;
                font-size: 0.9em;
                font-weight: 600;
                text-decoration: none;
              }
              .commit-pr {
                color: #8250df;
              }
              .commit-pr:hover {
                text-decoration: underline;
              }
              .commit-branch {
                color: #1f2328;
              }
              .commit-branch:hover {
                text-decoration: underline;
              }
              .commit-sha {
                color: #0969da;
              }
              .commit-sha:hover {
                text-decoration: underline;
              }
              .commit-message {
                font-weight: 500;
                color: #1f2328;
                flex: 1 1 220px;
                min-width: 200px;
              }
            </style>
          </head>
          <body>
            <h1>Capy Branch Deployments</h1>
            <ul class="deployments">
          HTML

          PR_DATA_FILE="../pr-branches.json"
          MAIN_DATA_FILE="../main-branch-data.json"
          if [ ! -f "$PR_DATA_FILE" ]; then
            echo '[]' > "$PR_DATA_FILE"
          fi
          if [ ! -f "$MAIN_DATA_FILE" ]; then
            echo '{"commits":[]}' > "$MAIN_DATA_FILE"
          fi

          BRANCH_COMMITS_FILE="../branch-commits.json"
          if [ ! -f "$BRANCH_COMMITS_FILE" ]; then
            echo '{}' > "$BRANCH_COMMITS_FILE"
          fi

          DEPLOY_DATA_PATH="$DEPLOY_DATA" \
          PR_DATA_PATH="$PR_DATA_FILE" \
          MAIN_DATA_PATH="$MAIN_DATA_FILE" \
          BRANCH_COMMITS_PATH="$BRANCH_COMMITS_FILE" \
          node <<'NODE'
          const fs = require('fs');

          const readJson = (path, fallback) => {
            try {
              return JSON.parse(fs.readFileSync(path, 'utf8'));
            } catch (error) {
              return fallback;
            }
          };

          const deployments = readJson(process.env.DEPLOY_DATA_PATH, {});
          const prList = readJson(process.env.PR_DATA_PATH, []);
          const mainData = readJson(process.env.MAIN_DATA_PATH, { commits: [] });
          const branchCommits = readJson(process.env.BRANCH_COMMITS_PATH, {});
          const repoSlug = process.env.GITHUB_REPOSITORY ?? '';
          const githubBaseUrl = repoSlug ? `https://github.com/${repoSlug}` : '';
          const githubBranchUrl = (branch) => {
            if (!githubBaseUrl) {
              return '';
            }

            const name = String(branch ?? '').trim();
            if (!name) {
              return '';
            }

            return `${githubBaseUrl}/tree/${encodeURIComponent(name)}`;
          };

          const htmlEscape = (value) => String(value ?? '')
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');

          const firstLine = (text) => {
            const str = String(text ?? '');
            const newlineIndex = str.indexOf('\n');
            return newlineIndex === -1 ? str : str.slice(0, newlineIndex);
          };

          const formatDate = (value) => {
            if (!value) {
              return { text: '', iso: '' };
            }

            const date = new Date(value);
            if (Number.isNaN(date.getTime())) {
              return { text: '', iso: '' };
            }

            const parts = new Intl.DateTimeFormat('en-US', {
              weekday: 'short',
              year: 'numeric',
              month: 'short',
              day: '2-digit',
              hour: 'numeric',
              minute: '2-digit',
              hour12: true
            }).formatToParts(date);

            const get = (type) => {
              const part = parts.find((entry) => entry.type === type);
              return part ? part.value : '';
            };

            const month = get('month');
            const rawDay = get('day');
            const day = rawDay ? rawDay.padStart(2, '0') : '';
            const year = get('year');
            const hour = get('hour');
            const minute = get('minute');
            const period = get('dayPeriod');
            const weekday = get('weekday');

            if (!month || !day || !year || !hour || !minute || !period || !weekday) {
              return { text: '', iso: '' };
            }

            const time = `${hour}:${minute}${period.toLowerCase()}`;
            const text = `${time} ${weekday} ${month} ${day}, ${year}`;
            return { text, iso: date.toISOString() };
          };

          const renderDate = (value, className = 'commit-time') => {
            const { text, iso } = formatDate(value);
            if (iso) {
              return `<time class="${htmlEscape(className)}" datetime="${htmlEscape(iso)}" data-local-datetime="${htmlEscape(iso)}">${htmlEscape(text)}</time>`;
            }
            if (text) {
              return `<span class="${htmlEscape(className)}">${htmlEscape(text)}</span>`;
            }
            return '';
          };

          const prByBranch = new Map();
          const prBySafe = new Map();

          for (const pr of prList) {
            if (pr && typeof pr === 'object') {
              if (pr.branch) {
                prByBranch.set(pr.branch, pr);
              }
              if (pr.safeName) {
                prBySafe.set(pr.safeName, pr);
              }
            }
          }

          const branchPr = (entry) => {
            const value = entry.value ?? {};
            return prByBranch.get(value.branch) ?? prBySafe.get(value.safeName) ?? null;
          };

          const branchCommitsFor = (entry) => {
            const value = entry.value ?? {};
            const branchName = value.branch ?? '';
            const safeName = value.safeName ?? '';
            const commits = branchCommits?.[branchName] ?? branchCommits?.[safeName] ?? [];
            return Array.isArray(commits) ? commits : [];
          };

          const baseData = (entry) => {
            const value = entry.value ?? {};

            return {
              branch: value.branch ?? '',
              safe: value.safeName ?? '',
              deployed: value.deployedAt ?? 'unknown',
              actor: value.actor ?? 'unknown',
              commit: value.commit ?? '',
              message: value.message ?? '',
              url: value.commitUrl ?? '#'
            };
          };

          const uniqueCommits = (commits) => {
            const seen = new Set();
            const results = [];

            for (const commit of Array.isArray(commits) ? commits : []) {
              const sha = commit?.sha ?? commit?.shortSha ?? commit?.htmlUrl ?? commit?.message ?? null;
              const key = sha ? String(sha) : null;
              if (key && seen.has(key)) {
                continue;
              }
              if (key) {
                seen.add(key);
              }
              results.push(commit);
            }

            return results;
          };

          const normalizeSha = (value) => String(value ?? '').trim().toLowerCase();

          const commitMatchesSha = (commit, target) => {
            const normalizedTarget = normalizeSha(target);
            if (!normalizedTarget) {
              return false;
            }

            const candidates = [
              normalizeSha(commit?.sha),
              normalizeSha(commit?.shortSha)
            ].filter(Boolean);

            return candidates.some((candidate) => normalizedTarget.startsWith(candidate) || candidate.startsWith(normalizedTarget));
          };

          const excludeCommitBySha = (commits, target) => (Array.isArray(commits) ? commits : []).filter((commit) => !commitMatchesSha(commit, target));

          const firstPullRequest = (commit) => {
            const list = Array.isArray(commit?.prs) ? commit.prs : [];
            for (const pr of list) {
              if (pr && typeof pr === 'object') {
                return pr;
              }
            }
            return null;
          };

          const commitItem = (commit, { fallbackPr = null, fallbackBranch = '', fallbackMessage = '', fallbackSha = '', fallbackUrl = '' } = {}) => {
            if (!commit || typeof commit !== 'object') {
              commit = {};
            }

            const message = firstLine(commit.message ?? fallbackMessage ?? '');
            const resolvedSha = commit.sha ?? fallbackSha ?? '';
            const shortSha = commit.shortSha ?? (resolvedSha ? String(resolvedSha).slice(0, 7) : '');
            const commitUrl = commit.htmlUrl ?? fallbackUrl ?? '';
            const dateMarkup = renderDate(commit.date ?? '');
            const pr = firstPullRequest(commit) ?? fallbackPr;
            const prNumber = pr?.number != null ? String(pr.number) : '';
            const prUrl = pr?.url ?? '';

            const branchName = (() => {
              const fromPr = pr?.branch ? String(pr.branch).trim() : '';
              if (fromPr) {
                return fromPr;
              }
              if (fallbackBranch) {
                return String(fallbackBranch).trim();
              }
              return '';
            })();
            const branchUrl = branchName ? githubBranchUrl(branchName) : '';

            const segments = [];

            if (dateMarkup) {
              segments.push(dateMarkup);
            }

            if (prNumber) {
              const label = `#${htmlEscape(prNumber)}`;
              if (prUrl) {
                segments.push(`<a class="commit-pr" href="${htmlEscape(prUrl)}">${label}</a>`);
              } else {
                segments.push(`<span class="commit-pr">${label}</span>`);
              }
            }

            if (branchName) {
              const branchLabel = htmlEscape(branchName);
              if (branchUrl) {
                segments.push(`<a class="commit-branch" href="${htmlEscape(branchUrl)}">${branchLabel}</a>`);
              } else {
                segments.push(`<span class="commit-branch">${branchLabel}</span>`);
              }
            }

            if (shortSha) {
              if (commitUrl) {
                segments.push(`<a class="commit-sha" href="${htmlEscape(commitUrl)}">${htmlEscape(shortSha)}</a>`);
              } else {
                segments.push(`<span class="commit-sha">${htmlEscape(shortSha)}</span>`);
              }
            }

            if (message) {
              segments.push(`<span class="commit-message">${htmlEscape(message)}</span>`);
            }

            if (segments.length === 0) {
              return '';
            }

            return `<li class="commit-item">${segments.join(' ')}</li>`;
          };

          const renderMain = (entry) => {
            const data = baseData(entry);
            const commits = uniqueCommits(mainData.commits);
            const items = [];

            const findMatchingCommit = () => {
              const targetSha = data.commit ? String(data.commit) : '';
              if (!targetSha) {
                return null;
              }

              const targetShort = targetSha.slice(0, 7);
              for (const commit of commits) {
                const sha = commit?.sha ? String(commit.sha) : '';
                const shortSha = commit?.shortSha ? String(commit.shortSha) : sha.slice(0, 7);
                if (sha && sha === targetSha) {
                  return commit;
                }
                if (shortSha && targetShort && shortSha === targetShort) {
                  return commit;
                }
              }
              return null;
            };

            const matchingCommit = findMatchingCommit();
            if (matchingCommit) {
              const enriched = {
                ...matchingCommit,
                date: data.deployed || matchingCommit.date || '',
                message: data.message || matchingCommit.message || '',
                sha: matchingCommit.sha || data.commit || '',
                shortSha: matchingCommit.shortSha || (data.commit ? String(data.commit).slice(0, 7) : ''),
                htmlUrl: data.url || matchingCommit.htmlUrl || ''
              };
              items.push(commitItem(enriched));
            } else {
              const fallback = {
                date: data.deployed || '',
                message: data.message || '',
                sha: data.commit || '',
                shortSha: data.commit ? String(data.commit).slice(0, 7) : '',
                htmlUrl: data.url || ''
              };
              const markup = commitItem(fallback);
              if (markup) {
                items.push(markup);
              }
            }

            let remaining = commits;
            if (matchingCommit) {
              remaining = commits.filter((commit) => commit !== matchingCommit && commit?.sha !== matchingCommit.sha);
            }

            for (const commit of remaining) {
              if (items.length >= 3) {
                break;
              }
              const markup = commitItem(commit);
              if (markup) {
                items.push(markup);
              }
            }

            const previewHref = data.safe ? `./${data.safe}/` : './';
            const branchLabel = previewHref ? `<a href="${htmlEscape(previewHref)}">main</a>` : 'main';

            let html = `<li class="card main">`;
            html += `<div class="branch-title"><span class="branch-name">${branchLabel}</span></div>`;
            html += `<ul class="commit-list">${items.join('')}</ul>`;
            html += `</li>\n`;
            return html;
          };

          const renderBranch = (entry) => {
            const data = baseData(entry);
            const pr = branchPr(entry);
            const branchName = firstLine(data.branch ?? '') || 'unknown branch';
            const commits = uniqueCommits(branchCommitsFor(entry));
            const items = [];

            const fallbackPr = pr ? {
              ...pr,
              branch: pr.branch ?? data.branch ?? ''
            } : null;

            const previewHref = data.safe ? `./${data.safe}/` : './';
            const displayName = htmlEscape(branchName);
            const branchTitle = previewHref ? `<a href="${htmlEscape(previewHref)}">${displayName}</a>` : displayName;

            const deploymentCommit = {
              date: data.deployed || '',
              message: data.message || '',
              sha: data.commit || '',
              shortSha: data.commit ? String(data.commit).slice(0, 7) : '',
              htmlUrl: data.url || '',
              prs: fallbackPr ? [fallbackPr] : []
            };

            const deploymentMarkup = commitItem(deploymentCommit, { fallbackPr, fallbackBranch: data.branch });
            if (deploymentMarkup) {
              items.push(deploymentMarkup);
            }

            for (const commit of commits) {
              if (items.length >= 3) {
                break;
              }
              const markup = commitItem(commit, { fallbackPr, fallbackBranch: data.branch });
              if (markup) {
                items.push(markup);
              }
            }

            let html = `<li class="card">`;
            html += `<div class="branch-title"><span class="branch-name">${branchTitle}</span></div>`;
            html += `<ul class="commit-list">${items.join('')}</ul>`;
            html += `</li>\n`;
            return html;
          };

          const toTimestamp = (value) => {
            if (!value) {
              return 0;
            }

            const parsed = Date.parse(value);
            return Number.isNaN(parsed) ? 0 : parsed;
          };

          const entries = Object.entries(deployments ?? {}).map(([key, value]) => ({ key, value }));
          let output = '';

          const mainEntry = entries.find((entry) => entry.key === 'main' && entry.value);
          if (mainEntry) {
            output += renderMain(mainEntry);
          }

          const branchEntries = entries
            .filter((entry) => entry.key !== 'main')
            .filter((entry) => branchPr(entry));

          branchEntries.sort((a, b) => toTimestamp(b.value?.deployedAt) - toTimestamp(a.value?.deployedAt));

          for (const entry of branchEntries) {
            output += renderBranch(entry);
          }

          fs.appendFileSync('branch.html', output);
          NODE

          cat >> branch.html <<'HTML'
            </ul>
            <script>
              (() => {
                const baseOptions = {
                  weekday: 'short',
                  year: 'numeric',
                  month: 'short',
                  day: '2-digit',
                  hour: 'numeric',
                  minute: '2-digit',
                  hour12: true
                };

                let zoneFormatter = null;
                try {
                  zoneFormatter = new Intl.DateTimeFormat(undefined, { ...baseOptions, timeZoneName: 'short' });
                } catch (error) {
                  zoneFormatter = null;
                }

                const fallbackFormatter = new Intl.DateTimeFormat(undefined, baseOptions);

                const formatParts = (formatter, date) => {
                  if (!formatter) {
                    return null;
                  }

                  try {
                    const parts = formatter.formatToParts(date);
                    const find = (type) => {
                      const entry = parts.find((part) => part.type === type);
                      return entry ? entry.value : '';
                    };

                    const month = find('month');
                    const rawDay = find('day');
                    const day = rawDay ? rawDay.padStart(2, '0') : '';
                    const year = find('year');
                    const hour = find('hour');
                    const minute = find('minute');
                    const period = find('dayPeriod');
                    const weekday = find('weekday');
                    const zone = find('timeZoneName');

                    if (!month || !day || !year || !hour || !minute || !period || !weekday) {
                      return null;
                    }

                    const time = `${hour}:${minute}${period.toLowerCase()}`;
                    const base = `${time} ${weekday} ${month} ${day}, ${year}`;
                    const zoneSuffix = zone ? ` ${zone}` : '';
                    return `${base}${zoneSuffix}`;
                  } catch (error) {
                    return null;
                  }
                };

                const elements = document.querySelectorAll('[data-local-datetime]');
                for (const element of elements) {
                  const iso = element.getAttribute('data-local-datetime');
                  if (!iso) {
                    continue;
                  }

                  const date = new Date(iso);
                  if (Number.isNaN(date.getTime())) {
                    continue;
                  }

                  const display = formatParts(zoneFormatter, date) ?? formatParts(fallbackFormatter, date);
                  if (display) {
                    element.textContent = display;
                  }
                }
              })();
            </script>
          </body>
          </html>
          HTML

          git add -A
          if [ -n "$(git status --short)" ]; then
            git commit -m "Deploy ${BRANCH_NAME} (${GITHUB_SHA})"
            git push origin gh-pages
          else
            echo "No changes to commit"
          fi

          BASE_URL="https://${GITHUB_REPOSITORY_OWNER}.github.io/${GITHUB_REPOSITORY#*/}"
          if [ -z "$SAFE_NAME" ]; then
            PREVIEW_URL="${BASE_URL}/"
          else
            PREVIEW_URL="${BASE_URL}/${SAFE_NAME}/"
          fi

          echo "preview_url=${PREVIEW_URL}" >> "$GITHUB_OUTPUT"
          echo "Branch deployed to: ${PREVIEW_URL}"

          cd ..

      - name: Prepare Pages artifact
        if: steps.deployment-gate.outputs.eligible == 'true'
        run: |
          set -euo pipefail
          rm -rf site
          mkdir -p site
          rsync -a --exclude='.git/' pages/ site/

      - name: Setup Pages
        if: steps.deployment-gate.outputs.eligible == 'true'
        uses: actions/configure-pages@v5

      - name: Upload artifact
        if: steps.deployment-gate.outputs.eligible == 'true'
        uses: actions/upload-pages-artifact@v3
        with:
          path: site

      - name: Deploy to GitHub Pages
        if: steps.deployment-gate.outputs.eligible == 'true'
        id: deploy-pages
        uses: actions/deploy-pages@v4

      - name: Preview URL
        if: steps.deployment-gate.outputs.eligible == 'true'
        run: echo "Preview available at ${{ steps.sync.outputs.preview_url }}"
