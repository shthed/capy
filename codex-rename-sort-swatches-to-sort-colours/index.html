<!DOCTYPE html>
<html lang="en">
  <!--
    Developer Map
    ==========
    Layout overview
    --------------
    - UI chrome (command rail, modal sheets, and the debug console) exposes primary actions wired
      to script handlers. Scan for "Command button" listeners when adjusting layout interactions.
    - Viewport + stage: #viewport, #canvasStage, and #canvasTransform cooperate with viewState for
      pan/zoom. Pointer handlers (handlePanStart/Move/End) and applyZoom feed navigation updates.
    - Puzzle state & rendering: state holds palette, fills, and metadata. renderPuzzle →
      drawOutlines/drawNumbers use ensureRenderCache to hydrate canvases and labels.
    - Generation pipeline: loadImage → createPuzzleData orchestrates quantization, segmentation,
      and palette prep. Regeneration, fixture loading, and saves all call applyPuzzleResult.
    - Persistence + exports: createGameSaveManager backs the Saves sheet. Autosave,
      manual saves, and exports live alongside serializeCurrentPuzzle.
    - External API: window.capyGenerator exposes devtools entry points; keep signatures stable when
      reorganizing internal wiring.

    Script organization
    -------------------
    1. Cached DOM references, constants, and default settings.
    2. Canvas metrics, view state, pointer capture, and custom cursor helpers.
    3. Generation + rendering pipeline (loadDefaultPuzzle, createPuzzleData, renderPuzzle, etc.).
    4. Palette interactions, keyboard/mouse handlers, and hint overlay animation loop.
    5. Autosave + storage encoding, save manager wiring, and UI refresh routines.
    6. window.capyGenerator bindings exported last for manual QA tooling.

    Function highlights
    -------------------
    - installBrowserZoomGuards(): Prevents browser zoom from intercepting wheel gestures on the
      canvas.
    - applyViewTransform(options): Pushes viewState pan/zoom changes to the stage and pointer
      overlays.
    - applyZoom(multiplier, clientX, clientY, options): Normalizes zoom gestures around the pointer
      focus and updates viewState.
    - resetView(options): Fits the puzzle to the viewport and recenters the stage.
    - loadSamplePuzzle(options) / loadDefaultPuzzle(options): Bootstrap the bundled sample or
      fallback puzzle payload.
    - createPuzzleData(image, options): Invokes the generation worker to quantize colors and
      segment regions.
    - applyPuzzleResult(data, metadata): Hydrates puzzle state, triggers canvas redraw, and updates
      metadata surfaces.
    - renderPuzzle() / renderPreview(): Draw the active puzzle and thumbnail preview using the
      shared render cache.
    - renderPalette(): Rebuilds the palette dock and accessibility metadata for the active colors.
    - attemptFillRegion(hit, { label }): Processes paint interactions, updates fills, and schedules
      autosave.
    - useHint(): Coordinates palette flashing + overlay animations to guide the next region.
    - updateCommandStates(): Enables/disables command rail buttons based on current puzzle state.
    - applyTheme(theme, options) / applyBackgroundColor(hex, options): Refresh UI theming tokens and
      persist preferences.
    - scheduleAutosave(reason) / persistAutosave(reason): Manage background save cadence and writes
      to storage.
    - saveCurrentSnapshot(): Captures a manual save entry and refreshes manager lists.
    - refreshGameSelection() / refreshSaveList(): Render save management surfaces from shared
      templates.
    - createGameSaveManager(): Wraps persistence with list, subscribe, and persist helpers for UI
      consumers.
  -->
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <title>Image to Color-by-Number</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: "Inter", "Segoe UI", -apple-system, BlinkMacSystemFont, system-ui,
          sans-serif;
        --ui-scale-user: 0.75;
        --ui-scale-auto: 1;
        --ui-scale: calc(var(--ui-scale-user, 1) * var(--ui-scale-auto, 1));
        --app-width: 100vw;
        --app-height: 100vh;
        --viewport-padding: calc(32px * var(--ui-scale));
        --rail-padding-block: calc(10px * var(--ui-scale));
        --rail-padding-inline: calc(20px * var(--ui-scale));
        --theme-body-bg: #000000;
        --theme-body-color: #e2e8f0;
        --theme-command-bg: rgba(15, 23, 42, 0.82);
        --theme-command-border: rgba(148, 163, 184, 0.28);
        --theme-command-text: rgba(226, 232, 240, 0.92);
        --theme-command-active-bg: rgba(37, 99, 235, 0.28);
        --theme-command-active-border: rgba(96, 165, 250, 0.55);
        --theme-command-active-text: rgba(226, 232, 240, 1);
        --theme-command-disabled-bg: rgba(15, 23, 42, 0.55);
        --theme-command-disabled-border: rgba(71, 85, 105, 0.35);
        --theme-command-disabled-text: rgba(148, 163, 184, 0.6);
        --theme-sheet-bg: rgba(2, 6, 23, 0.95);
        --theme-sheet-border: rgba(59, 130, 246, 0.4);
        --theme-sheet-shadow: 0 32px 80px rgba(8, 47, 73, 0.45);
        --theme-sheet-button-bg: rgba(148, 163, 184, 0.15);
        --theme-sheet-button-text: rgba(226, 232, 240, 0.8);
        --theme-sheet-button-border: rgba(148, 163, 184, 0.25);
        --theme-debug-border: rgba(59, 130, 246, 0.35);
        --theme-debug-bg: rgba(15, 23, 42, 0.85);
        --theme-hint-overlay: rgba(15, 23, 42, 0.82);
        --theme-hint-body-bg: rgba(2, 6, 23, 0.78);
        --theme-hint-body-border: rgba(59, 130, 246, 0.35);
        --theme-hint-body-text: rgba(226, 232, 240, 0.8);
        --theme-preview-overlay: rgba(2, 6, 23, 0.9);
        --theme-tooltip-bg: rgba(15, 23, 42, 0.9);
        --theme-tooltip-border: rgba(15, 23, 42, 0.9);
        --theme-keycap-bg: rgba(15, 23, 42, 0.65);
        --theme-keycap-border: rgba(148, 163, 184, 0.35);
        --theme-keycap-text: rgba(226, 232, 240, 0.9);
        --theme-muted-strong: rgba(148, 163, 184, 0.9);
        --theme-muted-text: rgba(226, 232, 240, 0.82);
        --theme-caption-text: rgba(148, 163, 184, 0.85);
        --theme-note-text: rgba(148, 163, 184, 0.8);
        --theme-input-bg: rgba(15, 23, 42, 0.85);
        --theme-input-border: rgba(148, 163, 184, 0.35);
        --theme-preview-canvas-bg: rgba(15, 23, 42, 0.8);
        --theme-preview-canvas-border: rgba(148, 163, 184, 0.3);
        --theme-chip-bg: rgba(15, 23, 42, 0.65);
        --theme-chip-border: rgba(148, 163, 184, 0.35);
        --theme-chip-text: rgba(226, 232, 240, 0.85);
        --theme-chip-hover-bg: rgba(37, 99, 235, 0.25);
        --theme-chip-hover-text: rgba(226, 232, 240, 0.95);
        --theme-chip-active-bg: rgba(59, 130, 246, 0.35);
        --theme-chip-active-border: rgba(147, 197, 253, 0.6);
        --theme-chip-active-text: rgba(226, 232, 240, 0.98);
        --theme-palette-dock-bg: rgba(2, 6, 23, 0.94);
        --theme-palette-dock-border: rgba(15, 23, 42, 0.85);
        --command-rail-top: calc(env(safe-area-inset-top, 0px) + 12px);
        --command-rail-height: calc(40px * var(--ui-scale));
        --stage-background: var(--theme-body-bg);
      }

      body[data-theme="dark"] {
        color-scheme: dark;
      }

      body[data-theme="light"] {
        color-scheme: light;
        --theme-body-bg: #f8fafc;
        --theme-body-color: #0f172a;
        --theme-command-bg: rgba(248, 250, 252, 0.9);
        --theme-command-border: rgba(15, 23, 42, 0.18);
        --theme-command-text: rgba(15, 23, 42, 0.86);
        --theme-command-active-bg: rgba(59, 130, 246, 0.16);
        --theme-command-active-border: rgba(37, 99, 235, 0.4);
        --theme-command-active-text: rgba(15, 23, 42, 0.92);
        --theme-command-disabled-bg: rgba(226, 232, 240, 0.75);
        --theme-command-disabled-border: rgba(148, 163, 184, 0.32);
        --theme-command-disabled-text: rgba(100, 116, 139, 0.7);
        --theme-sheet-bg: rgba(255, 255, 255, 0.9);
        --theme-sheet-border: rgba(15, 23, 42, 0.1);
        --theme-sheet-shadow: 0 24px 60px rgba(15, 23, 42, 0.25);
        --theme-sheet-button-bg: rgba(226, 232, 240, 0.85);
        --theme-sheet-button-text: rgba(15, 23, 42, 0.75);
        --theme-sheet-button-border: rgba(148, 163, 184, 0.35);
        --theme-debug-border: rgba(96, 165, 250, 0.35);
        --theme-debug-bg: rgba(226, 232, 240, 0.85);
        --theme-hint-overlay: rgba(248, 250, 252, 0.9);
        --theme-hint-body-bg: rgba(255, 255, 255, 0.95);
        --theme-hint-body-border: rgba(96, 165, 250, 0.35);
        --theme-hint-body-text: rgba(15, 23, 42, 0.78);
        --theme-preview-overlay: rgba(15, 23, 42, 0.75);
        --theme-tooltip-bg: rgba(15, 23, 42, 0.85);
        --theme-tooltip-border: rgba(15, 23, 42, 0.85);
        --theme-keycap-bg: rgba(226, 232, 240, 0.85);
        --theme-keycap-border: rgba(148, 163, 184, 0.45);
        --theme-keycap-text: rgba(15, 23, 42, 0.82);
        --theme-muted-strong: rgba(71, 85, 105, 0.95);
        --theme-muted-text: rgba(51, 65, 85, 0.85);
        --theme-caption-text: rgba(100, 116, 139, 0.85);
        --theme-note-text: rgba(100, 116, 139, 0.9);
        --theme-input-bg: rgba(255, 255, 255, 0.95);
        --theme-input-border: rgba(148, 163, 184, 0.35);
        --theme-preview-canvas-bg: rgba(248, 250, 252, 0.95);
        --theme-preview-canvas-border: rgba(148, 163, 184, 0.35);
        --theme-chip-bg: rgba(226, 232, 240, 0.9);
        --theme-chip-border: rgba(148, 163, 184, 0.35);
        --theme-chip-text: rgba(30, 41, 59, 0.85);
        --theme-chip-hover-bg: rgba(59, 130, 246, 0.25);
        --theme-chip-hover-text: rgba(15, 23, 42, 0.85);
        --theme-chip-active-bg: rgba(59, 130, 246, 0.35);
        --theme-chip-active-border: rgba(37, 99, 235, 0.5);
        --theme-chip-active-text: rgba(15, 23, 42, 0.85);
        --theme-palette-dock-bg: rgba(255, 255, 255, 0.9);
        --theme-palette-dock-border: rgba(148, 163, 184, 0.4);
      }

      body[data-theme="colorful"] {
        color-scheme: dark;
        --theme-body-bg: linear-gradient(145deg, #111827 0%, #1d1b52 40%, #6d1c8c 65%, #b91c1c 100%);
        --theme-body-color: #f8fafc;
        --theme-command-bg: rgba(30, 41, 59, 0.85);
        --theme-command-border: rgba(244, 114, 182, 0.45);
        --theme-command-text: rgba(248, 250, 252, 0.92);
        --theme-command-active-bg: rgba(244, 114, 182, 0.28);
        --theme-command-active-border: rgba(253, 186, 116, 0.75);
        --theme-command-active-text: rgba(15, 23, 42, 0.95);
        --theme-command-disabled-bg: rgba(30, 41, 59, 0.6);
        --theme-command-disabled-border: rgba(148, 163, 184, 0.4);
        --theme-command-disabled-text: rgba(226, 232, 240, 0.65);
        --theme-sheet-bg: rgba(17, 24, 39, 0.92);
        --theme-sheet-border: rgba(147, 51, 234, 0.45);
        --theme-sheet-shadow: 0 38px 90px rgba(17, 24, 39, 0.6);
        --theme-sheet-button-bg: rgba(244, 114, 182, 0.25);
        --theme-sheet-button-text: rgba(248, 250, 252, 0.9);
        --theme-sheet-button-border: rgba(253, 186, 116, 0.5);
        --theme-debug-border: rgba(244, 114, 182, 0.35);
        --theme-debug-bg: rgba(30, 41, 59, 0.82);
        --theme-hint-overlay: rgba(17, 24, 39, 0.82);
        --theme-hint-body-bg: rgba(30, 41, 59, 0.85);
        --theme-hint-body-border: rgba(253, 186, 116, 0.5);
        --theme-hint-body-text: rgba(248, 250, 252, 0.86);
        --theme-preview-overlay: rgba(17, 24, 39, 0.88);
        --theme-tooltip-bg: rgba(30, 41, 59, 0.92);
        --theme-tooltip-border: rgba(147, 51, 234, 0.6);
        --theme-keycap-bg: rgba(30, 41, 59, 0.7);
        --theme-keycap-border: rgba(244, 114, 182, 0.45);
        --theme-keycap-text: rgba(248, 250, 252, 0.9);
        --theme-muted-strong: rgba(244, 114, 182, 0.85);
        --theme-muted-text: rgba(253, 186, 116, 0.9);
        --theme-caption-text: rgba(244, 114, 182, 0.85);
        --theme-note-text: rgba(244, 114, 182, 0.82);
        --theme-input-bg: rgba(30, 41, 59, 0.8);
        --theme-input-border: rgba(244, 114, 182, 0.45);
        --theme-preview-canvas-bg: rgba(30, 41, 59, 0.78);
        --theme-preview-canvas-border: rgba(244, 114, 182, 0.45);
        --theme-chip-bg: rgba(30, 41, 59, 0.78);
        --theme-chip-border: rgba(244, 114, 182, 0.5);
        --theme-chip-text: rgba(248, 250, 252, 0.9);
        --theme-chip-hover-bg: rgba(244, 114, 182, 0.32);
        --theme-chip-hover-text: rgba(15, 23, 42, 0.95);
        --theme-chip-active-bg: rgba(253, 186, 116, 0.45);
        --theme-chip-active-border: rgba(244, 114, 182, 0.65);
        --theme-chip-active-text: rgba(15, 23, 42, 0.95);
        --theme-palette-dock-bg: rgba(17, 24, 39, 0.88);
        --theme-palette-dock-border: rgba(244, 114, 182, 0.4);
      }

      * {
        box-sizing: border-box;
      }

      html {
        touch-action: manipulation;
      }

      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      body {
        margin: 0;
        min-height: 100vh;
        min-height: 100dvh;
        background: var(--stage-background);
        color: var(--theme-body-color);
        overflow: hidden;
        font-size: calc(16px * var(--ui-scale));
        touch-action: manipulation;
        overscroll-behavior: none;
      }

      body.dragging {
        cursor: copy;
      }

      body.panning {
        cursor: grabbing;
      }

      #app {
        position: relative;
        width: min(var(--app-width, 100vw), 100vw);
        height: min(var(--app-height, 100vh), 100vh);
        overflow: hidden;
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        grid-template-rows: 1fr auto;
      }

      @supports (height: 100dvh) {
        #app {
          height: min(var(--app-height, 100dvh), 100dvh);
        }
      }

      #commandRail {
        position: absolute;
        top: var(--command-rail-top);
        left: calc(env(safe-area-inset-left, 0px) + 12px);
        display: flex;
        align-items: center;
        gap: calc(6px * var(--ui-scale));
        padding: 0;
        margin: 0;
        border: 0;
        background: none;
        box-shadow: none;
        backdrop-filter: none;
        flex-wrap: nowrap;
        overflow-x: auto;
        overflow-y: hidden;
        touch-action: manipulation;
        z-index: 3;
        scrollbar-width: none;
        width: max-content;
        max-width: calc(100vw - env(safe-area-inset-left, 0px) - env(safe-area-inset-right, 0px) - 24px);
      }

      #commandRail::-webkit-scrollbar {
        display: none;
      }

      #commandRail button {
        display: inline-flex;
        align-items: center;
        gap: calc(6px * var(--ui-scale));
        padding: calc(4px * var(--ui-scale)) calc(10px * var(--ui-scale));
        border-radius: calc(6px * var(--ui-scale));
        border: 1px solid color-mix(in srgb, var(--theme-command-border) 60%, transparent);
        background: color-mix(in srgb, var(--theme-command-bg) 88%, transparent);
        color: var(--theme-command-text);
        font-size: calc(14px * var(--ui-scale));
        font-weight: 500;
        line-height: 1;
        white-space: nowrap;
        flex: 0 0 auto;
        transition: border-color 140ms ease, background 140ms ease, color 140ms ease;
      }

      #commandRail button.active {
        background: color-mix(in srgb, var(--theme-command-active-bg) 70%, transparent);
        border-color: color-mix(in srgb, var(--theme-command-active-border) 70%, transparent);
        color: var(--theme-command-active-text);
      }

      #commandRail button .icon {
        font-size: 1.05rem;
        line-height: 1;
      }

      #commandRail .label {
        font-size: calc(13px * var(--ui-scale));
        line-height: 1;
        white-space: nowrap;
      }

      #commandRail button:not(:disabled):hover,
      #commandRail button:not(:disabled):focus-visible {
        background: color-mix(in srgb, var(--theme-command-active-bg) 55%, transparent);
        border-color: color-mix(in srgb, var(--theme-command-active-border) 70%, transparent);
        color: var(--theme-command-active-text);
      }

      #commandRail button:focus-visible {
        outline: 2px solid color-mix(in srgb, var(--theme-command-active-border) 70%, transparent);
        outline-offset: 2px;
      }

      #commandRail button:disabled {
        background: color-mix(in srgb, var(--theme-command-disabled-bg) 70%, transparent);
        border-color: color-mix(in srgb, var(--theme-command-disabled-border) 70%, transparent);
        color: var(--theme-command-disabled-text);
      }

      body[data-orientation="portrait"] #commandRail {
        gap: calc(4px * var(--ui-scale));
      }

      body.compact-commands #commandRail {
        gap: calc(4px * var(--ui-scale));
      }

      body.compact-commands #commandRail .label {
        display: none;
      }

      body[data-orientation="portrait"] #paletteDock {
        gap: calc(10px * var(--ui-scale));
      }

      #viewport {
        position: relative;
        width: 100%;
        height: 100%;
        display: grid;
        place-items: center;
        padding: calc(16px * var(--ui-scale));
        padding-top: calc(var(--command-rail-top) + var(--command-rail-height));
        overflow: hidden;
        background: none;
        touch-action: none;
        cursor: grab;
      }

      body[data-orientation="portrait"] #viewport {
        padding-top: calc(var(--command-rail-top) + var(--command-rail-height));
      }

      #canvasStage {
        position: absolute;
        top: 50%;
        left: 50%;
        --pan-x: 0px;
        --pan-y: 0px;
        transform: translate3d(calc(-50% + var(--pan-x)), calc(-50% + var(--pan-y)), 0);
        display: flex;
        align-items: center;
        justify-content: center;
        touch-action: none;
        will-change: transform;
        z-index: 1;
        cursor: grab;
      }

      body.custom-cursor:not(.panning) #canvasStage {
        cursor: none;
      }

      #pointerOverlay {
        --cursor-x: -9999px;
        --cursor-y: -9999px;
        --cursor-ring: rgba(226, 232, 240, 0.95);
        --cursor-fill: rgba(15, 23, 42, 0.55);
        --cursor-swatch: transparent;
        position: fixed;
        top: 0;
        left: 0;
        z-index: 6;
        pointer-events: none;
        transform: translate3d(var(--cursor-x), var(--cursor-y), 0);
        opacity: 0;
        transition: opacity 0.12s ease;
      }

      #pointerOverlay.active {
        opacity: 1;
      }

      body:not(.custom-cursor) #pointerOverlay {
        opacity: 0;
      }

      body.panning #pointerOverlay,
      body.dragging #pointerOverlay {
        opacity: 0;
      }

      #pointerOverlay .pointer-indicator {
        width: calc(20px * var(--ui-scale));
        height: calc(20px * var(--ui-scale));
        border-radius: 50%;
        border: 2px solid var(--cursor-ring);
        background: var(--cursor-fill);
        box-shadow: 0 6px 14px rgba(2, 6, 23, 0.45), 0 0 0 1px rgba(15, 23, 42, 0.6);
        transform: translate(-50%, -50%);
        backdrop-filter: blur(4px);
      }

      #pointerOverlay.matching .pointer-indicator {
        box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.42), 0 8px 18px rgba(2, 6, 23, 0.4);
      }

      #pointerOverlay.mismatch .pointer-indicator {
        box-shadow: 0 0 0 3px rgba(248, 113, 113, 0.45), 0 8px 18px rgba(2, 6, 23, 0.4);
      }

      #pointerOverlay.filled .pointer-indicator {
        box-shadow: 0 0 0 3px rgba(148, 163, 184, 0.35), 0 8px 18px rgba(2, 6, 23, 0.4);
      }

      #pointerOverlay .pointer-tooltip {
        display: inline-flex;
        align-items: center;
        gap: calc(6px * var(--ui-scale));
        min-width: 0;
        padding: calc(4px * var(--ui-scale)) calc(6px * var(--ui-scale));
        border-radius: calc(6px * var(--ui-scale));
        background: rgba(248, 250, 252, 0.95);
        border: 1px solid rgba(148, 163, 184, 0.35);
        box-shadow: 0 12px 24px rgba(2, 6, 23, 0.25);
        transform: translate(calc(-50% + 14px), calc(-50% + 20px));
        font-size: calc(14px * var(--ui-scale));
        line-height: 1;
      }

      #pointerOverlay.matching .pointer-tooltip {
        border-color: rgba(34, 197, 94, 0.55);
      }

      #pointerOverlay.mismatch .pointer-tooltip {
        border-color: rgba(248, 113, 113, 0.55);
      }

      #pointerOverlay.filled .pointer-tooltip {
        border-color: rgba(148, 163, 184, 0.5);
      }

      #pointerOverlay .pointer-number {
        font-weight: 600;
        letter-spacing: 0.02em;
        color: rgba(15, 23, 42, 0.88);
        text-shadow: 0 0 4px rgba(15, 23, 42, 0.35);
      }

      #pointerOverlay .pointer-swatch {
        width: calc(14px * var(--ui-scale));
        height: calc(14px * var(--ui-scale));
        border-radius: calc(4px * var(--ui-scale));
        border: 1px solid rgba(148, 163, 184, 0.7);
        background: var(--cursor-swatch);
        box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.4);
      }

      #canvasTransform {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        will-change: width, height;
      }

      #viewport::before {
        content: none;
      }

      #puzzleCanvas {
        max-width: 100%;
        max-height: 100%;
        width: auto;
        height: auto;
        border-radius: 0;
        background: none;
        border: none;
        box-shadow: none;
        image-rendering: pixelated;
        touch-action: none;
      }

      canvas.renderer-surface {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: block;
        pointer-events: none;
        user-select: none;
      }


        #generatorSheet .detail-callout {
          text-align: left;
        }

        #generatorSheet .detail-picker {
          justify-content: flex-start;
        }
      button {
        font: inherit;
        border-radius: 999px;
        border: none;
        padding: calc(10px * var(--ui-scale)) calc(22px * var(--ui-scale));
        background: rgba(96, 165, 250, 0.92);
        color: #021027;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
      }

      button:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(37, 99, 235, 0.35);
        background: rgba(147, 197, 253, 0.96);
      }

      button:disabled {
        background: rgba(148, 163, 184, 0.35);
        color: rgba(226, 232, 240, 0.7);
        cursor: not-allowed;
        box-shadow: none;
      }

        #paletteDock {
          position: sticky;
          bottom: 0;
          left: 0;
          right: 0;
        width: 100%;
        max-width: 100%;
        display: flex;
        flex-direction: column;
        gap: calc(6px * var(--ui-scale));
        align-items: stretch;
        justify-content: flex-start;
        padding: 0;
        background: var(--theme-palette-dock-bg);
        border-top: 1px solid var(--theme-palette-dock-border);
        overflow: visible;
          z-index: 3;
        }

        #palette {
          flex: 1 1 auto;
          min-width: 0;
          width: 100%;
          max-width: 100%;
        display: flex;
        gap: 0;
        overflow-x: auto;
        overflow-y: visible;
        touch-action: pan-x;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: thin;
        padding-block-end: calc(2px * var(--ui-scale));
      }

      #palette::-webkit-scrollbar {
        height: calc(6px * var(--ui-scale));
      }

      #palette::-webkit-scrollbar-thumb {
        background: rgba(148, 163, 184, 0.45);
      }

      .control select {
        appearance: none;
        border: 1px solid rgba(148, 163, 184, 0.35);
        border-radius: calc(10px * var(--ui-scale));
        background: rgba(15, 23, 42, 0.82);
        color: inherit;
        font: inherit;
        padding: calc(6px * var(--ui-scale)) calc(28px * var(--ui-scale))
          calc(6px * var(--ui-scale)) calc(12px * var(--ui-scale));
        line-height: 1.2;
        cursor: pointer;
        box-shadow: 0 1px 0 rgba(15, 23, 42, 0.35);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
        background-image: linear-gradient(45deg, transparent 50%, rgba(148, 163, 184, 0.75) 50%),
          linear-gradient(135deg, rgba(148, 163, 184, 0.75) 50%, transparent 50%);
        background-position: calc(100% - 18px) center, calc(100% - 12px) center;
        background-size: calc(6px * var(--ui-scale)) calc(6px * var(--ui-scale));
        background-repeat: no-repeat;
        min-width: min(calc(220px * var(--ui-scale)), 100%);
      }

      .control select:focus {
        outline: none;
        border-color: rgba(96, 165, 250, 0.55);
        box-shadow: 0 0 0 calc(2px * var(--ui-scale)) rgba(37, 99, 235, 0.25);
      }

      .control select:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        background-image: none;
      }

      body[data-theme="light"] .control select {
        background: rgba(255, 255, 255, 0.95);
        border-color: rgba(15, 23, 42, 0.18);
        box-shadow: 0 1px 0 rgba(148, 163, 184, 0.35);
        color: rgba(15, 23, 42, 0.86);
        background-image: linear-gradient(45deg, transparent 50%, rgba(71, 85, 105, 0.65) 50%),
          linear-gradient(135deg, rgba(71, 85, 105, 0.65) 50%, transparent 50%);
      }

      body[data-theme="light"] .control select:focus {
        border-color: rgba(37, 99, 235, 0.45);
        box-shadow: 0 0 0 calc(2px * var(--ui-scale)) rgba(59, 130, 246, 0.25);
      }

      body[data-theme="light"] .control select:disabled {
        opacity: 0.75;
        color: rgba(148, 163, 184, 0.8);
      }

      .control {
        display: flex;
        flex-direction: column;
        gap: calc(6px * var(--ui-scale));
        font-size: 0.95rem;
      }

      .control > span {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
      }

      .control output {
        font-size: 0.85rem;
        color: rgba(148, 163, 184, 0.9);
      }

      .mouse-control-group {
        display: flex;
        flex-direction: column;
        gap: calc(8px * var(--ui-scale));
      }

      .mouse-control-title {
        font-weight: 600;
        font-size: 0.95rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .mouse-control-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(calc(180px * var(--ui-scale)), 1fr));
        gap: calc(12px * var(--ui-scale));
      }

      .mouse-control-option {
        flex: 1 1 auto;
      }

      details.advanced-options {
        margin-top: calc(16px * var(--ui-scale));
        padding: calc(12px * var(--ui-scale));
        border-radius: calc(12px * var(--ui-scale));
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.45);
      }

      details.advanced-options[open] {
        background: rgba(15, 23, 42, 0.6);
      }

      details.advanced-options summary {
        list-style: none;
        cursor: pointer;
        font-weight: 600;
        margin-bottom: calc(8px * var(--ui-scale));
        display: flex;
        align-items: center;
        gap: calc(6px * var(--ui-scale));
      }

      details.advanced-options summary::after {
        content: "▾";
        font-size: 0.85rem;
        opacity: 0.7;
        transform: rotate(0deg);
        transition: transform 0.2s ease;
      }

      details.advanced-options[open] summary::after {
        transform: rotate(180deg);
      }

      #imageDescription {
        width: 100%;
        min-height: calc(120px * var(--ui-scale));
        padding: calc(10px * var(--ui-scale));
        border-radius: calc(12px * var(--ui-scale));
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(15, 23, 42, 0.85);
        color: inherit;
        font: inherit;
        resize: vertical;
      }

      #imageDescription:focus {
        outline: none;
        border-color: rgba(96, 165, 250, 0.7);
        box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.25);
      }

      #imageDescription::placeholder {
        color: rgba(148, 163, 184, 0.7);
      }

      .chatgpt-link {
        display: inline-flex;
        align-items: center;
        gap: 0.35em;
        font-weight: 600;
        color: rgba(96, 165, 250, 0.95);
        text-decoration: none;
      }

      .chatgpt-link:hover,
      .chatgpt-link:focus-visible {
        color: rgba(147, 197, 253, 0.95);
        text-decoration: underline;
        outline: none;
      }

      input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        height: 6px;
        border-radius: 999px;
        background: rgba(51, 65, 85, 0.9);
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: rgba(96, 165, 250, 0.95);
        border: none;
        box-shadow: 0 2px 6px rgba(37, 99, 235, 0.4);
        cursor: pointer;
      }

      input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: rgba(96, 165, 250, 0.95);
        border: none;
        box-shadow: 0 2px 6px rgba(37, 99, 235, 0.4);
        cursor: pointer;
      }

      input[type="color"] {
        width: 100%;
        height: 38px;
        border-radius: 12px;
        border: 1px solid var(--theme-input-border);
        background: var(--theme-input-bg);
        padding: 0;
        cursor: pointer;
      }

      input[type="color"]::-webkit-color-swatch,
      input[type="color"]::-moz-color-swatch {
        border: none;
        border-radius: 10px;
      }

      .control-note {
        margin-top: -8px;
        font-size: 0.8rem;
        color: var(--theme-note-text);
      }

      .panel-actions {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
      }

      .panel-actions button {
        border-radius: 12px;
      }

      #downloadJson {
        width: 100%;
        border-radius: 12px;
        padding: 10px 0;
      }

      .swatch {
        flex: 0 0 calc(72px * var(--ui-scale));
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: calc(64px * var(--ui-scale));
        min-height: calc(72px * var(--ui-scale));
        padding: 0;
        border: 0;
        border-radius: 0;
        background: var(--swatch-color, rgba(15, 23, 42, 0.85));
        color: var(--swatch-label-color, rgba(248, 250, 252, 0.98));
        text-align: center;
        cursor: pointer;
        box-shadow: inset 0 0 0 1px var(--swatch-outline, rgba(15, 23, 42, 0.6));
        transition: box-shadow 0.18s ease;
        position: relative;
        overflow: visible;
      }

      .swatch:hover {
        box-shadow: inset 0 0 0 2px var(--swatch-outline, rgba(15, 23, 42, 0.75));
      }

      .swatch:focus-visible {
        outline: 2px solid rgba(148, 163, 184, 0.85);
        outline-offset: -2px;
      }

      .swatch.active {
        box-shadow: inset 0 0 0 3px rgba(96, 165, 250, 0.9);
      }

      .swatch.done {
        opacity: 0.55;
      }

      .swatch.flash {
        animation: swatchHintPulse 0.48s ease;
      }

      @keyframes swatchHintPulse {
        0% {
          box-shadow: inset 0 0 0 4px rgba(96, 165, 250, 0.85);
        }
        60% {
          box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.4);
        }
        100% {
          box-shadow: inset 0 0 0 1px var(--swatch-outline, rgba(15, 23, 42, 0.6));
        }
      }

      .swatch .label {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.05rem;
        font-weight: 600;
        line-height: 1.2;
        max-width: 100%;
        z-index: 1;
        padding: 0;
        color: inherit;
      }

      .swatch .swatch-tooltip {
        position: absolute;
        inset-inline: 50%;
        bottom: calc(100% + 8px);
        transform: translate(-50%, 4px) scale(0.98);
        padding: calc(6px * var(--ui-scale)) calc(10px * var(--ui-scale));
        border-radius: calc(8px * var(--ui-scale));
        background: var(--theme-tooltip-bg);
        color: rgba(248, 250, 252, 0.95);
        font-size: 0.75rem;
        font-weight: 500;
        white-space: nowrap;
        box-shadow: 0 6px 20px rgba(2, 6, 23, 0.45);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.16s ease, transform 0.16s ease;
        z-index: 10;
      }

      .swatch .swatch-tooltip::after {
        content: "";
        position: absolute;
        inset-inline-start: 50%;
        top: 100%;
        transform: translateX(-50%);
        border-width: 6px 6px 0 6px;
        border-style: solid;
        border-color: var(--theme-tooltip-border) transparent transparent transparent;
      }

      .swatch:hover .swatch-tooltip,
      .swatch:focus-visible .swatch-tooltip {
        opacity: 1;
        transform: translate(-50%, 0) scale(1);
      }

      .swatch .label > strong {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: calc(28px * var(--ui-scale));
        padding: 0;
        border-radius: 0;
        border: 0;
        background: transparent;
        font-size: 1.15rem;
        letter-spacing: 0.01em;
        color: currentColor;
        text-shadow: var(--swatch-label-shadow, none);
      }

      .sheet {
        position: fixed;
        top: calc(
          env(safe-area-inset-top, 0px) +
            var(--rail-padding-block) +
            var(--command-rail-height) +
            calc(16px * var(--ui-scale))
        );
        right: calc(env(safe-area-inset-right, 0px) + 24px);
        bottom: calc(env(safe-area-inset-bottom, 0px) + 24px);
        width: min(380px, calc(100vw - 48px));
        padding: 24px;
        display: flex;
        flex-direction: column;
        gap: 18px;
        border-radius: 22px;
        background: var(--theme-sheet-bg);
        border: 1px solid var(--theme-sheet-border);
        box-shadow: var(--theme-sheet-shadow);
        backdrop-filter: blur(22px);
        z-index: 6;
        opacity: 1;
        transition: opacity 0.2s ease;
      }

      .sheet.hidden {
        opacity: 0;
        pointer-events: none;
        visibility: hidden;
      }

      .sheet-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
      }

      .sheet-header h2 {
        margin: 0;
        font-size: 1.25rem;
      }

      .close-button {
        padding: 6px 14px;
        border-radius: 12px;
        background: var(--theme-sheet-button-bg);
        color: var(--theme-sheet-button-text);
        border: 1px solid var(--theme-sheet-button-border);
      }

      .sheet-body {
        display: flex;
        flex-direction: column;
        gap: 22px;
        overflow-y: auto;
        padding-right: 4px;
      }

      .settings-body {
        gap: 18px;
      }

      .settings-tabs {
        display: flex;
        flex-wrap: wrap;
        gap: calc(8px * var(--ui-scale));
      }

      .settings-tab {
        flex: 1 1 120px;
        padding: calc(8px * var(--ui-scale)) calc(12px * var(--ui-scale));
        border-radius: calc(12px * var(--ui-scale));
        border: 1px solid var(--theme-sheet-button-border);
        background: var(--theme-sheet-button-bg);
        color: var(--theme-sheet-button-text);
        font-size: 0.95rem;
        letter-spacing: 0.01em;
        transition: background 0.16s ease, border-color 0.16s ease, color 0.16s ease;
      }

      body[data-theme="light"] .settings-tab {
        background: rgba(226, 232, 240, 0.85);
      }

      .settings-tab[aria-selected="true"] {
        background: var(--theme-command-active-bg);
        border-color: var(--theme-command-active-border);
        color: var(--theme-command-active-text);
      }

      .settings-tab:focus-visible {
        outline: 2px solid rgba(96, 165, 250, 0.75);
        outline-offset: 2px;
      }

      .settings-panel {
        display: flex;
        flex-direction: column;
        gap: 22px;
      }

      .settings-panel[hidden] {
        display: none;
      }

      .generator-import-notice,
      .generator-progress {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: calc(14px * var(--ui-scale));
        border-radius: calc(18px * var(--ui-scale));
      }

      .generator-import-notice {
        border: 1px solid rgba(59, 130, 246, 0.45);
        background: rgba(59, 130, 246, 0.16);
        color: var(--theme-command-text);
      }

      body[data-theme="light"] .generator-import-notice {
        background: rgba(191, 219, 254, 0.75);
        border-color: rgba(59, 130, 246, 0.35);
      }

      .generator-import-title {
        margin: 0;
        font-size: 1.05rem;
        font-weight: 600;
      }

      .generator-import-title strong {
        font-weight: 700;
      }

      .generator-import-description {
        margin: 0;
        font-size: 0.95rem;
        color: var(--theme-caption-text);
      }

      .generator-import-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
      }

      .generator-url-form {
        display: grid;
        gap: calc(12px * var(--ui-scale));
      }

      .generator-url-actions {
        display: flex;
        flex-wrap: wrap;
        gap: calc(12px * var(--ui-scale));
        align-items: center;
      }

      .generator-url-actions button[type="submit"] {
        flex: 0 0 auto;
      }

      .generator-url-error {
        margin: 0;
        font-weight: 600;
        color: #f87171;
      }

      body[data-theme="light"] .generator-url-error {
        color: #dc2626;
      }

      .generator-progress {
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(15, 23, 42, 0.6);
        color: var(--theme-command-text);
      }

      body[data-theme="light"] .generator-progress {
        background: rgba(226, 232, 240, 0.85);
        border-color: rgba(148, 163, 184, 0.5);
      }

      .generator-progress-message {
        margin: 0;
        font-weight: 600;
        letter-spacing: 0.01em;
      }

      .generator-progress-meter {
        position: relative;
        width: 100%;
        height: calc(6px * var(--ui-scale));
        border-radius: 999px;
        background: rgba(148, 163, 184, 0.25);
        overflow: hidden;
        transition: opacity 0.25s ease;
        opacity: 0;
      }

      .generator-progress-meter[aria-hidden="false"] {
        opacity: 1;
      }

      body[data-theme="light"] .generator-progress-meter {
        background: rgba(148, 163, 184, 0.35);
      }

      .generator-progress-bar {
        width: 0%;
        height: 100%;
        border-radius: inherit;
        background: rgba(59, 130, 246, 0.92);
        box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.4);
        transition: width 0.24s ease;
      }

      .sheet-section {
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .sheet-section h3 {
        margin: 0;
        font-size: 1.05rem;
        letter-spacing: 0.02em;
      }

      .save-manager {
        display: grid;
        gap: calc(12px * var(--ui-scale));
      }

      .save-start-actions {
        display: flex;
        flex-wrap: wrap;
        gap: calc(12px * var(--ui-scale));
      }

      .save-start-actions button {
        flex: 1 1 180px;
      }

      .save-manager h2 {
        margin: 0;
        font-size: 1.1rem;
      }

      .save-manager-empty {
        margin: 0;
        font-size: 0.85rem;
        color: var(--theme-caption-text);
      }

      .command-list {
        display: grid;
        grid-template-columns: minmax(0, auto) 1fr;
        gap: 6px 12px;
        margin: 0;
        padding: 0;
        list-style: none;
      }

      .command-list dt {
        font-weight: 600;
        color: var(--theme-muted-strong);
        font-size: 0.95rem;
      }

      .command-list dd {
        margin: 0;
        font-size: 0.95rem;
      }

      .control-list {
        margin: 0;
        padding-left: 18px;
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 0.95rem;
        list-style: none;
      }

      .readme-preview {
        margin: 0;
        padding: 16px;
        border-radius: 16px;
        border: 1px solid var(--theme-sheet-border);
        background: var(--theme-sheet-bg);
        color: var(--theme-body-color);
        max-height: 320px;
        overflow: auto;
        font-size: 0.9rem;
        line-height: 1.6;
        white-space: normal;
        word-break: break-word;
      }

      .readme-preview--plaintext {
        white-space: pre-wrap;
        font-family: 'JetBrains Mono', 'SFMono-Regular', ui-monospace, SFMono-Regular, Menlo, Monaco,
          Consolas, 'Liberation Mono', 'Courier New', monospace;
        font-size: 0.85rem;
      }

      .readme-preview h1,
      .readme-preview h2,
      .readme-preview h3,
      .readme-preview h4,
      .readme-preview h5,
      .readme-preview h6 {
        margin-top: 1.5em;
        margin-bottom: 0.6em;
      }

      .readme-preview h1:first-child,
      .readme-preview h2:first-child,
      .readme-preview h3:first-child,
      .readme-preview h4:first-child,
      .readme-preview h5:first-child,
      .readme-preview h6:first-child {
        margin-top: 0;
      }

      .readme-preview p,
      .readme-preview ul,
      .readme-preview ol {
        margin: 0 0 1em;
      }

      .readme-preview ul,
      .readme-preview ol {
        padding-left: 1.4em;
      }

      .readme-preview pre {
        border-radius: 12px;
        border: 1px solid var(--theme-debug-border);
        background: rgba(15, 23, 42, 0.35);
        padding: 12px;
        white-space: pre-wrap;
        overflow-x: auto;
      }

      body[data-theme="light"] .readme-preview pre {
        background: rgba(226, 232, 240, 0.6);
      }

      .readme-preview a {
        color: var(--theme-command-active-text);
      }

      .control-list kbd {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 1.4em;
        padding: 2px 6px;
        margin-right: 6px;
        border-radius: 6px;
        border: 1px solid var(--theme-keycap-border);
        background: var(--theme-keycap-bg);
        font-family: 'JetBrains Mono', 'SFMono-Regular', ui-monospace, SFMono-Regular, Menlo, Monaco,
          Consolas, 'Liberation Mono', 'Courier New', monospace;
        font-size: 0.85rem;
        color: var(--theme-keycap-text);
      }

      .debug-log {
        border-radius: 16px;
        border: 1px solid var(--theme-debug-border);
        background: var(--theme-debug-bg);
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-height: 240px;
        overflow-y: auto;
      }

      .debug-log .log-entry {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 4px 10px;
        align-items: baseline;
        font-size: 0.9rem;
      }

      .debug-log time {
        font-family: 'JetBrains Mono', 'SFMono-Regular', ui-monospace, SFMono-Regular, Menlo, Monaco,
          Consolas, 'Liberation Mono', 'Courier New', monospace;
        font-size: 0.8rem;
        color: rgba(148, 163, 184, 0.9);
      }

      .debug-log span {
        color: rgba(226, 232, 240, 0.95);
      }

      .log-empty {
        margin: 0;
        font-style: italic;
        color: rgba(148, 163, 184, 0.8);
      }

      .log-actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
      }

      .sheet-actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
      }

      .toggle {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 0.95rem;
      }

      .toggle input {
        width: 18px;
        height: 18px;
      }

      .save-manager-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin: 12px 0 0;
        padding: 0;
      }

      .save-manager-actions {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 16px;
      }

      .save-manager-actions button {
        width: 100%;
      }

      .save-entry {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 14px;
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.75);
        border: 1px solid rgba(59, 130, 246, 0.2);
      }

      .save-entry header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }

      .save-entry-badge {
        font-size: 0.7rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        padding: 2px 8px;
        border-radius: 999px;
        background: rgba(250, 204, 21, 0.2);
        color: rgba(253, 224, 71, 0.9);
        font-weight: 600;
        white-space: nowrap;
      }

      .save-entry time {
        font-size: 0.8rem;
        color: rgba(148, 163, 184, 0.8);
      }

      .save-entry[data-loaded="true"] {
        border-color: rgba(96, 165, 250, 0.6);
        box-shadow: 0 0 0 1px rgba(96, 165, 250, 0.35);
      }

      .save-entry-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 4px 12px;
        font-size: 0.9rem;
        color: rgba(226, 232, 240, 0.9);
      }

      .save-entry-storage {
        color: rgba(148, 197, 255, 0.95);
      }

      .save-entry-status {
        font-size: 0.85rem;
        color: rgba(96, 165, 250, 0.9);
      }

      .save-actions {
        display: flex;
        gap: 8px;
      }

      .save-actions button {
        flex: 1;
        border-radius: 10px;
        padding: 8px 12px;
      }

      @media (max-width: 1024px) {
        #commandRail {
          flex-wrap: wrap;
          justify-content: flex-start;
        }
      }

      @media (max-width: 720px) {
        #viewport {
          padding: calc(12px * var(--ui-scale));
          padding-top: calc(var(--command-rail-top) + var(--command-rail-height));
        }

        body[data-orientation="portrait"] #viewport {
          padding-top: calc(var(--command-rail-top) + var(--command-rail-height));
        }

        #paletteDock {
          flex-direction: column;
          align-items: stretch;
          gap: 12px;
        }
      }
    </style>
  </head>
  <body data-theme="dark">
    <div id="app">
      <header id="commandRail" aria-label="Game controls">
        <button
          id="previewToggle"
          type="button"
          data-testid="preview-toggle"
          aria-label="Show preview"
          title="Show preview"
          disabled
        >
          <span class="icon" aria-hidden="true">🖼</span>
          <span class="label">Preview</span>
        </button>
        <button
          id="generatorButton"
          type="button"
          data-testid="generator-button"
          aria-label="Generator options"
          title="Generator options"
        >
          <span class="icon" aria-hidden="true">🎛</span>
          <span class="label">Generator</span>
        </button>
        <button
          id="fullscreenButton"
          type="button"
          data-testid="fullscreen-button"
          aria-label="Enter fullscreen"
          title="Enter fullscreen"
        >
          <span class="icon" aria-hidden="true">⛶</span>
          <span class="label">Fullscreen</span>
        </button>
        <button
          id="importButton"
          type="button"
          data-testid="import-button"
          aria-label="Import"
          title="Import"
        >
          <span class="icon" aria-hidden="true">⬆</span>
          <span class="label">Import</span>
        </button>
        <button
          id="saveManagerButton"
          type="button"
          data-testid="save-manager-button"
          aria-label="Save manager"
          title="Save manager"
        >
          <span class="icon" aria-hidden="true">💾</span>
          <span class="label">Saves</span>
        </button>
        <button
          id="helpButton"
          type="button"
          data-testid="help-button"
          aria-label="Help &amp; shortcuts"
          title="Help &amp; shortcuts"
        >
          <span class="icon" aria-hidden="true">ℹ</span>
          <span class="label">Help</span>
        </button>
        <button
          id="settingsButton"
          type="button"
          data-testid="settings-button"
          aria-label="Settings"
          title="Settings"
        >
          <span class="icon" aria-hidden="true">⚙</span>
          <span class="label">Settings</span>
        </button>
      </header>
      <div id="viewport">
        <div id="canvasStage">
          <div id="canvasTransform">
            <canvas
              id="puzzleCanvas"
              data-testid="puzzle-canvas"
              width="640"
              height="480"
            ></canvas>
          </div>
        </div>
        <div id="pointerOverlay" aria-hidden="true">
          <div class="pointer-indicator"></div>
          <div class="pointer-tooltip">
            <span class="pointer-swatch" data-pointer-color-swatch aria-hidden="true"></span>
            <strong class="pointer-number" data-pointer-number></strong>
          </div>
        </div>
      </div>
        <footer id="paletteDock" aria-label="Palette dock" data-testid="palette-dock">
          <div id="palette" role="list"></div>
        </footer>
    </div>
    <input id="fileInput" type="file" accept=".json,.capy,image/*" hidden />
    <div
      id="saveManagerSheet"
      class="sheet hidden"
      role="dialog"
      aria-labelledby="saveManagerTitle"
      aria-hidden="true"
    >
      <div class="sheet-header">
        <h2 id="saveManagerTitle">Manage saves</h2>
        <button type="button" class="close-button" data-sheet-close="saves">Close</button>
      </div>
      <div class="sheet-body">
        <section class="sheet-section" aria-labelledby="saveStartHeading">
          <h3 id="saveStartHeading" class="visually-hidden">Puzzle sources</h3>
          <div class="save-start-actions">
            <button
              id="selectImage"
              type="button"
              aria-label="Upload image or JSON puzzle"
            >
              Upload Image
            </button>
            <button
              id="samplePuzzle"
              type="button"
              data-action="load-sample"
              aria-label="Load capybara sample puzzle"
            >
              Load capybara sample
            </button>
          </div>
        </section>
        <section
          class="sheet-section save-manager"
          role="group"
          aria-labelledby="saveManagerTitle"
          data-save-section="dialog"
        >
          <div
            class="save-manager-list"
            data-save-list
            aria-live="polite"
            aria-labelledby="saveManagerTitle"
            role="list"
          ></div>
          <p class="save-manager-empty" data-save-empty hidden>
            No saves yet. Create one above to start autosaving progress.
          </p>
          <div class="save-manager-actions">
            <button type="button" data-save-snapshot disabled>Save current puzzle</button>
            <button type="button" data-reset-progress disabled>Reset puzzle progress</button>
            <button id="downloadJson" type="button" disabled>Export puzzle JSON</button>
          </div>
        </section>
        <section class="sheet-section" aria-labelledby="storageHeading">
          <h3 id="storageHeading">Save storage</h3>
          <p id="saveStorageSummary" class="control-note"></p>
          <label class="control">
            <span>Stored image size <output data-for="sourceImageLimit">1 MB</output></span>
            <select id="sourceImageLimit">
              <option value="262144">256 KB</option>
              <option value="524288">512 KB</option>
              <option value="1048576" selected>1 MB</option>
              <option value="2097152">2 MB</option>
              <option value="5242880">5 MB</option>
            </select>
          </label>
          <p class="control-note">
            Caps the compressed original image that ships with saves and exports. Changes apply to the next puzzle you generate
            or import.
          </p>
          <div class="log-actions">
            <button id="deleteAllSaves" type="button">Delete all saves</button>
          </div>
        </section>
      </div>
    </div>
    <div
      id="helpSheet"
      class="sheet hidden"
      role="dialog"
      aria-labelledby="helpTitle"
      aria-hidden="true"
    >
      <div class="sheet-header">
        <h2 id="helpTitle">Help &amp; shortcuts</h2>
        <button type="button" class="close-button" data-sheet-close="help">Close</button>
      </div>
      <div class="sheet-body">
        <section class="sheet-section" aria-labelledby="commandsHeading">
          <h3 id="commandsHeading">Command buttons</h3>
          <dl class="command-list">
            <dt>🖼 Preview</dt>
            <dd>Toggle the finished artwork overlay to compare your progress.</dd>
            <dt>🎛 Generator</dt>
            <dd>
              Adjust clustering sliders, choose capybara detail presets, reload the current source image, and monitor
              generation progress. The sheet mirrors the k-means pipeline inputs used for puzzle creation.
            </dd>
            <dt>🎚 Detail</dt>
            <dd>
              Toggle the capybara detail chips in the Generator sheet to reload the sample with tuned palette sizes,
              minimum region areas, resize targets, and the region counts noted above.
            </dd>
            <dt>⛶ Fullscreen</dt>
            <dd>Expand the app to fill the display or exit back to windowed mode.</dd>
            <dt>⬆ Import</dt>
            <dd>Load a new image or JSON puzzle from disk.</dd>
            <dt>💾 Saves</dt>
            <dd>Manage snapshots — load, rename, export, or delete stored games.</dd>
            <dt>ℹ Help</dt>
            <dd>Open this guide and inspect the live debug log.</dd>
            <dt>⚙ Settings</dt>
            <dd>
              Toggle auto-advance, customise hints, change the background or theme, sort the palette, and adjust the interface
              scale. Advanced options expose accessibility tweaks for the hint animations.
            </dd>
          </dl>
        </section>
        <section class="sheet-section" aria-labelledby="controlsHeading">
          <h3 id="controlsHeading">Canvas controls</h3>
          <ul class="control-list">
            <li><kbd>Click</kbd> Fill the tapped region if it matches the active colour.</li>
            <li><kbd>Right click</kbd> Select the colour under the pointer.</li>
            <li>Select a palette swatch to set the active colour and flash every matching region.</li>
            <li>Enable Easy difficulty in Settings to let clicks auto-select the tapped region's colour.</li>
            <li><kbd>Mouse wheel</kbd> or <kbd>+</kbd>/<kbd>-</kbd> Zoom in or out around the cursor.</li>
            <li><kbd>Middle click</kbd> or <kbd>Space</kbd> + drag Pan the canvas.</li>
            <li>Drag &amp; drop an image or JSON file anywhere on the window to import it.</li>
          </ul>
        </section>
        <section class="sheet-section" aria-labelledby="readmeHeading">
          <h3 id="readmeHeading">Project README</h3>
          <p class="control-note">
            Loads the live documentation from
            <a href="https://shthed.github.io/capy/README" target="_blank" rel="noreferrer noopener"
              >https://shthed.github.io/capy/README</a
            >
            so you can review gameplay notes and contributor guidance without leaving the app.
          </p>
          <p class="control-note" data-readme-status role="status">Loading README…</p>
          <p class="control-note" data-readme-error role="alert" hidden></p>
          <article class="readme-preview" data-readme-content hidden aria-live="polite"></article>
        </section>
        <section class="sheet-section" aria-labelledby="debugHeading">
          <h3 id="debugHeading">Debug log</h3>
          <p class="control-note">
            Recent actions, selections, and generation events appear here while you play.
          </p>
          <div
            id="debugLog"
            class="debug-log"
            role="log"
            aria-live="polite"
            aria-relevant="additions text"
          ></div>
          <div class="log-actions">
            <button id="clearDebugLog" type="button">Clear log</button>
          </div>
        </section>
      </div>
    </div>
    <div
      id="generatorSheet"
      class="sheet hidden"
      role="dialog"
      aria-labelledby="generatorTitle"
      aria-hidden="true"
    >
      <div class="sheet-header">
        <h2 id="generatorTitle">Puzzle generator</h2>
        <button type="button" class="close-button" data-sheet-close="generator">Close</button>
      </div>
      <div class="sheet-body">
        <div
          class="generator-import-notice"
          data-import-notice
          role="status"
          aria-live="polite"
          hidden
        >
          <p class="generator-import-title">
            <strong data-import-file></strong>
          </p>
          <p class="generator-import-description" data-import-description></p>
          <div class="generator-import-actions">
            <button id="confirmImport" type="button" data-import-confirm>Generate puzzle</button>
            <button type="button" class="close-button" data-import-cancel>Cancel</button>
          </div>
        </div>
        <section class="sheet-section" aria-labelledby="generatorHeading">
          <h3 id="generatorHeading">Clustering &amp; detail</h3>
          <p class="control-note">
            Tune the colour clustering pipeline that powers new puzzles. These settings apply to fresh imports and the bundled
            capybara sample when reloaded.
          </p>
          <div class="detail-callout">
            <p class="detail-intro">Capybara sample detail presets</p>
            <div class="detail-picker" role="group" aria-label="Capybara sample detail presets">
              <button type="button" class="detail-chip" data-detail-level="low">Low</button>
              <button type="button" class="detail-chip" data-detail-level="medium">Medium</button>
              <button type="button" class="detail-chip" data-detail-level="high">High</button>
            </div>
            <p class="detail-caption" data-detail-caption></p>
          </div>
          <p class="control-note">
            Switching presets updates every slider below and reloads the sample scene when it's active.
          </p>
          <label class="control">
            <span>Colours <output data-for="colorCount">16</output></span>
            <input id="colorCount" type="range" min="4" max="64" value="16" />
          </label>
          <label class="control">
            <span>Regions <output data-for="minRegion">80 px²</output></span>
            <input id="minRegion" type="range" min="1" max="600" value="80" />
          </label>
          <p class="control-note">Higher values merge smaller areas for fewer regions.</p>
          <label class="control">
            <span>Detail <output data-for="detailLevel">768 px</output></span>
            <input id="detailLevel" type="range" min="256" max="1600" step="64" value="768" />
          </label>
          <p class="control-note">Controls the longest edge used when resizing the source image.</p>
          <label class="control">
            <span>Algorithm</span>
            <select id="generationAlgorithm">
              <option value="local-kmeans">Local palette clustering (k-means)</option>
              <option value="local-posterize">Local posterize &amp; merge</option>
            </select>
          </label>
          <p class="control-note">
            Choose between local clustering pipelines now, with space for hosted services to appear as they become available.
          </p>
          <label class="control">
            <span>Sample rate <output data-for="sampleRate">65%</output></span>
            <input id="sampleRate" type="range" min="25" max="100" step="5" value="65" />
          </label>
          <p class="control-note">Lower values speed up clustering by sampling fewer pixels.</p>
          <label class="control">
            <span>Iterations <output data-for="kmeansIters">12</output></span>
            <input id="kmeansIters" type="range" min="4" max="32" step="1" value="12" />
          </label>
          <p class="control-note">
            Iterations rerun the clustering stage; higher counts refine colour centroids but take longer to process.
          </p>
          <label class="control">
            <span>Smoothing passes <output data-for="smoothingPasses">1</output></span>
            <input id="smoothingPasses" type="range" min="0" max="4" step="1" value="1" />
          </label>
          <p class="control-note">
            Each pass blends stray pixels into neighbouring regions before segmentation—set to 0 to keep edges as crisp as the source.
          </p>
          <details class="advanced-options" id="generatorAdvanced">
            <summary>Advanced options</summary>
            <label class="control">
              <span>Image description</span>
              <textarea
                id="imageDescription"
                rows="3"
                placeholder="Describe the image you want to generate"
              ></textarea>
            </label>
            <p class="control-note">
              Stored with saves and exports so you can revisit the inspiration later.
            </p>
            <p class="control-note">
              <a
                id="chatGptLink"
                class="chatgpt-link"
                href="https://chat.openai.com/"
                target="_blank"
                rel="noopener noreferrer"
              >
                Open ChatGPT to craft an image prompt <span aria-hidden="true">↗</span>
              </a>
            </p>
          </details>
        </section>
      </div>
      <div class="sheet-actions">
        <button id="applyOptions" type="button" disabled>Apply changes</button>
      </div>
      <div
        class="generator-progress"
        data-generator-progress
        role="status"
        aria-live="polite"
        hidden
      >
        <p class="generator-progress-message" data-generator-progress-message></p>
        <div
          class="generator-progress-meter"
          data-generator-progress-meter
          role="progressbar"
          aria-label="Puzzle generation progress"
          aria-valuemin="0"
          aria-valuemax="100"
          aria-valuenow="0"
          aria-hidden="true"
        >
          <div class="generator-progress-bar" data-generator-progress-bar></div>
        </div>
      </div>
    </div>
    <div
      id="settingsSheet"
      class="sheet hidden"
      role="dialog"
      aria-labelledby="settingsTitle"
      aria-hidden="true"
    >
      <div class="sheet-header">
        <h2 id="settingsTitle">Settings</h2>
        <button type="button" class="close-button" data-sheet-close="settings">Close</button>
      </div>
      <div class="sheet-body settings-body">
        <div class="settings-tabs" role="tablist" aria-label="Settings categories">
          <button
            type="button"
            class="settings-tab"
            id="settingsTab-gameplay"
            data-settings-tab="gameplay"
            data-settings-tab-default="true"
            role="tab"
            aria-controls="settingsPanel-gameplay"
            aria-selected="true"
            tabindex="0"
          >
            Gameplay
          </button>
          <button
            type="button"
            class="settings-tab"
            id="settingsTab-hints"
            data-settings-tab="hints"
            role="tab"
            aria-controls="settingsPanel-hints"
            aria-selected="false"
            tabindex="-1"
          >
            Hints
          </button>
          <button
            type="button"
            class="settings-tab"
            id="settingsTab-controls"
            data-settings-tab="controls"
            role="tab"
            aria-controls="settingsPanel-controls"
            aria-selected="false"
            tabindex="-1"
          >
            Controls
          </button>
          <button
            type="button"
            class="settings-tab"
            id="settingsTab-appearance"
            data-settings-tab="appearance"
            role="tab"
            aria-controls="settingsPanel-appearance"
            aria-selected="false"
            tabindex="-1"
          >
            Appearance
          </button>
        </div>
        <div
          class="settings-panel"
          id="settingsPanel-gameplay"
          role="tabpanel"
          aria-labelledby="settingsTab-gameplay"
          data-settings-panel="gameplay"
        >
          <section class="sheet-section" aria-labelledby="gameplayHeading">
            <h3 id="gameplayHeading">Gameplay</h3>
            <label class="toggle">
              <input id="autoAdvanceToggle" type="checkbox" checked />
              <span>Auto-advance to the next colour when complete</span>
            </label>
            <label class="toggle">
              <input id="hintFlashToggle" type="checkbox" checked />
              <span>Animate hint highlights</span>
            </label>
            <label class="toggle">
              <input id="showRegionLabelsToggle" type="checkbox" checked />
              <span>Show region numbers</span>
            </label>
            <label class="control">
              <span>Difficulty</span>
              <select id="difficultySelect">
                <option value="normal">Standard</option>
                <option value="easy">Easy</option>
              </select>
            </label>
            <p class="control-note">
              Easy mode lets you click any region to auto-select its colour before filling it.
            </p>
            <label class="control">
              <span>Sort Colours</span>
              <select id="paletteSort" data-testid="palette-sort" disabled>
                <option value="region">Number</option>
                <option value="remaining">Remaining regions</option>
                <option value="name">Colour name</option>
                <option value="spectrum">Rainbow spectrum</option>
                <option value="warmth">Warm → cool</option>
                <option value="lightness">Perceptual lightness</option>
              </select>
            </label>
            <p class="control-note">Choose how unfinished colours appear in the dock.</p>
          </section>
        </div>
        <div
          class="settings-panel"
          id="settingsPanel-hints"
          role="tabpanel"
          aria-labelledby="settingsTab-hints"
          data-settings-panel="hints"
          hidden
          aria-hidden="true"
        >
          <section class="sheet-section" aria-labelledby="hintsControlsHeading">
            <h3 id="hintsControlsHeading">Hints &amp; controls</h3>
            <label class="control">
              <span>Hint fade duration <output data-for="hintFadeDuration">1.2 s</output></span>
              <input id="hintFadeDuration" type="range" min="400" max="2400" step="100" value="1200" />
            </label>
            <p class="control-note">Set how long hint highlights linger before fading out.</p>
            <label class="control">
              <span>Hint intensity <output data-for="hintIntensity">65%</output></span>
              <input id="hintIntensity" type="range" min="20" max="90" step="5" value="65" />
            </label>
            <p class="control-note">Adjust the opacity used when flashing matching regions.</p>
          </section>
          <section class="sheet-section" aria-labelledby="hintTypesHeading">
            <h3 id="hintTypesHeading">Hint types</h3>
            <p class="control-note">Pick which guidance effects appear while you play.</p>
            <label class="toggle">
              <input id="hintMatchingToggle" type="checkbox" checked />
              <span>Highlight every region for the active colour</span>
            </label>
            <p class="control-note">Toggle the pulse that flashes all remaining regions sharing the selected colour.</p>
            <label class="toggle">
              <input id="hintHoverToggle" type="checkbox" checked />
              <span>Spotlight hovered regions</span>
            </label>
            <p class="control-note">Show a focused hint when you pause the pointer over a region.</p>
          </section>
        </div>
        <div
          class="settings-panel"
          id="settingsPanel-controls"
          role="tabpanel"
          aria-labelledby="settingsTab-controls"
          data-settings-panel="controls"
          hidden
          aria-hidden="true"
        >
          <section class="sheet-section" aria-labelledby="mouseControlsHeading">
            <h3 id="mouseControlsHeading">Mouse controls</h3>
            <p class="control-note">
              Assign actions to each mouse button when clicking or click-dragging on the
              canvas.
            </p>
            <div class="mouse-control-group">
              <span class="mouse-control-title">Left button</span>
              <div class="mouse-control-options">
                <label class="control mouse-control-option">
                  <span>Click</span>
                  <select id="mouseLeftClick">
                    <option value="fill" selected>Fill region</option>
                    <option value="select-fill">Select and fill region</option>
                    <option value="select">Select colour</option>
                    <option value="zoom-in">Zoom in</option>
                    <option value="zoom-out">Zoom out</option>
                    <option value="none">No action</option>
                  </select>
                </label>
                <label class="control mouse-control-option">
                  <span>Click + drag</span>
                  <select id="mouseLeftDrag">
                    <option value="pan" selected>Pan view</option>
                    <option value="fill">Fill while dragging</option>
                    <option value="zoom">Zoom</option>
                    <option value="none">No action</option>
                  </select>
                </label>
              </div>
            </div>
            <div class="mouse-control-group">
              <span class="mouse-control-title">Middle button</span>
              <div class="mouse-control-options">
                <label class="control mouse-control-option">
                  <span>Click</span>
                  <select id="mouseMiddleClick">
                    <option value="fill">Fill region</option>
                    <option value="select-fill">Select and fill region</option>
                    <option value="select">Select colour</option>
                    <option value="zoom-in">Zoom in</option>
                    <option value="zoom-out">Zoom out</option>
                    <option value="none" selected>No action</option>
                  </select>
                </label>
                <label class="control mouse-control-option">
                  <span>Click + drag</span>
                  <select id="mouseMiddleDrag">
                    <option value="pan" selected>Pan view</option>
                    <option value="fill">Fill while dragging</option>
                    <option value="zoom">Zoom</option>
                    <option value="none">No action</option>
                  </select>
                </label>
              </div>
            </div>
            <div class="mouse-control-group">
              <span class="mouse-control-title">Right button</span>
              <div class="mouse-control-options">
                <label class="control mouse-control-option">
                  <span>Click</span>
                  <select id="mouseRightClick">
                    <option value="fill">Fill region</option>
                    <option value="select-fill">Select and fill region</option>
                    <option value="select" selected>Select colour</option>
                    <option value="zoom-in">Zoom in</option>
                    <option value="zoom-out">Zoom out</option>
                    <option value="none">No action</option>
                  </select>
                </label>
                <label class="control mouse-control-option">
                  <span>Click + drag</span>
                  <select id="mouseRightDrag">
                    <option value="pan" selected>Pan view</option>
                    <option value="fill">Fill while dragging</option>
                    <option value="zoom">Zoom</option>
                    <option value="none">No action</option>
                  </select>
                </label>
              </div>
            </div>
            <p class="control-note">
              Drag-to-zoom adjusts the view by moving up to zoom in or down to zoom out.
            </p>
          </section>
        </div>
        <div
          class="settings-panel"
          id="settingsPanel-appearance"
          role="tabpanel"
          aria-labelledby="settingsTab-appearance"
          data-settings-panel="appearance"
          hidden
          aria-hidden="true"
        >
          <section class="sheet-section" aria-labelledby="appearanceHeading">
            <h3 id="appearanceHeading">Appearance</h3>
            <label class="control">
              <span>Interface scale <output data-for="uiScale">75%</output></span>
              <input
                id="uiScale"
                type="range"
                min="0.2"
                max="3"
                step="0.05"
                value="0.75"
              />
            </label>
            <p class="control-note">Resize command buttons and labels without altering canvas zoom.</p>
            <label class="control">
              <span>Label size <output data-for="labelScale">100%</output></span>
              <input
                id="labelScale"
                type="range"
                min="0.2"
                max="2"
                step="0.05"
                value="1"
              />
            </label>
            <p class="control-note">Scale region numbers independently from the surrounding interface.</p>
            <label class="control">
              <span>Interface theme</span>
              <select id="uiTheme">
                <option value="dark">Dark</option>
                <option value="light">Light</option>
                <option value="colorful">Colourful</option>
              </select>
            </label>
            <p class="control-note">Switch between dark, light, or colourful chrome accents.</p>
            <label class="control">
              <span>Renderer</span>
              <select id="rendererMode">
                <option value="canvas2d">Canvas 2D</option>
                <option value="webgl">WebGL</option>
                <option value="svg">SVG</option>
              </select>
            </label>
            <p class="control-note">
              Choose between the classic Canvas pipeline, accelerated WebGL, or the SVG renderer.
            </p>
            <label class="control">
              <span>Unfilled region colour</span>
              <input id="backgroundColor" type="color" value="#f8fafc" />
            </label>
            <p class="control-note">
              Applies to unfinished regions and adjusts outline contrast automatically.
            </p>
            <label class="control">
              <span>Background</span>
              <input id="stageBackgroundColor" type="color" value="#000000" />
            </label>
            <p class="control-note">Adjust the area surrounding the puzzle canvas.</p>
          </section>
        </div>
      </div>
    </div>
        <script type="module">
      import {
        createRendererController,
        createWebGLRenderer,
        createSvgRenderer,
      } from "./render.js";
      // Cached DOM references so we can wire handlers without repeated lookups.
      const appEl = document.getElementById("app");
      const commandRail = document.getElementById("commandRail");
      const fileInput = document.getElementById("fileInput");
      const selectButton = document.getElementById("selectImage");
      const sampleButtons = Array.from(document.querySelectorAll('[data-action="load-sample"]'));
      const sampleDetailButtons = Array.from(document.querySelectorAll('[data-detail-level]'));
      const sampleDetailCaptions = Array.from(document.querySelectorAll('[data-detail-caption]'));
      const samplePreview = document.getElementById("sampleArtPreview");
      const gameSelectionList = document.getElementById("gameSelectionList");
      const gameSelectionEmpty = document.getElementById("gameSelectionEmpty");
      const startHint = document.getElementById("startHint");
      const startHintCloseButton = document.getElementById("closeStartHint");
      const startSaveManagerSection = document.getElementById("saveManagerSection");
      const previewToggle = document.getElementById("previewToggle");
      const fullscreenButton = document.getElementById("fullscreenButton");
      const importButton = document.getElementById("importButton");
      const saveManagerButton = document.getElementById("saveManagerButton");
      const generatorButton = document.getElementById("generatorButton");
      const settingsButton = document.getElementById("settingsButton");
      const helpButton = document.getElementById("helpButton");
      const generatorSheet = document.getElementById("generatorSheet");
      const settingsSheet = document.getElementById("settingsSheet");
      const settingsBody = settingsSheet?.querySelector(".sheet-body") || null;
      const settingsTabButtons = settingsSheet
        ? Array.from(settingsSheet.querySelectorAll("[data-settings-tab]"))
        : [];
      const settingsPanels = settingsSheet
        ? Array.from(settingsSheet.querySelectorAll("[data-settings-panel]"))
        : [];
      let activeSettingsTabId =
        settingsTabButtons.find((button) => button?.hasAttribute("data-settings-tab-default"))
          ?.dataset.settingsTab || (settingsTabButtons[0]?.dataset.settingsTab ?? null);
      const helpSheet = document.getElementById("helpSheet");
      const saveManagerSheet = document.getElementById("saveManagerSheet");
      const sheetRegistry = [generatorSheet, settingsSheet, helpSheet, saveManagerSheet].filter(
        Boolean
      );
      const readmeContentEl = helpSheet?.querySelector("[data-readme-content]") || null;
      const readmeStatusEl = helpSheet?.querySelector("[data-readme-status]") || null;
      const readmeErrorEl = helpSheet?.querySelector("[data-readme-error]") || null;
      const README_SOURCE_URL = "https://shthed.github.io/capy/README";
      let readmeLoadState = "idle";
      const debugLogEl = document.getElementById("debugLog");
      const clearDebugLogButton = document.getElementById("clearDebugLog");
      const saveStorageSummary = document.getElementById("saveStorageSummary");
      const deleteAllSavesButton = document.getElementById("deleteAllSaves");
      const viewportEl = document.getElementById("viewport");
      const canvasStage = document.getElementById("canvasStage");
      const canvasTransform = document.getElementById("canvasTransform");
      const cursorOverlay = document.getElementById("pointerOverlay");
      const cursorNumberEl = cursorOverlay?.querySelector("[data-pointer-number]") || null;
      const autoAdvanceToggle = document.getElementById("autoAdvanceToggle");
      const hintFlashToggle = document.getElementById("hintFlashToggle");
      const hintMatchingToggle = document.getElementById("hintMatchingToggle");
      const hintHoverToggle = document.getElementById("hintHoverToggle");
      const hintFadeDurationInput = document.getElementById("hintFadeDuration");
      const hintIntensityInput = document.getElementById("hintIntensity");
      const difficultySelect = document.getElementById("difficultySelect");
      const mouseControlInputs = {
        left: {
          click: document.getElementById("mouseLeftClick"),
          drag: document.getElementById("mouseLeftDrag"),
        },
        middle: {
          click: document.getElementById("mouseMiddleClick"),
          drag: document.getElementById("mouseMiddleDrag"),
        },
        right: {
          click: document.getElementById("mouseRightClick"),
          drag: document.getElementById("mouseRightDrag"),
        },
      };
      const showRegionLabelsToggle = document.getElementById("showRegionLabelsToggle");
      const uiThemeSelect = document.getElementById("uiTheme");
      const rendererModeSelect = document.getElementById("rendererMode");
      const backgroundColorInput = document.getElementById("backgroundColor");
      const stageBackgroundColorInput = document.getElementById("stageBackgroundColor");
      const uiScaleInput = document.getElementById("uiScale");
      const labelScaleInput = document.getElementById("labelScale");
      const colorCountEl = document.getElementById("colorCount");
      const minRegionEl = document.getElementById("minRegion");
      const detailEl = document.getElementById("detailLevel");
      const algorithmEl = document.getElementById("generationAlgorithm");
      const sampleRateEl = document.getElementById("sampleRate");
      const kmeansItersEl = document.getElementById("kmeansIters");
      const smoothingEl = document.getElementById("smoothingPasses");
      const artPromptInput = document.getElementById("artPrompt");
      const imageDescriptionInput = document.getElementById("imageDescription");
      const sourceImageLimitSelect = document.getElementById("sourceImageLimit");
      const chatGptLink = document.getElementById("chatGptLink");
      const applyBtn = document.getElementById("applyOptions");
      const downloadBtn = document.getElementById("downloadJson");
      const saveSnapshotButtons = Array.from(document.querySelectorAll("[data-save-snapshot]"));
      const resetProgressButtons = Array.from(document.querySelectorAll("[data-reset-progress]"));
      const saveListContainers = Array.from(document.querySelectorAll("[data-save-list]"));
      const saveListEmptyStates = Array.from(document.querySelectorAll("[data-save-empty]"));
      const paletteEl = document.getElementById("palette");
      const paletteSortEl = document.getElementById("paletteSort");
      const ALLOWED_PALETTE_SORT_MODES = new Set([
        "region",
        "remaining",
        "name",
        "spectrum",
        "warmth",
        "lightness",
      ]);
      const LEGACY_PALETTE_SORT_ALIASES = new Map([
        ["hue", "spectrum"],
        ["brightness", "lightness"],
      ]);
      const WARM_HUE_PIVOT_RADIANS = (40 * Math.PI) / 180;
      const generatorImportNotice =
        generatorSheet?.querySelector("[data-import-notice]") || null;
      const generatorImportFileEl = generatorSheet?.querySelector("[data-import-file]") || null;
      const generatorImportDescriptionEl =
        generatorSheet?.querySelector("[data-import-description]") || null;
      const confirmImportBtn = document.getElementById("confirmImport");
      const cancelImportBtn = generatorSheet?.querySelector("[data-import-cancel]") || null;
      const generatorUrlForm = generatorSheet?.querySelector("[data-source-url-form]") || null;
      const generatorUrlInput = generatorSheet?.querySelector("[data-source-url-input]") || null;
      const generatorUrlSubmit = generatorSheet?.querySelector("[data-source-url-submit]") || null;
      const generatorUrlHint = generatorSheet?.querySelector("[data-source-url-hint]") || null;
      const generatorUrlError = generatorSheet?.querySelector("[data-source-url-error]") || null;
      const generatorProgressEl = generatorSheet?.querySelector("[data-generator-progress]") || null;
      const generatorProgressMessageEl =
        generatorSheet?.querySelector("[data-generator-progress-message]") || null;
      const generatorProgressMeterEl =
        generatorSheet?.querySelector("[data-generator-progress-meter]") || null;
      const generatorProgressBarEl =
        generatorSheet?.querySelector("[data-generator-progress-bar]") || null;
      const defaultProgressLabel =
        generatorProgressMeterEl?.getAttribute("aria-label") || "Puzzle generation progress";
      const DEFAULT_PROGRESS_MESSAGE = "";
      const PROGRESS_MESSAGES = {
        loading: "Loading puzzle…",
        generating: "Processing image…",
        complete: "All done!",
      };
      const puzzleCanvas = document.getElementById("puzzleCanvas");
      const previewCanvas = document.createElement("canvas");
      const previewCtx = previewCanvas.getContext("2d");
      let rendererController = null;
      let pendingSourceUrlLoad = false;

      // Sheet output mirrors we update while users drag sliders.
      const generatorOutputs = generatorSheet
        ? {
            colorCount: generatorSheet.querySelector('output[data-for="colorCount"]'),
            minRegion: generatorSheet.querySelector('output[data-for="minRegion"]'),
            detail: generatorSheet.querySelector('output[data-for="detailLevel"]'),
            sample: generatorSheet.querySelector('output[data-for="sampleRate"]'),
            iterations: generatorSheet.querySelector('output[data-for="kmeansIters"]'),
            smoothing: generatorSheet.querySelector('output[data-for="smoothingPasses"]'),
          }
        : {};
      const sourceImageLimitOutput = document.querySelector('output[data-for="sourceImageLimit"]');
      const settingsOutputs = settingsSheet
        ? {
            uiScale: settingsSheet.querySelector('output[data-for="uiScale"]'),
            labelScale: settingsSheet.querySelector('output[data-for="labelScale"]'),
            hintFadeDuration: settingsSheet.querySelector('output[data-for="hintFadeDuration"]'),
            hintIntensity: settingsSheet.querySelector('output[data-for="hintIntensity"]'),
          }
        : {};
      if (activeSettingsTabId) {
        activateSettingsTab(activeSettingsTabId, { force: true });
      }
      const SAVE_STORAGE_KEY = "capy.saves.v2";
      const LEGACY_AUTOSAVE_STORAGE_KEY = "capy.autosave.v1";
      const LAST_IMAGE_STORAGE_KEY = "capy.last-uploaded-image.v1";
      const SETTINGS_STORAGE_KEY = "capy.settings.v1";
      const SETTINGS_AUTOSAVE_REASONS = new Set([
        "settings-renderer",
        "settings-auto-advance",
        "settings-hint-animations",
        "settings-hint-matching",
        "settings-hint-hover",
        "settings-difficulty",
        "settings-hint-fade",
        "settings-hint-intensity",
        "settings-ui-scale",
        "settings-label-scale",
        "settings-image-description",
        "settings-art-prompt",
        "settings-region-labels",
        "settings-theme",
        "settings-mouse-controls",
        "background-colour",
        "stage-background-colour",
      ]);
      const DEFAULT_BACKGROUND_HEX = "#f8fafc";
      const DEFAULT_STAGE_BACKGROUND_HEX = "#000000";
      const DEFAULT_UI_SCALE = 0.75;
      const DEFAULT_LABEL_SCALE = 1;
      const DEFAULT_UI_THEME = "dark";
      const DEFAULT_GENERATION_ALGORITHM = "local-kmeans";
      const VALID_GENERATION_ALGORITHMS = new Set(["local-kmeans", "local-posterize"]);
      const VALID_UI_THEMES = new Set(["dark", "light", "colorful"]);
      const DEFAULT_HINT_FADE_DURATION = 1200;
      const MIN_HINT_FADE_DURATION = 400;
      const MAX_HINT_FADE_DURATION = 2400;
      const DEFAULT_HINT_INTENSITY = 0.65;
      const MIN_HINT_INTENSITY = 0.2;
      const MAX_HINT_INTENSITY = 0.9;
      const DEFAULT_HINT_TYPES = {
        matchingRegions: true,
        hoverRegions: true,
      };
      const HINT_TYPE_KEYS = ["matchingRegions", "hoverRegions"];
      const DEFAULT_SOURCE_IMAGE_MAX_BYTES = 1048576;
      const SOURCE_IMAGE_LIMIT_OPTIONS = [
        { value: 262144, label: "256 KB" },
        { value: 524288, label: "512 KB" },
        { value: 1048576, label: "1 MB" },
        { value: 2097152, label: "2 MB" },
        { value: 5242880, label: "5 MB" },
      ];
      const MAX_SOURCE_IMAGE_LIMIT = SOURCE_IMAGE_LIMIT_OPTIONS.reduce((max, option) => {
        const value = option?.value;
        if (Number.isFinite(value) && value > max) {
          return value;
        }
        return max;
      }, DEFAULT_SOURCE_IMAGE_MAX_BYTES);
      const SOURCE_IMAGE_VARIANT_ORIGINAL = "original";
      const SOURCE_IMAGE_VARIANT_GENERATED = "generated";
      const DEFAULT_DIFFICULTY = "normal";
      const VALID_DIFFICULTY_LEVELS = new Set(["normal", "easy"]);
      const MOUSE_BUTTON_KEYS = ["left", "middle", "right"];
      const MOUSE_BUTTON_LABELS = {
        left: "Left mouse button",
        middle: "Middle mouse button",
        right: "Right mouse button",
      };
      const DEFAULT_MOUSE_CONTROLS = {
        left: { click: "fill", drag: "pan" },
        middle: { click: "none", drag: "pan" },
        right: { click: "select", drag: "pan" },
      };
      const VALID_MOUSE_CLICK_ACTIONS = new Set([
        "fill",
        "select-fill",
        "select",
        "zoom-in",
        "zoom-out",
        "none",
      ]);
      const VALID_MOUSE_DRAG_ACTIONS = new Set(["pan", "fill", "zoom", "none"]);
      let backgroundInk = computeInkStyles(DEFAULT_BACKGROUND_HEX);
      let settingsPersistTimer = null;
      let pendingSettingsPersistPayload = null;
      let lastStoredSettingsJson = null;
      const gameSaveManager = createGameSaveManager();
      let autosaveTimer = null;
      let pendingAutosaveReason = null;
      let storageSummaryUpdateToken = 0;
      let preventingBrowserZoom = false;
      const DOUBLE_TAP_GUARD_MS = 350;

      function normalizeMouseClickAction(value, fallback = DEFAULT_MOUSE_CONTROLS.left.click) {
        if (typeof value === "string" && VALID_MOUSE_CLICK_ACTIONS.has(value)) {
          return value;
        }
        if (typeof fallback === "string" && VALID_MOUSE_CLICK_ACTIONS.has(fallback)) {
          return fallback;
        }
        return DEFAULT_MOUSE_CONTROLS.left.click;
      }

      function normalizeMouseDragAction(value, fallback = DEFAULT_MOUSE_CONTROLS.left.drag) {
        if (typeof value === "string" && VALID_MOUSE_DRAG_ACTIONS.has(value)) {
          return value;
        }
        if (typeof fallback === "string" && VALID_MOUSE_DRAG_ACTIONS.has(fallback)) {
          return fallback;
        }
        return DEFAULT_MOUSE_CONTROLS.left.drag;
      }

      function normalizeMouseControls(input, fallback = DEFAULT_MOUSE_CONTROLS) {
        const base = fallback && typeof fallback === "object" ? fallback : DEFAULT_MOUSE_CONTROLS;
        const normalized = {};
        for (const key of MOUSE_BUTTON_KEYS) {
          const entry = input && typeof input === "object" ? input[key] : null;
          const baseEntry = base[key] || DEFAULT_MOUSE_CONTROLS[key];
          normalized[key] = {
            click: normalizeMouseClickAction(entry?.click, baseEntry?.click),
            drag: normalizeMouseDragAction(entry?.drag, baseEntry?.drag),
          };
        }
        return normalized;
      }

      function cloneMouseControls(source = DEFAULT_MOUSE_CONTROLS) {
        const normalized = normalizeMouseControls(source);
        return {
          left: { ...normalized.left },
          middle: { ...normalized.middle },
          right: { ...normalized.right },
        };
      }

      function getMouseControls() {
        return normalizeMouseControls(state.settings?.mouseControls, DEFAULT_MOUSE_CONTROLS);
      }

      function getMouseControlsForButton(button) {
        const controls = getMouseControls();
        if (controls[button]) {
          return controls[button];
        }
        return cloneMouseControls(DEFAULT_MOUSE_CONTROLS)[button];
      }

      function getMouseButtonName(buttonIndex) {
        if (buttonIndex === 1) return "middle";
        if (buttonIndex === 2) return "right";
        return "left";
      }

      function describeMouseButton(button) {
        return MOUSE_BUTTON_LABELS[button] || "Mouse button";
      }

      function describeMouseClickAction(action) {
        switch (action) {
          case "fill":
            return "Fill region";
          case "select-fill":
            return "Select and fill region";
          case "select":
            return "Select colour";
          case "zoom-in":
            return "Zoom in";
          case "zoom-out":
            return "Zoom out";
          case "none":
          default:
            return "No action";
        }
      }

      function describeMouseDragAction(action) {
        switch (action) {
          case "pan":
            return "Pan view";
          case "fill":
            return "Fill while dragging";
          case "zoom":
            return "Drag to zoom";
          case "none":
          default:
            return "No action";
        }
      }

      function isInteractiveElementForZoomGuard(node) {
        return (
          node instanceof Element &&
          Boolean(
            node.closest(
              "input, textarea, select, button, [role=\"button\"], [role=\"textbox\"], [role=\"slider\"], [contenteditable=\"true\"]"
            )
          )
        );
      }

      function installBrowserZoomGuards() {
        if (typeof window === "undefined") return;
        if (preventingBrowserZoom) return;
        let lastTouchEndTime = 0;
        const isGameSurface = (node) => {
          if (!(node instanceof Node)) return false;
          if (canvasStage && canvasStage.contains(node)) return true;
          if (canvasTransform && canvasTransform.contains(node)) return true;
          if (puzzleCanvas && puzzleCanvas.contains(node)) return true;
          if (viewportEl && viewportEl.contains(node)) return true;
          return false;
        };

        const isWithinGameSurface = (node) => {
          if (!(node instanceof Node)) return false;
          let current = node;
          while (current) {
            if (isGameSurface(current)) {
              return true;
            }
            if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
              current = current.host;
            } else {
              current = current.parentNode || null;
            }
          }
          return false;
        };

        const preventUiPinchZoom = (event) => {
          if (!event) return;
          const touches = event.touches;
          if (!touches || touches.length < 2) return;
          const path = typeof event.composedPath === "function" ? event.composedPath() : null;
          if (Array.isArray(path) && path.some((node) => isWithinGameSurface(node))) {
            return;
          }
          if (isWithinGameSurface(event.target)) {
            return;
          }
          if (event.cancelable) {
            event.preventDefault();
          }
        };

        window.addEventListener(
          "touchend",
          (event) => {
            const now = Date.now();
            const remainingTouches = event.touches ? event.touches.length : 0;
            if (remainingTouches === 0 && now - lastTouchEndTime <= DOUBLE_TAP_GUARD_MS) {
              if (!isInteractiveElementForZoomGuard(event.target)) {
                event.preventDefault();
              }
            }
            lastTouchEndTime = now;
          },
          { passive: false }
        );

        window.addEventListener("touchstart", preventUiPinchZoom, {
          passive: false,
          capture: true,
        });

        window.addEventListener("touchmove", preventUiPinchZoom, {
          passive: false,
          capture: true,
        });

        ["gesturestart", "gesturechange", "gestureend"].forEach((type) => {
          window.addEventListener(
            type,
            (event) => {
              if (event && typeof event.preventDefault === "function") {
                event.preventDefault();
              }
            },
            { passive: false }
          );
        });

        window.addEventListener(
          "wheel",
          (event) => {
            if (!event) return;
            if (!event.ctrlKey && !event.metaKey) return;
            const isInteractive = isInteractiveElementForZoomGuard(event.target);
            const isStageTarget = isGameSurface(event.target);
            if (isInteractive || isStageTarget) {
              return;
            }
            event.preventDefault();
          },
          { passive: false, capture: true }
        );

        window.addEventListener(
          "keydown",
          (event) => {
            if (!event) return;
            if (!event.ctrlKey && !event.metaKey) return;
            if (event.altKey) return;
            const isInteractive = isInteractiveElementForZoomGuard(event.target);
            if (isInteractive) return;
            const key = event.key;
            const code = event.code;
            const wantsReset = key === "0" || code === "Digit0" || code === "Numpad0";
            const wantsZoomIn =
              key === "+" || key === "=" || code === "Equal" || code === "NumpadAdd";
            const wantsZoomOut = key === "-" || code === "Minus" || code === "NumpadSubtract";
            if (!wantsReset && !wantsZoomIn && !wantsZoomOut) {
              return;
            }
            event.preventDefault();
            if (wantsReset) {
              resetView({ preserveZoom: false, recenter: true });
              return;
            }
            const allowShortcutTarget =
              isGameSurface(event.target) ||
              event.target === document.body ||
              event.target === document.documentElement;
            if (!allowShortcutTarget) {
              return;
            }
            applyZoom(wantsZoomIn ? 1.1 : 0.9);
          },
          { capture: true }
        );

        preventingBrowserZoom = true;
      }

      // Default puzzle metadata fallback used for onboarding and smoke tests.
      const DEFAULT_GAME_SOURCE = {
        id: "capy-default",
        path: "capy.json",
      };

      const DEFAULT_GAME_FALLBACK = {
        title: "Capybara Springs",
        description: "A capybara in a lavender scarf lounges with a dachshund beside a moonlit spring.",
      };

      let cachedDefaultGame = null;
      let defaultGameRequest = null;

      const SAMPLE_DETAIL_LEVELS = {
        low: {
          id: "low",
          label: "Low detail",
          shortLabel: "Low",
          summary: "Low detail • 18 colours / 15 px² min regions / 1216 px resize • ≈26 regions",
          ariaLabel:
            "Low detail – 18 colours, 15 pixel minimum regions, 1216px resize target, about 26 regions",
          logDescriptor: "low detail",
          approxRegions: 26,
          settings: {
            targetColors: 18,
            minRegion: 15,
            maxSize: 1216,
            sampleRate: 90,
            kmeansIters: 20,
            smoothingPasses: 1,
            algorithm: DEFAULT_GENERATION_ALGORITHM,
            sourceImageMaxBytes: 524288,
          },
        },
        medium: {
          id: "medium",
          label: "Medium detail",
          shortLabel: "Medium",
          summary: "Medium detail • 26 colours / 100 px² min regions / 1408 px resize • ≈20 regions",
          ariaLabel:
            "Medium detail – 26 colours, 100 pixel minimum regions, 1408px resize target, about 20 regions",
          logDescriptor: "medium detail",
          approxRegions: 20,
          settings: {
            targetColors: 26,
            minRegion: 100,
            maxSize: 1408,
            sampleRate: 95,
            kmeansIters: 24,
            smoothingPasses: 1,
            algorithm: DEFAULT_GENERATION_ALGORITHM,
            sourceImageMaxBytes: 1048576,
          },
        },
        high: {
          id: "high",
          label: "High detail",
          shortLabel: "High",
          summary: "High detail • 32 colours / 3 px² min regions / 1536 px resize • ≈140 regions",
          ariaLabel:
            "High detail – 32 colours, 3 pixel minimum regions, 1536px resize target, about 140 regions",
          logDescriptor: "high detail",
          approxRegions: 140,
          settings: {
            targetColors: 32,
            minRegion: 3,
            maxSize: 1536,
            sampleRate: 100,
            kmeansIters: 28,
            smoothingPasses: 1,
            algorithm: DEFAULT_GENERATION_ALGORITHM,
            sourceImageMaxBytes: 2097152,
          },
        },
      };
      const DEFAULT_SAMPLE_DETAIL = "medium";

      function drawOutlines(ctx) {
        if (!state.puzzle || !ctx) return;
        const cache = ensureRenderCache();
        if (!cache.ready) return;
        const filledRegions = state.filled || new Set();
        const hideCompleted = filledRegions.size > 0;
        const geometries = hideCompleted
          ? cache.regions.filter((geometry) => !filledRegions.has(geometry.id))
          : cache.regions;
        if (geometries.length === 0) {
          return;
        }
        if (!hideCompleted && cache.outlineLayer && cache.outlineLayerCtx) {
          if (cache.outlineLayerDirty && !rasterizeOutlineLayer(cache)) {
            strokeOutlinesDirect(ctx, cache, geometries);
            return;
          }
          ctx.drawImage(cache.outlineLayer, 0, 0);
          return;
        }
        strokeOutlinesDirect(ctx, cache, geometries);
      }

      function createRenderCache() {
        return {
          width: 0,
          height: 0,
          version: 0,
          strokeWidth: 1,
          renderScale: 1,
          pixelWidth: 0,
          pixelHeight: 0,
          ready: false,
          regions: [],
          regionsById: new Map(),
          filledLayer: null,
          filledLayerCtx: null,
          filledLayerDirty: true,
          filledLayerNeedsUpload: false,
          outlineLayer: null,
          outlineLayerCtx: null,
          outlineLayerDirty: true,
        };
      }

      function strokeOutlinesDirect(ctx, cache, geometries) {
        const scale = cache.renderScale > 0 ? cache.renderScale : 1;
        withRenderScale(ctx, scale, () => {
          ctx.strokeStyle = backgroundInk.outline;
          ctx.lineWidth = cache.strokeWidth;
          ctx.lineJoin = "round";
          ctx.lineCap = "round";
          strokeGeometries(ctx, Array.isArray(geometries) ? geometries : cache.regions);
        });
      }

      function rasterizeOutlineLayer(cache) {
        const ctx = cache.outlineLayerCtx;
        if (!ctx || !cache.outlineLayer) {
          cache.outlineLayerDirty = true;
          return false;
        }
        clearContext(ctx);
        const scale = cache.renderScale > 0 ? cache.renderScale : 1;
        withRenderScale(ctx, scale, () => {
          ctx.strokeStyle = backgroundInk.outline;
          ctx.lineWidth = cache.strokeWidth;
          ctx.lineJoin = "round";
          ctx.lineCap = "round";
          strokeGeometries(ctx, cache.regions);
        });
        cache.outlineLayerDirty = false;
        return true;
      }

      function createLayerCanvas(width, height) {
        if (SUPPORTS_OFFSCREEN_CANVAS) {
          try {
            return new OffscreenCanvas(width, height);
          } catch (error) {}
        }
        if (typeof document === "undefined") {
          return null;
        }
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        canvas.hidden = true;
        return canvas;
      }

      function getLayerContext(layer) {
        if (!layer) return null;
        try {
          const ctx = layer.getContext("2d");
          if (ctx) {
            ctx.imageSmoothingEnabled = false;
          }
          return ctx;
        } catch (error) {
          return null;
        }
      }

      function appendContoursToPath(ctx, contours) {
        for (const contour of contours || []) {
          if (!contour || contour.length === 0) continue;
          const first = contour[0];
          ctx.moveTo(first[0], first[1]);
          for (let i = 1; i < contour.length; i++) {
            const point = contour[i];
            ctx.lineTo(point[0], point[1]);
          }
          ctx.closePath();
        }
      }

      function fillGeometries(ctx, geometries) {
        if (SUPPORTS_PATH2D) {
          for (const geometry of geometries) {
            if (!geometry?.path) continue;
            ctx.fill(geometry.path);
          }
          return;
        }
        ctx.beginPath();
        for (const geometry of geometries) {
          if (!geometry?.contours) continue;
          appendContoursToPath(ctx, geometry.contours);
        }
        ctx.fill();
      }

      function strokeGeometries(ctx, geometries) {
        if (SUPPORTS_PATH2D) {
          for (const geometry of geometries) {
            if (!geometry?.path) continue;
            ctx.stroke(geometry.path);
          }
          return;
        }
        ctx.beginPath();
        for (const geometry of geometries) {
          if (!geometry?.contours) continue;
          appendContoursToPath(ctx, geometry.contours);
        }
        ctx.stroke();
      }

      function ensureRenderCache(options = {}) {
        if (!state.puzzle) {
          state.renderCache = createRenderCache();
          return state.renderCache;
        }
        const cache = state.renderCache || createRenderCache();
        const expectedWidth = state.puzzle.width;
        const expectedHeight = state.puzzle.height;
        const expectedVersion = state.puzzle.regions.length;
        const force = options.force === true;
        const needsRebuild =
          force ||
          !cache.ready ||
          cache.width !== expectedWidth ||
          cache.height !== expectedHeight ||
          cache.version !== expectedVersion;
        if (needsRebuild) {
          rebuildRenderCache(cache);
        }
        syncCacheMetrics(cache);
        state.renderCache = cache;
        return cache;
      }

      function rebuildRenderCache(cache) {
        if (!state.puzzle) {
          cache.width = 0;
          cache.height = 0;
          cache.version = 0;
          cache.strokeWidth = 1;
          cache.regions = [];
          cache.regionsById = new Map();
          cache.filledLayer = null;
          cache.filledLayerCtx = null;
          cache.filledLayerDirty = true;
          cache.filledLayerNeedsUpload = false;
          cache.outlineLayer = null;
          cache.outlineLayerCtx = null;
          cache.outlineLayerDirty = true;
          cache.ready = false;
          return cache;
        }
        cache.width = state.puzzle.width;
        cache.height = state.puzzle.height;
        cache.version = state.puzzle.regions.length;
        cache.strokeWidth = computeOutlineStrokeWidth(cache.width, cache.height, {
          displayScale: canvasMetrics.displayScale,
          pixelRatio: canvasMetrics.pixelRatio,
          deviceWidth: 1,
        });
        cache.regions = [];
        cache.regionsById = new Map();
        for (const region of state.puzzle.regions) {
          const geometry = buildRegionGeometry(region, cache.width, cache.height);
          cache.regions.push(geometry);
          cache.regionsById.set(region.id, geometry);
        }
        const pixelWidth = Math.max(1, canvasMetrics.pixelWidth || cache.width);
        const pixelHeight = Math.max(1, canvasMetrics.pixelHeight || cache.height);
        cache.filledLayer = createLayerCanvas(pixelWidth, pixelHeight);
        cache.filledLayerCtx = getLayerContext(cache.filledLayer);
        cache.filledLayerDirty = true;
        cache.filledLayerNeedsUpload = true;
        cache.outlineLayer = createLayerCanvas(pixelWidth, pixelHeight);
        cache.outlineLayerCtx = getLayerContext(cache.outlineLayer);
        cache.outlineLayerDirty = true;
        cache.ready = true;
        syncCacheMetrics(cache);
        return cache;
      }

      function rebuildFilledLayer(cache) {
        const ctx = cache.filledLayerCtx;
        if (!ctx || !cache.filledLayer) {
          cache.filledLayerDirty = true;
          return false;
        }
        clearContext(ctx);
        const scale = cache.renderScale > 0 ? cache.renderScale : 1;
        const overlayHex = sanitizeHexColor(
          state.settings.backgroundColor ?? DEFAULT_BACKGROUND_HEX,
          DEFAULT_BACKGROUND_HEX
        );
        const pending = [];
        for (const geometry of cache.regions) {
          if (!geometry) continue;
          if (state.filled.has(geometry.id)) continue;
          pending.push(geometry);
        }
        withRenderScale(ctx, scale, () => {
          ctx.globalCompositeOperation = "source-over";
          ctx.fillStyle = overlayHex;
          fillGeometries(ctx, pending);
        });
        cache.filledLayerDirty = false;
        cache.filledLayerNeedsUpload = true;
        return true;
      }

      function compositeFilledRegionsDirect(ctx, cache) {
        const scale = cache.renderScale > 0 ? cache.renderScale : 1;
        const overlayHex = sanitizeHexColor(
          state.settings.backgroundColor ?? DEFAULT_BACKGROUND_HEX,
          DEFAULT_BACKGROUND_HEX
        );
        withRenderScale(ctx, scale, () => {
          const pending = [];
          for (const geometry of cache.regions) {
            if (!geometry) continue;
            if (state.filled.has(geometry.id)) continue;
            pending.push(geometry);
          }
          if (pending.length === 0) {
            return;
          }
          ctx.fillStyle = overlayHex;
          fillGeometries(ctx, pending);
        });
      }

      function paintRegionToFilledLayer(regionId) {
        const cache = ensureRenderCache();
        if (!cache.ready) return;
        cache.filledLayerDirty = true;
        cache.filledLayerNeedsUpload = true;
      }

      function markFilledLayerDirty() {
        if (state.renderCache) {
          state.renderCache.filledLayerDirty = true;
          state.renderCache.filledLayerNeedsUpload = true;
        }
      }

      function markOutlineLayerDirty() {
        if (state.renderCache) {
          state.renderCache.outlineLayerDirty = true;
        }
      }

      function buildRegionGeometry(region, width, height) {
        const geometry = {
          id: region.id,
          colorId: region.colorId,
          bounds: ensureRegionBounds(region, width),
          pixelCount: region.pixelCount ?? region.pixels.length,
          contours: [],
          path: null,
        };
        const contours = buildRegionContours(region, width, height);
        geometry.contours = contours;
        if (SUPPORTS_PATH2D) {
          const path = new Path2D();
          for (const contour of contours) {
            if (contour.length === 0) continue;
            const first = contour[0];
            path.moveTo(first[0], first[1]);
            for (let i = 1; i < contour.length; i++) {
              const point = contour[i];
              path.lineTo(point[0], point[1]);
            }
            path.closePath();
          }
          geometry.path = path;
        }
        return geometry;
      }

      function buildRegionContours(region, width, height) {
        const pixels = Array.isArray(region.pixels) ? region.pixels : [];
        if (pixels.length === 0) {
          return [];
        }
        const membership = new Set(pixels);
        const edges = [];
        const outgoing = new Map();
        const vertexKey = (x, y) => `${x},${y}`;
        const pushEdge = (ax, ay, bx, by) => {
          const edge = { ax, ay, bx, by };
          const index = edges.length;
          edges.push(edge);
          const key = vertexKey(ax, ay);
          if (!outgoing.has(key)) {
            outgoing.set(key, []);
          }
          outgoing.get(key).push(index);
        };
        for (const idx of membership) {
          const x = idx % width;
          const y = (idx / width) | 0;
          const up = idx - width;
          const down = idx + width;
          const left = idx - 1;
          const right = idx + 1;
          if (y === 0 || !membership.has(up)) {
            pushEdge(x, y, x + 1, y);
          }
          if (x === width - 1 || !membership.has(right)) {
            pushEdge(x + 1, y, x + 1, y + 1);
          }
          if (y === height - 1 || !membership.has(down)) {
            pushEdge(x + 1, y + 1, x, y + 1);
          }
          if (x === 0 || !membership.has(left)) {
            pushEdge(x, y + 1, x, y);
          }
        }
        if (edges.length === 0) {
          return [];
        }
        const unused = new Set(edges.map((_, index) => index));
        const contours = [];
        const getVector = (edge) => ({ dx: edge.bx - edge.ax, dy: edge.by - edge.ay });
        const originKey = (edge) => `${edge.ax},${edge.ay}`;
        const limit = edges.length * 8;
        while (unused.size > 0) {
          const startIndex = unused.values().next().value;
          let currentIndex = startIndex;
          const startEdge = edges[startIndex];
          const startKey = originKey(startEdge);
          const contour = [];
          let guard = 0;
          while (true) {
            const edge = edges[currentIndex];
            if (contour.length === 0) {
              contour.push([edge.ax, edge.ay]);
            }
            contour.push([edge.bx, edge.by]);
            unused.delete(currentIndex);
            const nextKey = `${edge.bx},${edge.by}`;
            if (nextKey === startKey) {
              break;
            }
            const candidates = outgoing.get(nextKey) || [];
            let nextIndex = null;
            if (candidates.length === 1) {
              if (unused.has(candidates[0])) {
                nextIndex = candidates[0];
              }
            } else {
              const prevVector = getVector(edge);
              let bestAngle = Number.POSITIVE_INFINITY;
              for (const candidateIndex of candidates) {
                if (!unused.has(candidateIndex)) continue;
                const candidate = edges[candidateIndex];
                const vec = getVector(candidate);
                const cross = prevVector.dx * vec.dy - prevVector.dy * vec.dx;
                const dot = prevVector.dx * vec.dx + prevVector.dy * vec.dy;
                let angle = Math.atan2(cross, dot);
                if (angle <= 0) {
                  angle += Math.PI * 2;
                }
                if (angle < bestAngle) {
                  bestAngle = angle;
                  nextIndex = candidateIndex;
                }
              }
            }
            if (nextIndex == null) {
              break;
            }
            currentIndex = nextIndex;
            guard += 1;
            if (guard > limit) {
              break;
            }
          }
          if (contour.length > 1) {
            const first = contour[0];
            const last = contour[contour.length - 1];
            if (first[0] === last[0] && first[1] === last[1]) {
              contour.pop();
            }
            contours.push(contour);
          }
          if (contours.length > edges.length) {
            break;
          }
        }
        return contours;
      }

      function computeOutlineStrokeWidth(width, height, options = {}) {
        const base = Math.max(1, Math.min(width, height));
        const defaultStroke = clamp(base * 0.0024, 0.8, 2.8);
        const displayScale = options.displayScale;
        if (!Number.isFinite(displayScale) || displayScale <= 0) {
          return defaultStroke;
        }
        const pixelRatio =
          Number.isFinite(options.pixelRatio) && options.pixelRatio > 0
            ? options.pixelRatio
            : getDevicePixelRatio();
        const deviceWidth =
          Number.isFinite(options.deviceWidth) && options.deviceWidth > 0 ? options.deviceWidth : 1;
        const renderScale = Math.max(displayScale * pixelRatio, 0.0001);
        return deviceWidth / renderScale;
      }
      if (samplePreview) {
        const dataUrl = getSampleDataUrl();
        if (dataUrl) {
          samplePreview.src = dataUrl;
          samplePreview.alt = getSampleDescription() || getSampleTitle();
          samplePreview.title = getSampleTitle();
        } else {
          samplePreview.removeAttribute("src");
          samplePreview.alt = "";
          samplePreview.title = "";
        }
      }

      // View state drives pan/zoom transforms. baseScale keeps the puzzle fit-to-screen while
      // zoom holds user-controlled scaling.
      const MAX_VIEWPORT_ZOOM = 3;
      const MIN_VIEWPORT_ZOOM = 1 / 6;
      const MIN_RENDER_SCALE = 1 / 1048576;
      const MAX_RENDER_SCALE = 1048576;
      const SUPPORTS_PATH2D = typeof Path2D === "function";
      const SUPPORTS_OFFSCREEN_CANVAS = typeof OffscreenCanvas === "function";
      const viewState = {
        panX: 0,
        panY: 0,
        zoom: 1,
        baseScale: 1,
      };

      const canvasMetrics = {
        displayScale: 1,
        pixelRatio: 1,
        renderScale: 1,
        displayWidth: 0,
        displayHeight: 0,
        pixelWidth: 0,
        pixelHeight: 0,
      };

      let cachedCanvasRect = null;
      let pendingViewTransform = null;
      let viewTransformFrame = null;
      let cancelViewTransformFrame = null;

      function clampViewPanToPuzzleBounds() {
        let changed = false;
        if (!state.puzzle) {
          if (Math.abs(viewState.panX) > 0.0001) {
            viewState.panX = 0;
            changed = true;
          }
          if (Math.abs(viewState.panY) > 0.0001) {
            viewState.panY = 0;
            changed = true;
          }
          return changed;
        }
        const displayScale = computeDisplayScale();
        const stageHalfWidth = Math.max(0, (state.puzzle.width || 0) * displayScale * 0.5);
        const stageHalfHeight = Math.max(0, (state.puzzle.height || 0) * displayScale * 0.5);
        if (Number.isFinite(stageHalfWidth)) {
          const nextPanX = clamp(viewState.panX, -stageHalfWidth, stageHalfWidth);
          if (Math.abs(nextPanX - viewState.panX) > 0.0001) {
            viewState.panX = nextPanX;
            changed = true;
          }
        } else if (Math.abs(viewState.panX) > 0.0001) {
          viewState.panX = 0;
          changed = true;
        }
        if (Number.isFinite(stageHalfHeight)) {
          const nextPanY = clamp(viewState.panY, -stageHalfHeight, stageHalfHeight);
          if (Math.abs(nextPanY - viewState.panY) > 0.0001) {
            viewState.panY = nextPanY;
            changed = true;
          }
        } else if (Math.abs(viewState.panY) > 0.0001) {
          viewState.panY = 0;
          changed = true;
        }
        return changed;
      }

      function invalidateCanvasRect() {
        cachedCanvasRect = null;
      }

      function getPuzzleCanvasRect() {
        if (!puzzleCanvas) {
          return null;
        }
        if (cachedCanvasRect) {
          return cachedCanvasRect;
        }
        const rect = puzzleCanvas.getBoundingClientRect();
        if (!rect || rect.width <= 0 || rect.height <= 0) {
          cachedCanvasRect = null;
          return null;
        }
        cachedCanvasRect = rect;
        return cachedCanvasRect;
      }

      function getDevicePixelRatio() {
        if (typeof window === "undefined") {
          return 1;
        }
        const ratio = window.devicePixelRatio;
        if (!Number.isFinite(ratio) || ratio <= 0) {
          return 1;
        }
        return ratio;
      }

      function computeDisplayScale() {
        const base = viewState.baseScale > 0 ? viewState.baseScale : 1;
        const zoom = normalizeZoomValue(viewState.zoom > 0 ? viewState.zoom : 1, 1);
        const { minScale, maxScale } = getScaleBounds(base);
        return clamp(base * zoom, minScale, maxScale);
      }

      function updateCanvasMetrics() {
        if (!state.puzzle || !puzzleCanvas) {
          return false;
        }
        const nextDisplayScale = computeDisplayScale();
        const pixelRatio = getDevicePixelRatio();
        const renderScale = nextDisplayScale * pixelRatio;
        const pixelWidth = Math.max(1, Math.round(state.puzzle.width * renderScale));
        const pixelHeight = Math.max(1, Math.round(state.puzzle.height * renderScale));
        const displayWidth = Math.max(1, state.puzzle.width * nextDisplayScale);
        const displayHeight = Math.max(1, state.puzzle.height * nextDisplayScale);
        const changed =
          Math.abs(nextDisplayScale - canvasMetrics.displayScale) > 0.0001 ||
          canvasMetrics.pixelWidth !== pixelWidth ||
          canvasMetrics.pixelHeight !== pixelHeight ||
          Math.abs(pixelRatio - canvasMetrics.pixelRatio) > 0.0001;
        canvasMetrics.displayScale = nextDisplayScale;
        canvasMetrics.pixelRatio = pixelRatio;
        canvasMetrics.renderScale = renderScale;
        canvasMetrics.pixelWidth = pixelWidth;
        canvasMetrics.pixelHeight = pixelHeight;
        canvasMetrics.displayWidth = displayWidth;
        canvasMetrics.displayHeight = displayHeight;
        return changed;
      }

      function applyCanvasSizing() {
        if (!state.puzzle || !puzzleCanvas) {
          return false;
        }
        const metricsChanged = updateCanvasMetrics();
        puzzleCanvas.style.width = `${canvasMetrics.displayWidth}px`;
        puzzleCanvas.style.height = `${canvasMetrics.displayHeight}px`;
        if (canvasTransform) {
          canvasTransform.style.width = `${canvasMetrics.displayWidth}px`;
          canvasTransform.style.height = `${canvasMetrics.displayHeight}px`;
        }
        if (state.rendering?.controller) {
          state.rendering.controller.resize({ ...canvasMetrics });
        } else {
          if (puzzleCanvas.width !== canvasMetrics.pixelWidth) {
            puzzleCanvas.width = canvasMetrics.pixelWidth;
          }
          if (puzzleCanvas.height !== canvasMetrics.pixelHeight) {
            puzzleCanvas.height = canvasMetrics.pixelHeight;
          }
        }
        invalidateCanvasRect();
        return metricsChanged;
      }

      function ensureCanvasMetricsInitialized() {
        if (!state.puzzle || !puzzleCanvas) return;
        if (canvasMetrics.pixelWidth <= 0 || canvasMetrics.pixelHeight <= 0) {
          applyCanvasSizing();
        }
      }

      function withRenderScale(ctx, scale, callback) {
        ctx.save();
        ctx.setTransform(scale, 0, 0, scale, 0, 0);
        ctx.imageSmoothingEnabled = false;
        try {
          callback(scale);
        } finally {
          ctx.restore();
        }
      }

      function clearContext(ctx) {
        if (!ctx) return;
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.restore();
      }

      function syncCacheMetrics(cache) {
        if (!cache) return false;
        const fallbackWidth = Math.max(1, cache.width || 1);
        const fallbackHeight = Math.max(1, cache.height || 1);
        const pixelWidth = Math.max(1, canvasMetrics.pixelWidth || fallbackWidth);
        const pixelHeight = Math.max(1, canvasMetrics.pixelHeight || fallbackHeight);
        const renderScale = canvasMetrics.renderScale > 0 ? canvasMetrics.renderScale : 1;
        const changed =
          cache.pixelWidth !== pixelWidth ||
          cache.pixelHeight !== pixelHeight ||
          Math.abs((cache.renderScale || 0) - renderScale) > 0.0001;
        cache.pixelWidth = pixelWidth;
        cache.pixelHeight = pixelHeight;
        cache.renderScale = renderScale;
        cache.strokeWidth = computeOutlineStrokeWidth(cache.width, cache.height, {
          displayScale: canvasMetrics.displayScale,
          pixelRatio: canvasMetrics.pixelRatio,
          deviceWidth: 1,
        });
        if (cache.filledLayer) {
          let resized = false;
          if (cache.filledLayer.width !== pixelWidth) {
            cache.filledLayer.width = pixelWidth;
            resized = true;
          }
          if (cache.filledLayer.height !== pixelHeight) {
            cache.filledLayer.height = pixelHeight;
            resized = true;
          }
          if (resized || !cache.filledLayerCtx) {
            cache.filledLayerCtx = getLayerContext(cache.filledLayer);
          }
          if (resized) {
            cache.filledLayerNeedsUpload = true;
          }
        }
        if (cache.outlineLayer) {
          let resized = false;
          if (cache.outlineLayer.width !== pixelWidth) {
            cache.outlineLayer.width = pixelWidth;
            resized = true;
          }
          if (cache.outlineLayer.height !== pixelHeight) {
            cache.outlineLayer.height = pixelHeight;
            resized = true;
          }
          if (resized || !cache.outlineLayerCtx) {
            cache.outlineLayerCtx = getLayerContext(cache.outlineLayer);
          }
        }
        if (changed) {
          cache.filledLayerDirty = true;
          cache.filledLayerNeedsUpload = true;
          cache.outlineLayerDirty = true;
        }
        return changed;
      }

      let panPointerId = null;
      let panPointerType = null;
      const panOrigin = { x: 0, y: 0, panX: 0, panY: 0 };
      let panCandidate = null;
      let isPanning = false;
      let panCaptureTarget = null;
      let panHasPointerCapture = false;
      let panGlobalListenersAttached = false;
      const pointerSessions = new Map();
      const globalPanListenerOptions = { capture: true };
      let spacePressed = false;
      const overlayAnimations = new Map();
      let overlayAnimationFrame = null;
      let overlayAnimationTimeout = null;
      const activeTouches = new Map();
      let pinchSession = null;
      let lastViewportMetrics = { orientation: null, width: 0, height: 0 };
      let lastCommandRailMetrics = { top: 0, height: 0 };
      let commandRailMeasureFrame = null;
      let cursorHoverRegionId = null;
      let cursorLastClientX = null;
      let cursorLastClientY = null;
      let lastTouchTapTime = 0;
      let lastTouchTapRegionId = null;
      let lastTouchSelectionTime = 0;
      const prefersReducedMotionQuery = window.matchMedia
        ? window.matchMedia("(prefers-reduced-motion: reduce)")
        : null;

      function syncCommandRailMetrics() {
        if (!commandRail) {
          return lastCommandRailMetrics;
        }
        const height = Math.max(0, Math.round(commandRail.offsetHeight || 0));
        const top = Math.max(0, Math.round(commandRail.offsetTop || 0));
        const rootStyle = document.documentElement?.style;
        if (rootStyle) {
          if (height > 0 && height !== lastCommandRailMetrics.height) {
            rootStyle.setProperty("--command-rail-height", `${height}px`);
          }
          if (top !== lastCommandRailMetrics.top) {
            rootStyle.setProperty("--command-rail-top", `${top}px`);
          }
        }
        lastCommandRailMetrics = { top, height };
        return lastCommandRailMetrics;
      }

      function scheduleCommandRailMetricsSync() {
        if (!commandRail) {
          return;
        }
        if (typeof window?.requestAnimationFrame !== "function") {
          syncCommandRailMetrics();
          return;
        }
        if (commandRailMeasureFrame != null) {
          window.cancelAnimationFrame(commandRailMeasureFrame);
        }
        commandRailMeasureFrame = window.requestAnimationFrame(() => {
          commandRailMeasureFrame = null;
          syncCommandRailMetrics();
        });
      }

      // Primary puzzle state bag. applyPuzzleResult populates it and render* helpers read from it.
      const state = {
        puzzle: null,
        activeColor: null,
        filled: new Set(),
        sourceUrl: null,
        sourceTitle: null,
        lastOptions: null,
        sampleDetailLevel: DEFAULT_SAMPLE_DETAIL,
        paletteSort: "region",
        settings: {
          autoAdvance: true,
          animateHints: true,
          hintFadeDuration: DEFAULT_HINT_FADE_DURATION,
          hintIntensity: DEFAULT_HINT_INTENSITY,
          hintTypes: { ...DEFAULT_HINT_TYPES },
          difficulty: DEFAULT_DIFFICULTY,
          backgroundColor: DEFAULT_BACKGROUND_HEX,
          stageBackgroundColor: DEFAULT_STAGE_BACKGROUND_HEX,
          uiScale: DEFAULT_UI_SCALE,
          labelScale: DEFAULT_LABEL_SCALE,
          artPrompt: "",
          imageDescription: "",
          showRegionLabels: true,
          theme: DEFAULT_UI_THEME,
          renderer: "canvas2d",
          mouseControls: cloneMouseControls(DEFAULT_MOUSE_CONTROLS),
        },
        previewVisible: false,
        saves: gameSaveManager.hydrate(),
        loadedSaveId: null,
        previewImageData: null,
        renderCache: createRenderCache(),
        rendering: { controller: null },
        defaultGame: {
          id: DEFAULT_GAME_SOURCE.id,
          path: DEFAULT_GAME_SOURCE.path,
          title: DEFAULT_GAME_FALLBACK.title,
          description: DEFAULT_GAME_FALLBACK.description,
        },
        sampleArtwork: null,
        paletteDisplayNumbers: new Map(),
      };

      const storedUserSettings = loadUserSettings();
      if (storedUserSettings) {
        state.settings = {
          ...state.settings,
          ...storedUserSettings,
        };
      }

      const unavailableRenderers = new Set();

      function logRendererEvent(message, details = null) {
        if (details && typeof details === "object") {
          const suffix = Object.entries(details)
            .map(([key, value]) => `${key}=${value}`)
            .join(", ");
          logDebug(`[Renderer] ${message}${suffix ? ` (${suffix})` : ""}`);
        } else {
          logDebug(`[Renderer] ${message}`);
        }
      }

      rendererController = createRendererController(puzzleCanvas, {
        initialRenderer: state.settings.renderer || "canvas2d",
        hooks: {
          log: logRendererEvent,
          renderFrame: renderPuzzleFrame,
          renderPreview: renderPreviewImage,
          flashRegions: flashRegionsWithContext,
          fillBackground: fillBackgroundLayer,
          rebuildFilledLayer: ({ cache }) => rebuildFilledLayer(cache),
          rasterizeOutlineLayer: ({ cache }) => rasterizeOutlineLayer(cache),
          drawNumbersLayer: ({ context }) => {
            if (context) {
              drawNumbers(context);
            }
          },
          clearContext: ({ context }) => clearContext(context),
          onRendererChange: handleRendererChange,
        },
        renderers: {
          webgl: (currentCanvas, currentHooks, payload) => {
            if (!currentCanvas) {
              throw new Error("WebGL renderer unavailable");
            }
            const host = currentCanvas.parentElement;
            if (!host) {
              throw new Error("WebGL renderer unavailable");
            }
            const webglCanvas = document.createElement("canvas");
            webglCanvas.classList.add("renderer-surface", "renderer-surface-webgl");
            webglCanvas.setAttribute("aria-hidden", "true");
            webglCanvas.style.position = "absolute";
            webglCanvas.style.top = "0";
            webglCanvas.style.left = "0";
            webglCanvas.style.width = "100%";
            webglCanvas.style.height = "100%";
            webglCanvas.style.pointerEvents = "none";
            webglCanvas.style.userSelect = "none";
            host.insertBefore(webglCanvas, currentCanvas.nextSibling);
            if (typeof currentHooks?.log === "function") {
              try {
                currentHooks.log("Attaching WebGL surface", { stage: "init" });
              } catch (logError) {
                console.debug("Renderer log failed", logError);
              }
            }
            let renderer;
            try {
              renderer = createWebGLRenderer(webglCanvas, currentHooks, payload);
            } catch (error) {
              webglCanvas.remove();
              throw error;
            }
            if (!renderer) {
              webglCanvas.remove();
              throw new Error("WebGL renderer unavailable");
            }
            if (typeof currentHooks?.log === "function") {
              try {
                currentHooks.log("WebGL renderer created", { stage: "ready" });
              } catch (logError) {
                console.debug("Renderer log failed", logError);
              }
            }
            const baseDispose = typeof renderer.dispose === "function" ? renderer.dispose.bind(renderer) : null;
            return {
              ...renderer,
              dispose() {
                if (baseDispose) {
                  baseDispose();
                }
                if (typeof currentHooks?.log === "function") {
                  try {
                    currentHooks.log("WebGL renderer disposed", { stage: "dispose" });
                  } catch (logError) {
                    console.debug("Renderer log failed", logError);
                  }
                }
                webglCanvas.remove();
              },
            };
          },
          svg: (currentCanvas, currentHooks, payload) => {
            const renderer = createSvgRenderer(currentCanvas, currentHooks, payload);
            if (!renderer) {
              throw new Error("SVG renderer unavailable");
            }
            return renderer;
          },
        },
      });
      state.rendering.controller = rendererController;
      updateRendererModeAvailability();

      function handleRendererChange(change = {}) {
        const nextType = normalizeRendererType(change?.type) || null;
        if (nextType) {
          state.settings.renderer = nextType;
          if (rendererModeSelect && rendererModeSelect.value !== nextType) {
            rendererModeSelect.value = nextType;
          }
          unavailableRenderers.delete(nextType);
        }
        if (puzzleCanvas) {
          if (nextType === "webgl") {
            puzzleCanvas.style.opacity = "0";
          } else {
            puzzleCanvas.style.opacity = "";
          }
        }
        if (canvasStage) {
          if (nextType) {
            canvasStage.dataset.renderer = nextType;
          } else {
            delete canvasStage.dataset.renderer;
          }
        }
        updateRendererModeAvailability();
      }

      let generationJobCounter = 0;
      let latestGenerationJobId = 0;
      let puzzleGenerationModulePromise = null;
      let pendingImportFile = null;
      let pendingImportAutoStart = false;
      updateImportNotice();
      let shouldAutoLoadSample = false;
      let algorithmOptionsHydrated = false;
      updateMouseControlInputs();

      function disableSampleAutoload() {
        shouldAutoLoadSample = false;
      }

      function maybeAutoLoadSample(options = {}) {
        if (!shouldAutoLoadSample) {
          return;
        }
        if (state.puzzle) {
          shouldAutoLoadSample = false;
          return;
        }
        if (pendingImportFile) {
          return;
        }
        const dataUrl = getSampleDataUrl();
        const hasDefaultGame = Boolean(DEFAULT_GAME_SOURCE?.path);
        if (!dataUrl && !hasDefaultGame) {
          return;
        }
        disableSampleAutoload();
        const { announce = false } = options;
        loadSamplePuzzle({
          detailLevel: state.sampleDetailLevel,
          skipDetailUpdate: true,
          announce,
        });
      }

      gameSaveManager.subscribe((entries) => {
        state.saves = entries;
        if (state.loadedSaveId && !state.saves.some((item) => item.id === state.loadedSaveId)) {
          state.loadedSaveId = null;
        }
        refreshSaveList();
        updateStorageUsageSummary();
      });

      migrateLegacyAutosave();

      function getDefaultGameTitle() {
        const title = state.defaultGame?.title;
        if (typeof title === "string" && title.trim()) {
          return title.trim();
        }
        const fallback = DEFAULT_GAME_FALLBACK.title;
        if (typeof fallback === "string" && fallback.trim()) {
          return fallback.trim();
        }
        return DEFAULT_GAME_SOURCE.path;
      }

      function getDefaultGameDescription() {
        const description = state.defaultGame?.description;
        if (typeof description === "string" && description.trim()) {
          return description.trim();
        }
        const fallback = DEFAULT_GAME_FALLBACK.description;
        if (typeof fallback === "string" && fallback.trim()) {
          return fallback.trim();
        }
        return "";
      }

      function getSampleArtwork() {
        return state.sampleArtwork || null;
      }

      function getSampleDataUrl() {
        const artwork = getSampleArtwork();
        if (!artwork || typeof artwork.dataUrl !== "string") {
          return null;
        }
        const trimmed = artwork.dataUrl.trim();
        return trimmed ? trimmed : null;
      }

      function getSampleTitle() {
        const artwork = getSampleArtwork();
        if (artwork && typeof artwork.title === "string" && artwork.title.trim()) {
          return artwork.title.trim();
        }
        const fallback = getDefaultGameTitle();
        return fallback || "Sample puzzle";
      }

      function getSampleDescription() {
        const artwork = getSampleArtwork();
        if (artwork && typeof artwork.description === "string" && artwork.description.trim()) {
          return artwork.description.trim();
        }
        const fallback = getDefaultGameDescription();
        return fallback || "";
      }

      function applyDefaultGameMetadata(metadata = {}) {
        const fallbackTitle = DEFAULT_GAME_FALLBACK.title;
        const fallbackDescription = DEFAULT_GAME_FALLBACK.description;
        const titleValue =
          typeof metadata.title === "string" && metadata.title.trim()
            ? metadata.title.trim()
            : typeof fallbackTitle === "string" && fallbackTitle.trim()
            ? fallbackTitle.trim()
            : "";
        const descriptionValue =
          typeof metadata.description === "string" && metadata.description.trim()
            ? metadata.description.trim()
            : typeof fallbackDescription === "string" && fallbackDescription.trim()
            ? fallbackDescription.trim()
            : "";
        state.defaultGame = {
          id: DEFAULT_GAME_SOURCE.id,
          path: DEFAULT_GAME_SOURCE.path,
          title: titleValue,
          description: descriptionValue,
        };
        refreshGameSelection();
      }

      function applySampleArtwork(artwork) {
        state.sampleArtwork = artwork || null;
        applySampleDetailLevel(state.sampleDetailLevel, {
          skipReload: true,
          skipLog: true,
          skipOptions: true,
        });
      }

      function normalizeSampleArtwork(source, defaults = {}) {
        if (!source || typeof source !== "object") return null;
        const dataUrl = typeof source.dataUrl === "string" ? source.dataUrl.trim() : "";
        if (!dataUrl) return null;
        const title =
          typeof source.title === "string" && source.title.trim()
            ? source.title.trim()
            : typeof defaults.title === "string" && defaults.title.trim()
            ? defaults.title.trim()
            : "";
        const description =
          typeof source.description === "string" && source.description.trim()
            ? source.description.trim()
            : typeof defaults.description === "string" && defaults.description.trim()
            ? defaults.description.trim()
            : "";
        return {
          title,
          description,
          dataUrl,
        };
      }

      async function fetchDefaultGamePayload(options = {}) {
        const { forceRefresh = false } = options;
        if (!forceRefresh && cachedDefaultGame) {
          return cachedDefaultGame;
        }
        if (!forceRefresh && defaultGameRequest) {
          return defaultGameRequest;
        }
        const request = (async () => {
          const response = await fetch(DEFAULT_GAME_SOURCE.path, { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Request failed with status ${response.status}`);
          }
          const payload = await response.json();
          const requestedTitle =
            typeof payload.title === "string" && payload.title.trim() ? payload.title.trim() : "";
          const requestedDescription =
            typeof payload.description === "string" && payload.description.trim()
              ? payload.description.trim()
              : "";
          applyDefaultGameMetadata({
            title: requestedTitle,
            description: requestedDescription,
          });
          const resolvedTitle = getDefaultGameTitle();
          const resolvedDescription = getDefaultGameDescription();
          const artwork = normalizeSampleArtwork(payload.sampleArtwork, {
            title: resolvedTitle,
            description: resolvedDescription,
          });
          applySampleArtwork(artwork);
          return {
            payload,
            resolvedTitle,
            resolvedDescription,
          };
        })();

        if (!forceRefresh) {
          defaultGameRequest = request
            .then((result) => {
              cachedDefaultGame = result;
              return result;
            })
            .catch((error) => {
              if (defaultGameRequest === request) {
                defaultGameRequest = null;
              }
              throw error;
            })
            .finally(() => {
              if (defaultGameRequest === request) {
                defaultGameRequest = null;
              }
            });
          return defaultGameRequest;
        }

        try {
          const result = await request;
          cachedDefaultGame = result;
          return result;
        } finally {
          if (defaultGameRequest === request) {
            defaultGameRequest = null;
          }
        }
      }

      function normalizeRendererType(value) {
        if (typeof value !== "string") return null;
        const trimmed = value.trim().toLowerCase();
        return trimmed ? trimmed : null;
      }

      function formatRendererLabel(type) {
        switch (normalizeRendererType(type)) {
          case "webgl":
            return "WebGL";
          case "svg":
            return "SVG";
          case "canvas2d":
          default:
            return "Canvas 2D";
        }
      }

      function markRendererUnavailable(type) {
        const normalized = normalizeRendererType(type);
        if (!normalized) return;
        logRendererEvent(`Renderer unavailable`, { type: normalized });
        unavailableRenderers.add(normalized);
        if (rendererModeSelect) {
          for (const option of rendererModeSelect.options) {
            if (normalizeRendererType(option.value) === normalized) {
              option.disabled = true;
              option.title = "Not supported on this device";
              break;
            }
          }
        }
      }

      function updateRendererModeAvailability() {
        if (!rendererModeSelect) {
          return;
        }
        const controller = state.rendering?.controller || null;
        let listed = [];
        if (controller?.listRenderers) {
          try {
            listed = controller.listRenderers() || [];
          } catch (error) {
            listed = [];
          }
        }
        const available = new Set(listed.map((entry) => normalizeRendererType(entry)).filter(Boolean));
        for (const option of rendererModeSelect.options) {
          const value = normalizeRendererType(option.value);
          if (!value) continue;
          const isUnavailable = unavailableRenderers.has(value);
          const supported = available.has(value) || value === "canvas2d";
          option.disabled = isUnavailable || !supported;
          if (option.disabled && isUnavailable) {
            option.title = "Not supported on this device";
          } else {
            option.removeAttribute("title");
          }
        }
        const activeType = normalizeRendererType(
          controller?.getRendererType?.() || state.settings.renderer || "canvas2d"
        );
        if (activeType && rendererModeSelect.value !== activeType) {
          rendererModeSelect.value = activeType;
        }
      }

      function applyRendererMode(type, options = {}) {
        const controller = state.rendering?.controller;
        const requested = normalizeRendererType(type) || state.settings.renderer || "canvas2d";
        if (!controller || typeof controller.setRenderer !== "function") {
          state.settings.renderer = requested;
          if (rendererModeSelect) {
            rendererModeSelect.value = requested;
          }
          return requested;
        }
        let availableTypes = [];
        try {
          availableTypes = controller.listRenderers?.() || [];
        } catch (error) {
          availableTypes = [];
        }
        const availableSet = new Set(
          availableTypes.map((entry) => normalizeRendererType(entry)).filter(Boolean)
        );
        const fallback = availableSet.has("canvas2d")
          ? "canvas2d"
          : availableSet.size > 0
          ? Array.from(availableSet)[0]
          : "canvas2d";
        let target = normalizeRendererType(requested) || fallback;
        if (!availableSet.has(target) && !unavailableRenderers.has(target)) {
          target = fallback;
        }
        const previous = normalizeRendererType(controller.getRendererType?.());
        let resolved = previous || null;
        let changed = false;
        try {
          const result = controller.setRenderer(target);
          resolved = normalizeRendererType(controller.getRendererType?.() || (result ? target : null));
        } catch (error) {
          console.error(`Failed to activate renderer: ${target}`, error);
          markRendererUnavailable(target);
          resolved = normalizeRendererType(controller.getRendererType?.()) || previous || fallback;
        }
        if (!resolved || (!availableSet.has(resolved) && !unavailableRenderers.has(resolved))) {
          resolved = fallback;
          if (normalizeRendererType(controller.getRendererType?.()) !== resolved) {
            try {
              controller.setRenderer(resolved);
            } catch (fallbackError) {
              console.error(`Failed to fall back to renderer: ${resolved}`, fallbackError);
            }
          }
        }
        if (resolved !== previous) {
          changed = true;
        }
        state.settings.renderer = resolved;
        if (rendererModeSelect) {
          rendererModeSelect.value = resolved;
        }
        updateRendererModeAvailability();
        if (changed && !options.skipRender) {
          applyCanvasSizing();
          renderPuzzle();
        }
        if (changed && !options.skipLog) {
          logDebug(`Renderer switched to ${formatRendererLabel(resolved)}`);
        }
        if (changed && !options.skipAutosave) {
          scheduleAutosave("settings-renderer");
        }
        return resolved;
      }

      function applyGameplaySettings(settings = {}) {
        if (!settings || typeof settings !== "object") return;
        if (settings.renderer) {
          applyRendererMode(settings.renderer, { skipAutosave: true, skipLog: true, skipRender: true });
        } else {
          updateRendererModeAvailability();
        }
        if (typeof settings.theme === "string") {
          applyTheme(settings.theme, { skipLog: true, skipAutosave: true });
        } else if (state.settings.theme) {
          applyTheme(state.settings.theme, { skipLog: true, skipAutosave: true });
        }
        if (typeof settings.stageBackgroundColor === "string") {
          applyStageBackgroundColor(settings.stageBackgroundColor, {
            skipLog: true,
            skipAutosave: true,
          });
        } else {
          applyStageBackgroundColor(state.settings.stageBackgroundColor, {
            skipLog: true,
            skipAutosave: true,
            force: true,
          });
        }
        if (typeof settings.labelScale === "number") {
          applyLabelScale(settings.labelScale, { skipLog: true, skipAutosave: true });
        } else if (state.settings.labelScale != null) {
          applyLabelScale(state.settings.labelScale, { skipLog: true, skipAutosave: true });
        }
        if (typeof settings.autoAdvance === "boolean") {
          state.settings.autoAdvance = settings.autoAdvance;
          if (autoAdvanceToggle) {
            autoAdvanceToggle.checked = settings.autoAdvance;
          }
        }
        if (typeof settings.animateHints === "boolean") {
          state.settings.animateHints = settings.animateHints;
          if (hintFlashToggle) {
            hintFlashToggle.checked = settings.animateHints;
          }
        }
        const hintTypes = normalizeHintTypes(settings.hintTypes, state.settings.hintTypes);
        state.settings.hintTypes = hintTypes;
        syncHintTypeToggles();
        if (settings.hintFadeDuration != null) {
          const duration = normalizeHintFadeDuration(settings.hintFadeDuration);
          state.settings.hintFadeDuration = duration;
          if (hintFadeDurationInput) {
            hintFadeDurationInput.value = String(duration);
          }
        } else if (hintFadeDurationInput && state.settings.hintFadeDuration != null) {
          const duration = normalizeHintFadeDuration(state.settings.hintFadeDuration);
          state.settings.hintFadeDuration = duration;
          hintFadeDurationInput.value = String(duration);
        }
        if (settings.hintIntensity != null) {
          const intensity = normalizeHintIntensity(settings.hintIntensity);
          state.settings.hintIntensity = intensity;
          if (hintIntensityInput) {
            hintIntensityInput.value = String(Math.round(intensity * 100));
          }
        } else if (hintIntensityInput && state.settings.hintIntensity != null) {
          const intensity = normalizeHintIntensity(state.settings.hintIntensity);
          state.settings.hintIntensity = intensity;
          hintIntensityInput.value = String(Math.round(intensity * 100));
        }
        if (settings.difficulty != null) {
          const difficulty = resolveDifficulty(settings.difficulty);
          state.settings.difficulty = difficulty;
          if (difficultySelect) {
            difficultySelect.value = difficulty;
          }
        } else if (difficultySelect) {
          const difficulty = resolveDifficulty(state.settings.difficulty);
          state.settings.difficulty = difficulty;
          difficultySelect.value = difficulty;
        }
        if (typeof settings.showRegionLabels === "boolean") {
          applyRegionLabelVisibility(settings.showRegionLabels, {
            skipLog: true,
            skipAutosave: true,
            skipRender: true,
          });
        } else {
          applyRegionLabelVisibility(state.settings.showRegionLabels !== false, {
            skipLog: true,
            skipAutosave: true,
            skipRender: true,
          });
        }
        if (typeof settings.uiScale === "number") {
          applyUiScale(settings.uiScale, { skipLog: true, skipAutosave: true });
        }
        if (typeof settings.labelScale === "number") {
          applyLabelScale(settings.labelScale, {
            skipLog: true,
            skipAutosave: true,
            skipRender: true,
          });
        } else if (state.settings.labelScale != null) {
          applyLabelScale(state.settings.labelScale, {
            skipLog: true,
            skipAutosave: true,
            skipRender: true,
          });
        }
        if (typeof settings.artPrompt === "string") {
          applyArtPrompt(settings.artPrompt, { skipLog: true, skipAutosave: true });
        }
        if (typeof settings.imageDescription === "string") {
          applyImageDescription(settings.imageDescription, { skipLog: true, skipAutosave: true });
        } else if (state.settings.imageDescription != null) {
          applyImageDescription(state.settings.imageDescription, {
            skipLog: true,
            skipAutosave: true,
          });
        } else {
          applyImageDescription("", { skipLog: true, skipAutosave: true });
        }
        if (settings.mouseControls) {
          applyMouseControls(settings.mouseControls, { skipLog: true, skipAutosave: true });
        } else {
          applyMouseControls(state.settings.mouseControls, { skipLog: true, skipAutosave: true });
        }
        scheduleSettingsPersist({ delay: 0 });
        updateOptionOutputs();
      }

      const debugLogEntries = [];
      const DEBUG_LOG_LIMIT = 80;

      if (typeof window !== "undefined") {
        installBrowserZoomGuards();
        // Public hooks for tests and manual loading. Keep backwards compatible.
        window.capyGenerator = {
          getState: () => state,
          setActiveColor(colorId, options = {}) {
            if (colorId == null) {
              return false;
            }
            const { flash = false, redraw = true } = options;
            return activateColor(colorId, { flash, redraw });
          },
          getRendererType() {
            return state.rendering?.controller?.getRendererType?.() || null;
          },
          listRenderers() {
            const controller = state.rendering?.controller;
            if (!controller?.listRenderers) {
              return [];
            }
            try {
              return controller.listRenderers();
            } catch (error) {
              console.error("Unable to list renderers", error);
              return [];
            }
          },
          setRenderer(type) {
            const resolved = applyRendererMode(type, {
              skipAutosave: true,
              skipLog: true,
            });
            return resolved;
          },
          registerRenderer(type, factory) {
            const controller = state.rendering?.controller;
            if (!controller?.registerRenderer) {
              return false;
            }
            try {
              const registered = controller.registerRenderer(type, factory);
              if (registered && controller.getRendererType?.() === type) {
                applyCanvasSizing();
                renderPuzzle();
              }
              return registered;
            } catch (error) {
              console.error(`Failed to register renderer: ${type}`, error);
              return false;
            }
          },
          unregisterRenderer(type) {
            const controller = state.rendering?.controller;
            if (!controller?.unregisterRenderer) {
              return false;
            }
            try {
              return controller.unregisterRenderer(type);
            } catch (error) {
              console.error(`Failed to unregister renderer: ${type}`, error);
              return false;
            }
          },
          loadFromDataUrl(dataUrl, metadata) {
            if (typeof dataUrl !== "string" || dataUrl.length === 0) {
              return;
            }
            resetPuzzleUI();
            state.sourceUrl = dataUrl;
            const metadataTitle =
              metadata && typeof metadata === "object"
                ? typeof metadata.title === "string" && metadata.title.trim()
                  ? metadata.title.trim()
                  : null
                : typeof metadata === "string" && metadata.trim()
                ? metadata.trim()
                : null;
            state.sourceTitle = metadataTitle || "External data";
            hideStartScreen();
            logDebug(`Loading external puzzle data: ${state.sourceTitle}`);
            loadImage(dataUrl);
          },
          loadPuzzleFixture(puzzle) {
            return loadPuzzleFixtureData(puzzle);
          },
          setBackgroundColor(hex) {
            applyBackgroundColor(hex);
          },
          setStageBackgroundColor(hex) {
            applyStageBackgroundColor(hex);
          },
          setUiScale(scale) {
            applyUiScale(scale);
          },
          setTheme(theme) {
            applyTheme(theme);
          },
          setArtPrompt(promptText) {
            applyArtPrompt(promptText);
          },
          setImageDescription(description) {
            applyImageDescription(description);
          },
          setRegionLabelsVisible(visible) {
            if (typeof visible === "boolean") {
              applyRegionLabelVisibility(visible);
            } else {
              applyRegionLabelVisibility(state.settings.showRegionLabels === false);
            }
          },
          isBrowserZoomSuppressed() {
            return preventingBrowserZoom;
          },
          togglePreview(show) {
            if (typeof show === "boolean") {
              state.previewVisible = show;
            } else {
              state.previewVisible = !state.previewVisible;
            }
            updatePreviewState();
          },
          openGenerator: () => openSheet(generatorSheet),
          openSettings: () => openSheet(settingsSheet),
          openSaves: () => openSheet(saveManagerSheet),
          resetProgress: () => resetCurrentProgress(),
          fillRegion(regionId, options = {}) {
            if (!state.puzzle) {
              return "ignored";
            }
            if (regionId == null) {
              return "invalid-region";
            }
            const {
              ensureColor = true,
              flash = false,
              redraw = true,
              label = "automation-fill",
            } = options || {};
            const region = state.puzzle.regions.find((entry) => entry?.id === regionId) || null;
            if (!region) {
              return "missing-region";
            }
            if (ensureColor && state.activeColor !== region.colorId) {
              activateColor(region.colorId, { flash, redraw });
            }
            return attemptFillRegion({ region, regionId: region.id }, { label });
          },
        };
      }

      applyGameplaySettings(state.settings);
      updateOptionOutputs();
      refreshSaveList();
      updateStorageUsageSummary();
      updateCommandStates();
      renderDebugLog();
      logDebug("Session started");
      syncCommandRailMetrics();
      handleViewportChange({ log: true, recenter: true });
      resetView({ recenter: true });

      if (paletteSortEl) {
        paletteSortEl.value = state.paletteSort;
        paletteSortEl.disabled = true;
        paletteSortEl.addEventListener("change", (event) => {
          const target = event.currentTarget?.value;
          applyPaletteSort(target);
        });
      }

      for (const button of sampleButtons) {
        if (!button) continue;
        button.setAttribute("type", "button");
        button.addEventListener("click", () => {
          const hasSampleArtwork = Boolean(getSampleDataUrl());
          const hasDefaultPuzzle = Boolean(DEFAULT_GAME_SOURCE?.path);
          if (!hasSampleArtwork && !hasDefaultPuzzle) {
            return;
          }
          if (saveManagerSheet && saveManagerSheet.contains(button)) {
            closeSheet(saveManagerSheet);
          }
          loadSamplePuzzle({ detailLevel: state.sampleDetailLevel });
        });
      }

      if (gameSelectionList) {
        gameSelectionList.addEventListener("click", (event) => {
          const target = event.target.closest("[data-game-id]");
          if (!target) return;
          const gameId = target.getAttribute("data-game-id");
          if (!gameId) return;
          if (gameId === DEFAULT_GAME_SOURCE.id) {
            loadDefaultPuzzle({ announce: true });
          } else {
            loadSaveEntry(gameId);
          }
        });
      }

      for (const button of sampleDetailButtons) {
        if (!button) continue;
        button.setAttribute("type", "button");
        button.addEventListener("click", (event) => {
          const target = event?.currentTarget?.dataset?.detailLevel;
          applySampleDetailLevel(target);
        });
      }

      applySampleDetailLevel(DEFAULT_SAMPLE_DETAIL, { skipReload: true, skipLog: true });

      const restoredSession = loadInitialSession();
      shouldAutoLoadSample = !restoredSession;
      maybeAutoLoadSample();

      fetchDefaultGamePayload()
        .then(() => {
          maybeAutoLoadSample();
        })
        .catch((error) => {
          console.error("Failed to preload default puzzle metadata", error);
        });

      if (settingsTabButtons.length > 0) {
        settingsTabButtons.forEach((button, index) => {
          button.addEventListener("click", () => {
            const tabId = button.dataset.settingsTab;
            if (tabId) {
              activateSettingsTab(tabId, { resetScroll: true });
            }
          });
          button.addEventListener("keydown", (event) => {
            switch (event.key) {
              case "ArrowRight":
              case "ArrowDown":
                event.preventDefault();
                focusSettingsTabRelative(index, 1, { resetScroll: true });
                break;
              case "ArrowLeft":
              case "ArrowUp":
                event.preventDefault();
                focusSettingsTabRelative(index, -1, { resetScroll: true });
                break;
              case "Home":
                event.preventDefault();
                focusSettingsTab(0, { resetScroll: true });
                break;
              case "End":
                event.preventDefault();
                focusSettingsTab(settingsTabButtons.length - 1, { resetScroll: true });
                break;
              default:
                break;
            }
          });
        });
      }

      if (selectButton) {
        selectButton.addEventListener("click", () => {
          if (saveManagerSheet && saveManagerSheet.contains(selectButton)) {
            closeSheet(saveManagerSheet);
          }
          fileInput.click();
        });
      }
      importButton.addEventListener("click", () => fileInput.click());
      if (generatorButton) {
        generatorButton.addEventListener("click", () => openSheet(generatorSheet));
      }
      settingsButton.addEventListener("click", () => openSheet(settingsSheet));
      saveManagerButton.addEventListener("click", () => {
        hideStartScreen();
        openSheet(saveManagerSheet);
      });
      if (helpButton) {
        helpButton.addEventListener("click", () => openSheet(helpSheet));
      }

      if (startHintCloseButton) {
        startHintCloseButton.addEventListener("click", () => {
          hideStartScreen();
          if (saveManagerButton && !saveManagerButton.disabled) {
            saveManagerButton.focus();
          }
        });
      }

      if (fullscreenButton) {
        fullscreenButton.addEventListener("click", () => toggleFullscreen());
        updateFullscreenState();
      }

      document.addEventListener("fullscreenchange", () => {
        updateFullscreenState();
        const active = Boolean(document.fullscreenElement);
        logDebug(active ? "Entered fullscreen mode" : "Exited fullscreen mode");
        handleViewportChange({ log: true, recenter: true });
      });

      if (clearDebugLogButton) {
        clearDebugLogButton.addEventListener("click", () => {
          debugLogEntries.splice(0, debugLogEntries.length);
          renderDebugLog();
          logDebug("Debug log cleared");
        });
      }

      if (deleteAllSavesButton) {
        deleteAllSavesButton.addEventListener("click", () => {
          const confirmed = window.confirm("Delete all saves? This can't be undone.");
          if (!confirmed) {
            return;
          }
          clearAllSaveData();
        });
      }

      for (const button of document.querySelectorAll('[data-sheet-close]')) {
        button.addEventListener("click", (event) => {
          const target = event.currentTarget.getAttribute("data-sheet-close");
          if (target === "settings") {
            closeSheet(settingsSheet);
          } else if (target === "generator") {
            closeSheet(generatorSheet);
          } else if (target === "help") {
            closeSheet(helpSheet);
          } else if (target === "saves") {
            closeSheet(saveManagerSheet);
          }
        });
      }

      if (startHint) {
        startHint.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            if (!startHint.classList.contains("hidden") && (state.puzzle || state.saves.length > 0)) {
              hideStartScreen();
              if (saveManagerButton && !saveManagerButton.disabled) {
                saveManagerButton.focus();
              }
            }
            return;
          }
          if ((event.key === "Enter" || event.key === " ") && event.target === startHint) {
            event.preventDefault();
            fileInput.click();
          }
        });
      }

      fileInput.addEventListener("change", (event) => {
        const [file] = event.target.files || [];
        if (file) {
          prepareImport(file);
        }
        fileInput.value = "";
      });

      if (generatorUrlForm && generatorUrlInput) {
        generatorUrlForm.addEventListener("submit", (event) => {
          event.preventDefault();
          handleSourceImageUrl(generatorUrlInput.value || "");
        });
        generatorUrlInput.addEventListener("input", () => {
          clearSourceUrlError();
          updateSourceUrlSubmitState();
        });
        updateSourceUrlSubmitState();
      }

      if (confirmImportBtn) {
        confirmImportBtn.hidden = true;
        confirmImportBtn.disabled = true;
        confirmImportBtn.addEventListener("click", () => {
          executePendingImport();
        });
      }

      if (cancelImportBtn) {
        cancelImportBtn.hidden = true;
        cancelImportBtn.addEventListener("click", () => {
          clearPendingImport();
        });
      }

      autoAdvanceToggle.addEventListener("change", () => {
        state.settings.autoAdvance = autoAdvanceToggle.checked;
        logDebug(`Auto-advance ${autoAdvanceToggle.checked ? "enabled" : "disabled"}`);
        scheduleAutosave("settings-auto-advance");
      });

      hintFlashToggle.addEventListener("change", () => {
        state.settings.animateHints = hintFlashToggle.checked;
        if (!hintFlashToggle.checked) {
          clearOverlayAnimations();
        }
        syncHintTypeToggles();
        logDebug(`Hint animations ${hintFlashToggle.checked ? "enabled" : "disabled"}`);
        scheduleAutosave("settings-hint-animations");
      });

      if (hintMatchingToggle) {
        hintMatchingToggle.addEventListener("change", () => {
          const next = normalizeHintTypes(
            { ...state.settings.hintTypes, matchingRegions: hintMatchingToggle.checked },
            state.settings.hintTypes
          );
          state.settings.hintTypes = next;
          if (!next.matchingRegions) {
            clearOverlayAnimations();
          } else if (state.settings.animateHints && state.activeColor != null) {
            flashColorRegions(state.activeColor);
          }
          logDebug(`Matching colour hints ${next.matchingRegions ? "enabled" : "disabled"}`);
          scheduleAutosave("settings-hint-matching");
        });
      }

      if (hintHoverToggle) {
        hintHoverToggle.addEventListener("change", () => {
          const next = normalizeHintTypes(
            { ...state.settings.hintTypes, hoverRegions: hintHoverToggle.checked },
            state.settings.hintTypes
          );
          state.settings.hintTypes = next;
          if (!next.hoverRegions) {
            clearOverlayAnimations();
          }
          logDebug(`Hover hints ${next.hoverRegions ? "enabled" : "disabled"}`);
          scheduleAutosave("settings-hint-hover");
        });
      }

      if (difficultySelect) {
        difficultySelect.value = resolveDifficulty(difficultySelect.value);
        difficultySelect.addEventListener("change", () => {
          const difficulty = resolveDifficulty(difficultySelect.value);
          state.settings.difficulty = difficulty;
          difficultySelect.value = difficulty;
          logDebug(
            difficulty === "easy"
              ? "Difficulty set to Easy – clicks auto-select matching colours"
              : "Difficulty set to Standard – clicks require the active colour"
          );
          scheduleAutosave("settings-difficulty");
        });
      }

      for (const button of MOUSE_BUTTON_KEYS) {
        const inputs = mouseControlInputs[button];
        if (!inputs) continue;
        if (inputs.click) {
          inputs.click.addEventListener("change", () => {
            setMouseControl(button, "click", inputs.click.value);
          });
        }
        if (inputs.drag) {
          inputs.drag.addEventListener("change", () => {
            setMouseControl(button, "drag", inputs.drag.value);
          });
        }
      }

      if (hintFadeDurationInput) {
        hintFadeDurationInput.value = String(normalizeHintFadeDuration(hintFadeDurationInput.value));
        hintFadeDurationInput.addEventListener("input", () => {
          state.settings.hintFadeDuration = normalizeHintFadeDuration(hintFadeDurationInput.value);
          updateOptionOutputs();
        });
        hintFadeDurationInput.addEventListener("change", () => {
          const duration = normalizeHintFadeDuration(hintFadeDurationInput.value);
          state.settings.hintFadeDuration = duration;
          hintFadeDurationInput.value = String(duration);
          updateOptionOutputs();
          logDebug(`Hint fade set to ${(duration / 1000).toFixed(1)}s`);
          scheduleAutosave("settings-hint-fade");
        });
      }

      if (hintIntensityInput) {
        hintIntensityInput.value = String(Math.round(normalizeHintIntensity(hintIntensityInput.value) * 100));
        hintIntensityInput.addEventListener("input", () => {
          state.settings.hintIntensity = normalizeHintIntensity(hintIntensityInput.value);
          updateOptionOutputs();
        });
        hintIntensityInput.addEventListener("change", () => {
          const intensity = normalizeHintIntensity(hintIntensityInput.value);
          state.settings.hintIntensity = intensity;
          hintIntensityInput.value = String(Math.round(intensity * 100));
          updateOptionOutputs();
          logDebug(`Hint intensity set to ${Math.round(intensity * 100)}%`);
          scheduleAutosave("settings-hint-intensity");
        });
      }

      if (showRegionLabelsToggle) {
        showRegionLabelsToggle.addEventListener("change", () => {
          applyRegionLabelVisibility(showRegionLabelsToggle.checked);
        });
      }

      if (uiThemeSelect) {
        uiThemeSelect.value = state.settings.theme || DEFAULT_UI_THEME;
        uiThemeSelect.addEventListener("change", (event) => {
          applyTheme(event.target.value);
        });
      }

      if (rendererModeSelect) {
        rendererModeSelect.value = state.settings.renderer || "canvas2d";
        rendererModeSelect.addEventListener("change", (event) => {
          const requested = event.target.value;
          const resolved = applyRendererMode(requested);
          if (resolved && resolved !== requested) {
            rendererModeSelect.value = resolved;
          }
        });
      }

      if (backgroundColorInput) {
        backgroundColorInput.addEventListener("input", (event) => {
          applyBackgroundColor(event.target.value, { skipLog: true, skipAutosave: true });
        });
        backgroundColorInput.addEventListener("change", (event) => {
          applyBackgroundColor(event.target.value);
        });
      }

      if (stageBackgroundColorInput) {
        stageBackgroundColorInput.addEventListener("input", (event) => {
          applyStageBackgroundColor(event.target.value, { skipLog: true, skipAutosave: true });
        });
        stageBackgroundColorInput.addEventListener("change", (event) => {
          applyStageBackgroundColor(event.target.value);
        });
      }

      if (uiScaleInput) {
        uiScaleInput.addEventListener("input", (event) => {
          applyUiScale(event.target.value, { skipLog: true, skipAutosave: true });
        });
        uiScaleInput.addEventListener("change", (event) => {
          applyUiScale(event.target.value);
        });
      }

      if (labelScaleInput) {
        labelScaleInput.addEventListener("input", (event) => {
          applyLabelScale(event.target.value, { skipLog: true, skipAutosave: true });
        });
        labelScaleInput.addEventListener("change", (event) => {
          applyLabelScale(event.target.value);
        });
      }

      if (artPromptInput) {
        artPromptInput.addEventListener("input", (event) => {
          applyArtPrompt(event.target.value, { skipLog: true, skipAutosave: true });
        });
        artPromptInput.addEventListener("change", (event) => {
          applyArtPrompt(event.target.value);
        });
      }
      if (imageDescriptionInput) {
        imageDescriptionInput.addEventListener("input", (event) => {
          applyImageDescription(event.target.value, { skipLog: true, skipAutosave: true });
        });
        imageDescriptionInput.addEventListener("change", (event) => {
          applyImageDescription(event.target.value);
        });
      }

      if (paletteEl) {
        paletteEl.addEventListener("wheel", handlePaletteWheel, { passive: false });
      }

      previewToggle.addEventListener("click", () => {
        state.previewVisible = !state.previewVisible;
        updatePreviewState();
        logDebug(state.previewVisible ? "Showing preview" : "Hiding preview");
      });

      applyBtn.addEventListener("click", () => {
        if (applyBtn.disabled) return;
        logDebug("Regenerating puzzle with current generator settings");
        regenerateFromSource();
      });

      downloadBtn.addEventListener("click", () => {
        if (!state.puzzle) return;
        const payload = serializeCurrentPuzzle();
        const blob = new Blob([JSON.stringify(payload, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = `${payload.title ?? "color-by-number"}.json`;
        document.body.appendChild(link);
        link.click();
        requestAnimationFrame(() => {
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        });
        logDebug("Exported puzzle JSON");
      });

      for (const button of saveSnapshotButtons) {
        button.addEventListener("click", () => {
          if (!state.puzzle) return;
          saveCurrentSnapshot();
        });
      }

      for (const button of resetProgressButtons) {
        button.addEventListener("click", () => {
          if (!state.puzzle) return;
          if (state.filled.size === 0) return;
          const confirmed = window.confirm(
            "Reset progress on this puzzle? All filled regions will be cleared."
          );
          if (!confirmed) {
            return;
          }
          resetCurrentProgress();
        });
      }

      function handleSaveListClick(event) {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        const explicitId = target.getAttribute("data-target-id");
        let id = explicitId || null;
        if (!id) {
          const entryEl = target.closest("[data-save-id]");
          if (!entryEl) return;
          id = entryEl.getAttribute("data-save-id");
        }
        if (!id) return;
        if (target.dataset.action === "load") {
          loadSaveEntry(id);
        } else if (target.dataset.action === "delete") {
          deleteSaveEntry(id);
        } else if (target.dataset.action === "export") {
          exportSaveEntry(id);
        } else if (target.dataset.action === "rename") {
          renameSaveEntry(id);
        }
      }

      for (const list of saveListContainers) {
        list.addEventListener("click", handleSaveListClick);
      }

      colorCountEl.addEventListener("input", updateOptionOutputs);
      minRegionEl.addEventListener("input", updateOptionOutputs);
      detailEl.addEventListener("input", updateOptionOutputs);
      sampleRateEl.addEventListener("input", updateOptionOutputs);
      kmeansItersEl.addEventListener("input", updateOptionOutputs);
      smoothingEl.addEventListener("input", updateOptionOutputs);
      if (sourceImageLimitSelect) {
        sourceImageLimitSelect.addEventListener("change", () => {
          updateOptionOutputs();
          markOptionsDirty();
        });
      }

      colorCountEl.addEventListener("change", markOptionsDirty);
      minRegionEl.addEventListener("change", markOptionsDirty);
      detailEl.addEventListener("change", markOptionsDirty);
      if (algorithmEl) {
        algorithmEl.addEventListener("change", markOptionsDirty);
      }
      sampleRateEl.addEventListener("change", markOptionsDirty);
      kmeansItersEl.addEventListener("change", markOptionsDirty);
      smoothingEl.addEventListener("change", markOptionsDirty);

      function hasFiles(event) {
        const types = event.dataTransfer?.types;
        if (!types) return false;
        if (typeof types.includes === "function") {
          return types.includes("Files");
        }
        if (typeof types.contains === "function") {
          return types.contains("Files");
        }
        return Array.from(types).includes("Files");
      }

      let dragDepth = 0;
      window.addEventListener("dragenter", (event) => {
        if (!hasFiles(event)) return;
        dragDepth += 1;
        document.body.classList.add("dragging");
        event.preventDefault();
      });

      window.addEventListener("dragleave", (event) => {
        if (!hasFiles(event)) return;
        dragDepth = Math.max(0, dragDepth - 1);
        if (dragDepth === 0) {
          document.body.classList.remove("dragging");
        }
      });

      window.addEventListener("dragover", (event) => {
        if (!hasFiles(event)) return;
        event.preventDefault();
      });

      window.addEventListener("drop", (event) => {
        if (!hasFiles(event)) return;
        event.preventDefault();
        const file = event.dataTransfer?.files?.[0];
        dragDepth = 0;
        document.body.classList.remove("dragging");
        if (file) {
          prepareImport(file);
        }
      });

      // Viewport gesture wiring (mouse + pen):
      // - pointerdown delegates to handlePanStart so modifier / middle / right clicks immediately
      //   kick off panning while primary-button drags become "candidates" until they travel a few
      //   pixels. That keeps simple taps available for the canvas click handler below.
      // - pointermove promotes a stored candidate into a full pan session (capturing the pointer)
      //   once it travels ~4px, then continuously applies deltas via handlePanMove.
      // - pointerup/pointercancel tear down the session and restore the grab cursor. We also listen
      //   for lostpointercapture so releasing the mouse outside the stage still resets state.
      const pointerSurface = viewportEl || canvasStage || puzzleCanvas;
      if (pointerSurface) {
        const pointerOptions = { capture: true };
        pointerSurface.addEventListener("pointerdown", handlePanStart, pointerOptions);
        pointerSurface.addEventListener("pointermove", handlePanMove, pointerOptions);
        pointerSurface.addEventListener("pointerup", handlePanEnd, pointerOptions);
        pointerSurface.addEventListener("pointercancel", handlePanEnd, pointerOptions);
        pointerSurface.addEventListener("lostpointercapture", handlePanCaptureLost);
        pointerSurface.addEventListener("wheel", handleWheel, { passive: false });
        pointerSurface.addEventListener("contextmenu", (event) => event.preventDefault());
      }
      if (cursorOverlay && puzzleCanvas) {
        const handleCursorHover = (event) => updateCustomCursor(event);
        puzzleCanvas.addEventListener("pointermove", handleCursorHover);
        puzzleCanvas.addEventListener("pointerdown", handleCursorHover);
        puzzleCanvas.addEventListener("pointerenter", handleCursorHover);
        puzzleCanvas.addEventListener("pointerleave", hideCustomCursor);
        if (canvasStage) {
          canvasStage.addEventListener("pointerleave", hideCustomCursor);
        }
        if (viewportEl) {
          viewportEl.addEventListener("pointerleave", hideCustomCursor);
        }
        window.addEventListener(
          "scroll",
          () => {
            hideCustomCursor();
            invalidateCanvasRect();
          },
          { passive: true }
        );
      }

      const DOUBLE_TAP_WINDOW_MS = 320;
      const POINTER_CLICK_SUPPRESSION_MS = 360;
      const WHEEL_ZOOM_BASE = 1.25;
      const WHEEL_ZOOM_MAX_STEP = 8;
      const WHEEL_LINE_HEIGHT = 32;
      const WHEEL_PAGE_HEIGHT = 480;
      const REGION_HINT_HOVER_DELAY_MS = 280;
      const REGION_HINT_PRESS_DELAY_MS = 160;

      function getRegionAtPoint(clientX, clientY) {
        if (!state.puzzle || !puzzleCanvas) {
          return null;
        }
        if (typeof clientX !== "number" || typeof clientY !== "number") {
          return null;
        }
        const rect = getPuzzleCanvasRect();
        if (!rect || rect.width <= 0 || rect.height <= 0) {
          return null;
        }
        const scaleX = state.puzzle.width / rect.width;
        const scaleY = state.puzzle.height / rect.height;
        const x = Math.floor((clientX - rect.left) * scaleX);
        const y = Math.floor((clientY - rect.top) * scaleY);
        if (x < 0 || y < 0 || x >= state.puzzle.width || y >= state.puzzle.height) {
          return null;
        }
        const idx = y * state.puzzle.width + x;
        const regionId = state.puzzle.regionMap[idx];
        const region = state.puzzle.regions[regionId];
        if (!region) {
          return null;
        }
        return { regionId, region };
      }

      function getRegionFromEvent(event) {
        if (!event) return null;
        return getRegionAtPoint(event.clientX, event.clientY);
      }

      setupCustomCursorPreference();
      window.addEventListener("keydown", handleKeyDown, true);
      window.addEventListener("keyup", handleKeyUp, true);
      window.addEventListener("resize", () => handleViewportChange({ log: true }));
      if (window.visualViewport) {
        window.visualViewport.addEventListener("resize", () => handleViewportChange({ log: true }));
        window.visualViewport.addEventListener("scroll", () => handleViewportChange({ log: false }));
      }
      window.addEventListener("blur", () => {
        spacePressed = false;
        if (panPointerId != null) {
          if (
            panCaptureTarget &&
            panHasPointerCapture &&
            typeof panCaptureTarget.releasePointerCapture === "function"
          ) {
            try {
              panCaptureTarget.releasePointerCapture(panPointerId);
            } catch (error) {}
          }
        }
        panPointerId = null;
        panPointerType = null;
        panCandidate = null;
        panCaptureTarget = null;
        panHasPointerCapture = false;
        detachGlobalPanListeners();
        if (isPanning) {
          document.body.classList.remove("panning");
          isPanning = false;
        }
        hideCustomCursor();
        pointerSessions.clear();
      });

      if (window.screen?.orientation && typeof window.screen.orientation.addEventListener === "function") {
        window.screen.orientation.addEventListener("change", () =>
          handleViewportChange({ log: true, recenter: true })
        );
      } else if (window.matchMedia) {
        const orientationQuery = window.matchMedia("(orientation: portrait)");
        const orientationListener = () => handleViewportChange({ log: true, recenter: true });
        if (typeof orientationQuery.addEventListener === "function") {
          orientationQuery.addEventListener("change", orientationListener);
        } else if (typeof orientationQuery.addListener === "function") {
          orientationQuery.addListener(orientationListener);
        }
      }

      let suppressNextCanvasClickUntil = 0;
      let lastRegionHintId = null;
      let lastRegionHintTime = 0;

      function maybeShowRegionHint(region, paletteColor, options = {}) {
        if (!state.puzzle) return;
        if (state.previewVisible) return;
        if (!region) return;
        const { trigger = "hover", flashSwatch = false } = options;
        if (!isHintTypeEnabled("hoverRegions")) {
          if (flashSwatch) {
            flashPaletteSwatch(region.colorId, { hex: paletteColor?.hex });
          }
          return;
        }
        const now = Date.now();
        const delay = trigger === "press" ? REGION_HINT_PRESS_DELAY_MS : REGION_HINT_HOVER_DELAY_MS;
        if (lastRegionHintId === region.id && now - lastRegionHintTime < delay) {
          if (flashSwatch && !state.settings.animateHints) {
            flashPaletteSwatch(region.colorId, { hex: paletteColor?.hex });
          }
          return;
        }
        const remaining = getRegionsByColor(region.colorId, { includeFilled: false });
        const showOverlay = state.settings.animateHints !== false;
        if (showOverlay && remaining.length > 0) {
          flashRegion(region.id, { paletteColor, includeFilled: false });
          flashColorRegions(region.colorId, { paletteColor, onlyUnfilled: true });
          lastRegionHintId = region.id;
          lastRegionHintTime = now;
        } else {
          lastRegionHintId = region.id;
          lastRegionHintTime = now;
        }
        if (flashSwatch) {
          flashPaletteSwatch(region.colorId, { hex: paletteColor?.hex });
        }
      }

      function attemptFillRegion(hit, { label = "click" } = {}) {
        if (!state.puzzle) {
          logDebug(`Ignoring canvas ${label}: no puzzle loaded yet`);
          return "ignored";
        }
        if (state.activeColor == null) {
          logDebug(`Ignoring canvas ${label}: no active colour selected`);
          return "ignored";
        }
        if (!hit) {
          logDebug(`Ignoring canvas ${label}: no region mapped under pointer`);
          return "ignored";
        }
        const { region, regionId } = hit;
        if (state.filled.has(regionId)) {
          const remaining = getRegionsByColor(region.colorId, { includeFilled: false });
          if (remaining.length > 0) {
            const matchingHintsEnabled = isHintTypeEnabled("matchingRegions");
            if (matchingHintsEnabled) {
              flashColorRegions(region.colorId, {
                paletteColor: getPaletteEntry(region.colorId),
                onlyUnfilled: true,
              });
            }
            const regionWord = remaining.length === 1 ? "region" : "regions";
            logDebug(
              matchingHintsEnabled
                ? `Region ${region.id} already filled; flashing ${remaining.length} remaining ${regionWord} for ${describeColour(region.colorId, { includeCompleted: true })}`
                : `Region ${region.id} already filled; ${remaining.length} ${regionWord} still remain for ${describeColour(region.colorId, { includeCompleted: true })}`
            );
          } else {
            logDebug(`Region ${region.id} already filled; ignoring ${label}`);
          }
          return "already-filled";
        }
        if (region.colorId !== state.activeColor) {
          const difficulty = resolveDifficulty(state.settings.difficulty);
          if (difficulty === "easy") {
            activateColor(region.colorId, { flash: false });
          } else {
            const paletteColor = getPaletteEntry(region.colorId);
            const fallbackTint = paletteColor ? undefined : "rgba(250, 204, 21, 0.55)";
            if (state.settings.animateHints) {
              flashRegion(regionId, { paletteColor, tint: fallbackTint, includeFilled: false });
              if (isHintTypeEnabled("matchingRegions")) {
                flashColorRegions(region.colorId, {
                  paletteColor,
                  tint: fallbackTint,
                  onlyUnfilled: true,
                });
              }
            }
            flashPaletteSwatch(region.colorId, { hex: paletteColor?.hex });
            logDebug(
              `Region ${region.id} expects ${describeColour(region.colorId, { includeCompleted: true })}; active colour is ${describeColour(state.activeColor, { includeCompleted: true })}`
            );
            return "mismatch";
          }
        }
        if (region.colorId !== state.activeColor) {
          logDebug(
            `Region ${region.id} expects ${describeColour(region.colorId, { includeCompleted: true })}; active colour is ${describeColour(state.activeColor, { includeCompleted: true })}`
          );
          return "mismatch";
        }
        state.filled.add(regionId);
        paintRegionToFilledLayer(regionId);
        renderPuzzle();
        renderPalette();
        if (state.activeColor != null) {
          if (isHintTypeEnabled("matchingRegions")) {
            flashColorRegions(state.activeColor);
          }
        }
        updateProgress();
        updateCommandStates();
        scheduleAutosave("fill-region");
        logDebug(
          `Filled region ${region.id} with ${describeColour(region.colorId, { includeCompleted: true })} (${state.filled.size}/${state.puzzle.regions.length})`
        );
        if (state.settings.autoAdvance) {
          autoAdvanceColor(region.colorId);
        }
        refreshCustomCursorHighlight();
        return "filled";
      }

      // Puzzle fill interaction: click to paint if the region matches the active colour.
      puzzleCanvas.addEventListener("click", (event) => {
        const leftClickAction = getMouseControlsForButton("left").click;
        if (leftClickAction !== "fill") {
          return;
        }
        if (suppressNextCanvasClickUntil && Date.now() <= suppressNextCanvasClickUntil) {
          suppressNextCanvasClickUntil = 0;
          event.preventDefault?.();
          return;
        }
        attemptFillRegion(getRegionFromEvent(event), { label: "click" });
      });

      puzzleCanvas.addEventListener("dblclick", (event) => {
        if (!state.puzzle) {
          logDebug("Ignoring canvas double click: no puzzle loaded yet");
          return;
        }
        if (state.previewVisible) {
          logDebug("Ignoring canvas double click: preview mode active");
          return;
        }
        const now = Date.now();
        if (now - lastTouchSelectionTime <= 120) {
          event.preventDefault();
          return;
        }
        const hit = getRegionFromEvent(event);
        if (!hit) {
          logDebug("Ignoring canvas double click: no region mapped under pointer");
          return;
        }
        event.preventDefault();
        lastTouchSelectionTime = now;
        activateColor(hit.region.colorId);
      });

      puzzleCanvas.addEventListener("pointerdown", (event) => {
        const pointerType = event.pointerType;
        if (pointerType !== "touch" && pointerType !== "pen") {
          return;
        }
        if (!event.isPrimary) return;
        if (!state.puzzle || state.previewVisible) return;
        if (isPanning || pinchSession) return;
        const hit = getRegionFromEvent(event);
        if (!hit) return;
        const paletteColor = getPaletteEntry(hit.region.colorId);
        maybeShowRegionHint(hit.region, paletteColor, { trigger: "press", flashSwatch: true });
      });

      puzzleCanvas.addEventListener(
        "pointerup",
        (event) => {
          if (event.pointerType !== "touch") return;
          if (!event.isPrimary) return;
          if (!state.puzzle) return;
          if (state.previewVisible) return;
          if (isPanning) return;
          if (pinchSession) return;
          const hit = getRegionFromEvent(event);
          if (!hit) {
            lastTouchTapRegionId = null;
            return;
          }
          const now = Date.now();
          if (lastTouchTapRegionId === hit.regionId && now - lastTouchTapTime <= DOUBLE_TAP_WINDOW_MS) {
            event.preventDefault();
            suppressNextCanvasClickUntil = now + POINTER_CLICK_SUPPRESSION_MS;
            lastTouchTapTime = 0;
            lastTouchTapRegionId = null;
            lastTouchSelectionTime = now;
            activateColor(hit.region.colorId);
            return;
          }
          const result = attemptFillRegion(hit, { label: "tap" });
          if (result !== "ignored") {
            suppressNextCanvasClickUntil = now + POINTER_CLICK_SUPPRESSION_MS;
            event.preventDefault();
          }
          lastTouchTapTime = now;
          lastTouchTapRegionId = hit.regionId;
        },
        { passive: false }
      );

      async function ensureHelpReadmeLoaded() {
        if (!readmeContentEl) return;
        if (readmeLoadState === "loading" || readmeLoadState === "loaded") {
          return;
        }
        readmeLoadState = "loading";
        if (readmeStatusEl) {
          readmeStatusEl.hidden = false;
          readmeStatusEl.textContent = "Loading README…";
        }
        if (readmeErrorEl) {
          readmeErrorEl.hidden = true;
          readmeErrorEl.textContent = "";
        }
        readmeContentEl.hidden = true;
        readmeContentEl.innerHTML = "";
        readmeContentEl.classList.remove("readme-preview--plaintext");
        try {
          const response = await fetch(README_SOURCE_URL, { cache: "no-store" });
          if (!response || !response.ok) {
            throw new Error(`HTTP ${response ? response.status : "error"}`);
          }
          const contentType = response.headers?.get("content-type") || "";
          const raw = await response.text();
          if (contentType.includes("text/html")) {
            let html = raw;
            if (typeof DOMParser !== "undefined") {
              try {
                const parser = new DOMParser();
                const parsed = parser.parseFromString(raw, "text/html");
                const source = parsed.querySelector("main") || parsed.body;
                if (source) {
                  source.querySelectorAll("script").forEach((node) => node.remove());
                  source.querySelectorAll("a[href]").forEach((anchor) => {
                    const href = anchor.getAttribute("href");
                    if (!href) return;
                    if (!href.startsWith("#")) {
                      try {
                        const absolute = new URL(href, README_SOURCE_URL);
                        anchor.setAttribute("href", absolute.toString());
                      } catch (_) {
                        // Ignore malformed URLs.
                      }
                    }
                    anchor.setAttribute("target", "_blank");
                    anchor.setAttribute("rel", "noreferrer noopener");
                  });
                  source.querySelectorAll("img[src]").forEach((img) => {
                    const src = img.getAttribute("src");
                    if (!src) return;
                    try {
                      const absolute = new URL(src, README_SOURCE_URL);
                      img.setAttribute("src", absolute.toString());
                    } catch (_) {
                      // Ignore malformed URLs.
                    }
                  });
                  html = source.innerHTML;
                }
              } catch (_) {
                // Fall back to the original HTML string if parsing fails.
              }
            }
            readmeContentEl.innerHTML = html;
            readmeContentEl.classList.remove("readme-preview--plaintext");
          } else {
            const trimmed = raw.trim();
            readmeContentEl.textContent = trimmed.length > 0 ? trimmed : raw;
            readmeContentEl.classList.add("readme-preview--plaintext");
          }
          readmeContentEl.hidden = false;
          if (readmeStatusEl) {
            readmeStatusEl.hidden = true;
          }
          readmeLoadState = "loaded";
        } catch (error) {
          readmeLoadState = "error";
          if (readmeStatusEl) {
            readmeStatusEl.hidden = true;
          }
          if (readmeErrorEl) {
            const message = error && error.message ? error.message : "unknown error";
            readmeErrorEl.hidden = false;
            readmeErrorEl.textContent = `Couldn't load the README (${message}). Reopen this panel to try again.`;
          }
        }
      }

      function openSheet(sheet) {
        if (!sheet) return;
        for (const candidate of sheetRegistry) {
          if (!candidate || candidate === sheet) continue;
          candidate.classList.add("hidden");
          candidate.setAttribute("aria-hidden", "true");
        }
        sheet.classList.remove("hidden");
        sheet.setAttribute("aria-hidden", "false");
        if (sheet === helpSheet) {
          void ensureHelpReadmeLoaded();
        } else if (sheet === generatorSheet) {
          requestAnimationFrame(() => {
            if (!generatorUrlInput) {
              return;
            }
            if (
              (!generatorUrlInput.value || generatorUrlInput.value.trim().length === 0) &&
              state.sourceUrl &&
              !isProbablyDataUrl(state.sourceUrl)
            ) {
              generatorUrlInput.value = state.sourceUrl;
            }
            clearSourceUrlError();
            updateSourceUrlSubmitState();
            generatorUrlInput.focus();
            if (typeof generatorUrlInput.select === "function") {
              generatorUrlInput.select();
            }
          });
        }
      }

      function closeSheet(sheet) {
        if (!sheet) return;
        sheet.classList.add("hidden");
        sheet.setAttribute("aria-hidden", "true");
        if (sheet === generatorSheet) {
          clearPendingImport();
        }
      }

      function showStartScreen(options = {}) {
        if (!startHint) return;
        for (const sheet of sheetRegistry) {
          closeSheet(sheet);
        }
        startHint.classList.remove("hidden");
        startHint.setAttribute("aria-hidden", "false");
        const { focus = true, scrollTo } = options;
        if (focus) {
          requestAnimationFrame(() => {
            if (document.activeElement !== startHint) {
              startHint.focus();
            }
          });
        }
        if (scrollTo === "saves" && startSaveManagerSection) {
          requestAnimationFrame(() => {
            startSaveManagerSection.scrollIntoView({ block: "start" });
          });
        }
      }

      function hideStartScreen() {
        if (!startHint) return;
        startHint.classList.add("hidden");
        startHint.setAttribute("aria-hidden", "true");
      }

      function updatePreviewState() {
        if (!previewToggle) return;
        if (!state.puzzle) {
          state.previewVisible = false;
        }
        if (state.previewVisible && state.puzzle) {
          previewToggle.setAttribute("aria-pressed", "true");
          previewToggle.setAttribute("aria-label", "Hide preview");
          previewToggle.title = "Hide preview";
          previewToggle.classList.add("active");
          hideCustomCursor();
        } else {
          previewToggle.setAttribute("aria-pressed", "false");
          previewToggle.setAttribute("aria-label", "Show preview");
          previewToggle.title = "Show preview";
          previewToggle.classList.remove("active");
          refreshCustomCursorHighlight();
        }
        renderPuzzle();
      }

      function updateFullscreenState() {
        if (!fullscreenButton) return;
        const active = Boolean(document.fullscreenElement);
        fullscreenButton.classList.toggle("active", active);
        fullscreenButton.setAttribute("aria-pressed", active ? "true" : "false");
        fullscreenButton.setAttribute("aria-label", active ? "Exit fullscreen" : "Enter fullscreen");
        fullscreenButton.title = active ? "Exit fullscreen" : "Enter fullscreen";
        const icon = fullscreenButton.querySelector(".icon");
        if (icon) {
          icon.textContent = active ? "🗗" : "⛶";
        }
        fullscreenButton.disabled = !document.fullscreenEnabled && !active;
      }

      function toggleFullscreen() {
        if (!fullscreenButton) return;
        if (document.fullscreenElement) {
          if (document.exitFullscreen) {
            document.exitFullscreen().catch((error) => {
              console.error("Failed to exit fullscreen", error);
              logDebug("Unable to exit fullscreen");
            });
          }
          return;
        }
        const target = appEl || document.documentElement;
        if (!document.fullscreenEnabled || !target?.requestFullscreen) {
          logDebug("Fullscreen not supported in this browser");
          return;
        }
        target.requestFullscreen().catch((error) => {
          console.error("Failed to enter fullscreen", error);
          logDebug("Fullscreen request was blocked");
        });
      }

      function syncComputedUiScale() {
        const root = document.documentElement;
        const userValue =
          typeof state?.settings?.uiScale === "number"
            ? state.settings.uiScale
            : DEFAULT_UI_SCALE;
        if (!root) {
          return userValue;
        }
        let autoValue = 1;
        if (typeof window !== "undefined" && window.getComputedStyle) {
          const styles = getComputedStyle(root);
          const parsed = Number.parseFloat(styles.getPropertyValue("--ui-scale-auto"));
          if (Number.isFinite(parsed)) {
            autoValue = parsed;
          }
        } else {
          const inlineAuto = Number.parseFloat(root.style.getPropertyValue("--ui-scale-auto"));
          if (Number.isFinite(inlineAuto)) {
            autoValue = inlineAuto;
          }
        }
        const combined = clamp(userValue * autoValue, 0.35, 1.8);
        root.style.setProperty("--ui-scale", combined.toFixed(4));
        invalidateCanvasRect();
        return combined;
      }

      function updateViewportMetrics() {
        const viewport = window.visualViewport;
        const visualWidth = Math.round(
          viewport?.width || window.innerWidth || document.documentElement.clientWidth || 0
        );
        const visualHeight = Math.round(
          viewport?.height || window.innerHeight || document.documentElement.clientHeight || 0
        );
        const orientation = visualWidth >= visualHeight ? "landscape" : "portrait";
        document.documentElement.style.setProperty("--app-width", `${visualWidth}px`);
        document.documentElement.style.setProperty("--app-height", `${visualHeight}px`);
        if (appEl) {
          appEl.style.width = `${visualWidth}px`;
          appEl.style.height = `${visualHeight}px`;
        }
        const minSide = Math.max(1, Math.min(visualWidth, visualHeight));
        const padding = orientation === "portrait" ? Math.min(28, Math.max(16, Math.round(minSide * 0.06))) : 32;
        document.documentElement.style.setProperty("--viewport-padding", `${padding}px`);
        const autoScale = clamp(minSide / 880, 0.6, 1.1);
        document.documentElement.style.setProperty("--ui-scale-auto", autoScale.toFixed(3));
        if (document.body) {
          document.body.dataset.orientation = orientation;
          const compact = visualWidth < 720 || visualHeight < 540;
          document.body.classList.toggle("compact-commands", compact);
        }
        syncComputedUiScale();
        scheduleCommandRailMetricsSync();
        const changed = orientation !== lastViewportMetrics.orientation;
        const sizeChanged =
          visualWidth !== lastViewportMetrics.width || visualHeight !== lastViewportMetrics.height;
        lastViewportMetrics = { orientation, width: visualWidth, height: visualHeight };
        return { orientation, changed, sizeChanged, width: visualWidth, height: visualHeight };
      }

      function handleViewportChange(options = {}) {
        const { log = false, recenter = false } = options;
        const metrics = updateViewportMetrics();
        const orientationChanged = metrics.changed;
        if (orientationChanged) {
          logDebug(`Orientation changed to ${metrics.orientation}`);
        } else if (log && metrics.sizeChanged) {
          logDebug(`Viewport resized to ${metrics.width}×${metrics.height} (${metrics.orientation})`);
        }
        if (state.puzzle) {
          resetView({ preserveZoom: true, recenter: recenter || orientationChanged });
        }
        hideCustomCursor();
      }

      function applySampleDetailLevel(level, options = {}) {
        const { skipReload = false, skipLog = false, skipOptions = false } = options;
        const normalized = level && SAMPLE_DETAIL_LEVELS[level] ? level : DEFAULT_SAMPLE_DETAIL;
        const config = SAMPLE_DETAIL_LEVELS[normalized];
        if (!config) return null;
        const previousLevel = state.sampleDetailLevel;
        state.sampleDetailLevel = config.id;
        const sampleTitle = getSampleTitle();
        const sampleDescription = getSampleDescription();
        const sampleDataUrl = getSampleDataUrl();
        const sampleAvailable = Boolean(sampleDataUrl);
        const canReloadSample = sampleAvailable || Boolean(DEFAULT_GAME_SOURCE?.path);
        const reloadLabel = sampleTitle ? `Reload ${sampleTitle}` : "Reload sample puzzle";

        for (const button of sampleDetailButtons) {
          if (!button) continue;
          const targetLevel = button.dataset.detailLevel;
          const targetConfig = SAMPLE_DETAIL_LEVELS[targetLevel];
          if (targetConfig) {
            button.textContent = targetConfig.shortLabel;
            button.setAttribute("aria-label", targetConfig.ariaLabel);
            button.title = targetConfig.ariaLabel;
          }
          const isActive = targetLevel === config.id;
          button.setAttribute("aria-pressed", isActive ? "true" : "false");
        }
        for (const caption of sampleDetailCaptions) {
          if (caption) {
            caption.textContent = config.summary;
          }
        }
        for (const button of sampleButtons) {
          if (!button) continue;
          const detailSummary = config.summary || config.label;
          const defaultLabel = `${reloadLabel} – ${config.label}`;
          const titleText = detailSummary ? `${reloadLabel} – ${detailSummary}` : defaultLabel;
          const ariaText = detailSummary
            ? `${reloadLabel} (${detailSummary})`
            : `${reloadLabel} (${config.label})`;
          button.title = titleText;
          button.setAttribute("aria-label", ariaText);
          button.disabled = !canReloadSample;
          if (config.approxRegions != null) {
            button.dataset.detailRegions = String(config.approxRegions);
          } else {
            delete button.dataset.detailRegions;
          }
        }
        if (samplePreview) {
          const previewSummary = config.summary || config.label;
          const previewTitle = sampleTitle || "Sample puzzle";
          if (sampleAvailable) {
            samplePreview.src = sampleDataUrl;
            samplePreview.alt = sampleDescription || previewTitle;
          } else {
            samplePreview.removeAttribute("src");
            samplePreview.alt = "";
          }
          samplePreview.title = previewSummary
            ? `${previewTitle} – ${previewSummary}`
            : `${previewTitle} – ${config.label}`;
          if (config.approxRegions != null) {
            samplePreview.dataset.detailRegions = String(config.approxRegions);
          } else {
            delete samplePreview.dataset.detailRegions;
          }
        }
        if (!skipOptions) {
          const settings = config.settings || {};
          if (colorCountEl && typeof settings.targetColors === "number") {
            colorCountEl.value = String(settings.targetColors);
          }
          if (minRegionEl && typeof settings.minRegion === "number") {
            minRegionEl.value = String(settings.minRegion);
          }
          if (detailEl && typeof settings.maxSize === "number") {
            detailEl.value = String(settings.maxSize);
          }
          if (sampleRateEl && typeof settings.sampleRate === "number") {
            sampleRateEl.value = String(settings.sampleRate);
          }
          if (kmeansItersEl && typeof settings.kmeansIters === "number") {
            kmeansItersEl.value = String(settings.kmeansIters);
          }
          if (smoothingEl && typeof settings.smoothingPasses === "number") {
            smoothingEl.value = String(settings.smoothingPasses);
          }
          if (algorithmEl && typeof settings.algorithm === "string") {
            const normalizedAlgorithm = normalizeGenerationAlgorithm(settings.algorithm);
            if (algorithmEl.value !== normalizedAlgorithm) {
              algorithmEl.value = normalizedAlgorithm;
            }
          } else if (algorithmEl && !settings.algorithm) {
            if (algorithmEl.value !== DEFAULT_GENERATION_ALGORITHM) {
              algorithmEl.value = DEFAULT_GENERATION_ALGORITHM;
            }
          }
          if (sourceImageLimitSelect) {
            if (typeof settings.sourceImageMaxBytes === "number") {
              const limitValue = resolveSourceImageLimit(settings.sourceImageMaxBytes);
              const limitText = String(limitValue);
              if (sourceImageLimitSelect.value !== limitText) {
                sourceImageLimitSelect.value = limitText;
              }
            } else {
              const defaultLimit = String(DEFAULT_SOURCE_IMAGE_MAX_BYTES);
              if (sourceImageLimitSelect.value !== defaultLimit) {
                sourceImageLimitSelect.value = defaultLimit;
              }
            }
          }
          updateOptionOutputs();
          markOptionsDirty();
        }
        if (!skipLog && previousLevel !== config.id) {
          logDebug(`Sample detail set to ${config.label} – ${config.summary}`);
        }
        if (!skipReload && sampleAvailable && state.sourceUrl === sampleDataUrl) {
          loadSamplePuzzle({ detailLevel: config.id, skipDetailUpdate: true });
        }
        return config;
      }

      function loadSamplePuzzle(options = {}) {
        const { announce = true, detailLevel, skipDetailUpdate = false } = options;
        disableSampleAutoload();
        const targetLevel = detailLevel || state.sampleDetailLevel || DEFAULT_SAMPLE_DETAIL;
        const detailConfig = skipDetailUpdate
          ? SAMPLE_DETAIL_LEVELS[targetLevel] || SAMPLE_DETAIL_LEVELS[DEFAULT_SAMPLE_DETAIL]
          : applySampleDetailLevel(targetLevel, { skipReload: true, skipLog: !announce }) ||
            SAMPLE_DETAIL_LEVELS[targetLevel] ||
            SAMPLE_DETAIL_LEVELS[DEFAULT_SAMPLE_DETAIL];
        const dataUrl = getSampleDataUrl();
        if (!dataUrl) {
          return loadDefaultPuzzle({ announce });
        }
        const sampleTitle = getSampleTitle();
        resetPuzzleUI();
        state.sourceUrl = dataUrl;
        state.sourceTitle = sampleTitle || "Sample puzzle";
        hideStartScreen();
        const label = detailConfig ? detailConfig.label : null;
        const logDescriptor = detailConfig?.logDescriptor || (label ? label.toLowerCase() : null);
        const loadOptions = announce
          ? {
              logMessage: logDescriptor
                ? `Loading ${logDescriptor} sample puzzle: ${state.sourceTitle}`
                : `Loading sample puzzle: ${state.sourceTitle}`,
              completionMessage: label
                ? `${label} sample puzzle ready: ${state.sourceTitle}`
                : `Loading sample puzzle complete: ${state.sourceTitle}`,
              skipDefaultLog: true,
            }
          : undefined;
        loadImage(dataUrl, loadOptions);
      }

      async function loadDefaultPuzzle(options = {}) {
        const { announce = true, forceRefresh = false } = options;
        disableSampleAutoload();
        resetPuzzleUI();
        try {
          const { payload, resolvedTitle, resolvedDescription } = await fetchDefaultGamePayload({
            forceRefresh,
          });
          const descriptorTitle = resolvedTitle || getDefaultGameTitle();
          const descriptor = resolvedDescription
            ? `${descriptorTitle} – ${resolvedDescription}`
            : descriptorTitle;
          if (announce) {
            logDebug(`Loading ${descriptor}`);
          }
          const applied = applyPuzzleResult(payload, {
            options: payload.options || getCurrentOptions(),
            activeColor: payload.activeColor,
            backgroundColor: payload.backgroundColor,
            stageBackgroundColor: payload.stageBackgroundColor,
            viewport: payload.viewport,
            settings: payload.settings,
            title: descriptorTitle || DEFAULT_GAME_SOURCE.path || "Puzzle",
            skipDefaultLog: !announce,
          });
          if (applied) {
            state.sourceUrl = DEFAULT_GAME_SOURCE.path;
            state.sourceTitle = descriptorTitle || DEFAULT_GAME_SOURCE.path || "Puzzle";
            hideStartScreen();
            setProgressMessage("active");
            if (!announce) {
              logDebug(`Loaded ${state.sourceTitle} from ${DEFAULT_GAME_SOURCE.path}`);
            }
            return true;
          }
        } catch (error) {
          console.error("Failed to load default puzzle", error);
          logDebug(`Unable to load ${DEFAULT_GAME_SOURCE.path}. Check the console for details.`);
        }
        setProgressMessage("idle");
        return false;
      }

      function updateCommandStates() {
        const hasPuzzle = Boolean(state.puzzle);
        previewToggle.disabled = !hasPuzzle;
        downloadBtn.disabled = !hasPuzzle;
        for (const button of saveSnapshotButtons) {
          button.disabled = !hasPuzzle;
        }
        for (const button of resetProgressButtons) {
          button.disabled = !hasPuzzle || state.filled.size === 0;
        }
        if (saveManagerButton) {
          saveManagerButton.disabled = false;
        }
        if (startHintCloseButton) {
          startHintCloseButton.hidden = !hasPuzzle && state.saves.length === 0;
        }
      }

      function renderDebugLog() {
        if (!debugLogEl) return;
        debugLogEl.innerHTML = "";
        if (debugLogEntries.length === 0) {
          const empty = document.createElement("p");
          empty.className = "log-empty";
          empty.textContent = "No events yet.";
          debugLogEl.appendChild(empty);
          return;
        }
        const fragment = document.createDocumentFragment();
        for (let index = debugLogEntries.length - 1; index >= 0; index -= 1) {
          const entry = debugLogEntries[index];
          const item = document.createElement("div");
          item.className = "log-entry";
          const time = document.createElement("time");
          time.dateTime = entry.iso;
          time.textContent = entry.display;
          const message = document.createElement("span");
          message.textContent = entry.message;
          item.appendChild(time);
          item.appendChild(message);
          fragment.appendChild(item);
        }
        debugLogEl.appendChild(fragment);
        debugLogEl.scrollTop = 0;
      }

      function logDebug(message) {
        if (message == null) return;
        const now = new Date();
        const entry = {
          iso: now.toISOString(),
          display: now.toLocaleTimeString([], {
            hour12: false,
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
          }),
          message: String(message),
        };
        debugLogEntries.push(entry);
        if (debugLogEntries.length > DEBUG_LOG_LIMIT) {
          debugLogEntries.splice(0, debugLogEntries.length - DEBUG_LOG_LIMIT);
        }
        renderDebugLog();
      }

      function activateSettingsTab(tabId, options = {}) {
        if (!tabId || settingsTabButtons.length === 0) {
          return null;
        }
        const { focusTab = false, force = false, resetScroll = false } = options;
        const button = settingsTabButtons.find(
          (candidate) => candidate?.dataset.settingsTab === tabId
        );
        const panel = settingsPanels.find((candidate) => candidate?.dataset.settingsPanel === tabId);
        if (!button || !panel) {
          return null;
        }
        const previousTabId = activeSettingsTabId;
        const changed = previousTabId !== tabId;
        if (!force && !changed) {
          if (resetScroll && settingsBody) {
            settingsBody.scrollTop = 0;
          }
          if (focusTab) {
            button.focus();
          }
          return tabId;
        }
        activeSettingsTabId = tabId;
        for (const candidate of settingsTabButtons) {
          const selected = candidate === button;
          candidate.setAttribute("aria-selected", selected ? "true" : "false");
          candidate.setAttribute("tabindex", selected ? "0" : "-1");
        }
        for (const candidate of settingsPanels) {
          const isTarget = candidate === panel;
          candidate.hidden = !isTarget;
          candidate.setAttribute("aria-hidden", isTarget ? "false" : "true");
        }
        if (settingsBody && (resetScroll || changed)) {
          settingsBody.scrollTop = 0;
        }
        if (focusTab) {
          button.focus();
        }
        return tabId;
      }

      function focusSettingsTab(index, options = {}) {
        if (settingsTabButtons.length === 0) {
          return null;
        }
        const length = settingsTabButtons.length;
        const normalized = ((index % length) + length) % length;
        const button = settingsTabButtons[normalized];
        if (!button) {
          return null;
        }
        const tabId = button.dataset.settingsTab;
        if (tabId) {
          activateSettingsTab(tabId, {
            focusTab: true,
            resetScroll: options.resetScroll ?? true,
            force: options.force ?? false,
          });
        }
        return tabId;
      }

      function focusSettingsTabRelative(currentIndex, delta, options = {}) {
        if (settingsTabButtons.length === 0) {
          return null;
        }
        return focusSettingsTab(currentIndex + delta, options);
      }

      function applyUiScale(scale, options = {}) {
        const { skipLog = false, skipAutosave = false, force = false } = options;
        const numeric = Number(scale);
        const fallbackScale =
          Number.isFinite(state.settings.uiScale) && state.settings.uiScale > 0
            ? state.settings.uiScale
            : DEFAULT_UI_SCALE;
        const resolved = clamp(
          Number.isFinite(numeric) && numeric > 0 ? numeric : fallbackScale,
          0.2,
          3
        );
        const current = fallbackScale;
        const changed = force || Math.abs(resolved - current) > 0.001;
        state.settings.uiScale = resolved;
        document.documentElement.style.setProperty("--ui-scale-user", String(resolved));
        syncComputedUiScale();
        scheduleCommandRailMetricsSync();
        if (uiScaleInput && Math.abs(Number(uiScaleInput.value) - resolved) > 0.001) {
          uiScaleInput.value = String(resolved);
        }
        updateOptionOutputs();
        if (changed && !skipLog) {
          logDebug(`Interface scale set to ${Math.round(resolved * 100)}%`);
        }
        if (!changed) {
          return resolved;
        }
        if (!skipAutosave) {
          scheduleAutosave("settings-ui-scale");
        } else {
          scheduleSettingsPersist();
        }
        return resolved;
      }

      function applyLabelScale(scale, options = {}) {
        const { skipLog = false, skipAutosave = false, skipRender = false, force = false } = options;
        const numeric = Number(scale);
        const fallbackScale =
          Number.isFinite(state.settings.labelScale) && state.settings.labelScale > 0
            ? state.settings.labelScale
            : DEFAULT_LABEL_SCALE;
        const resolved = clamp(
          Number.isFinite(numeric) && numeric > 0 ? numeric : fallbackScale,
          0.2,
          2
        );
        const current = fallbackScale;
        const changed = force || Math.abs(resolved - current) > 0.001;
        state.settings.labelScale = resolved;
        if (labelScaleInput && Math.abs(Number(labelScaleInput.value) - resolved) > 0.001) {
          labelScaleInput.value = String(resolved);
        }
        updateOptionOutputs();
        if (changed && !skipRender) {
          renderPuzzle();
        }
        if (changed && !skipLog) {
          logDebug(`Label size set to ${Math.round(resolved * 100)}%`);
        }
        if (changed && !skipAutosave) {
          scheduleAutosave("settings-label-scale");
        }
        return resolved;
      }

      function updateChatGptLink(description) {
        if (!chatGptLink) {
          return;
        }
        const trimmed = typeof description === "string" ? description.trim() : "";
        const prompt = trimmed
          ? `You help craft vivid prompts for image generators. Based on the description below, write a polished prompt ready for DALLE or similar tools.\n\nDescription:\n${trimmed}\n\nReturn only the improved prompt.`
          : "You help craft vivid prompts for image generators. Suggest a playful capybara-themed scene prompt suitable for DALLE or similar tools.";
        const params = new URLSearchParams({ q: prompt });
        chatGptLink.href = `https://chat.openai.com/?${params.toString()}`;
      }

      function applyImageDescription(text, options = {}) {
        const { skipLog = false, skipAutosave = false } = options;
        const normalized = typeof text === "string" ? text : "";
        const previous = state.settings.imageDescription ?? "";
        state.settings.imageDescription = normalized;
        if (imageDescriptionInput && imageDescriptionInput.value !== normalized) {
          imageDescriptionInput.value = normalized;
        }
        updateChatGptLink(normalized);
        if (normalized !== previous) {
          if (!skipLog) {
            const trimmed = normalized.trim();
            logDebug(
              trimmed
                ? `Image description updated (${trimmed.length} characters)`
                : "Image description cleared"
            );
          }
          if (!skipAutosave) {
            scheduleAutosave("settings-image-description");
          }
        }
        return normalized;
      }

      function applyArtPrompt(text, options = {}) {
        const { skipLog = false, skipAutosave = false } = options;
        const normalized = typeof text === "string" ? text : "";
        const previous = state.settings.artPrompt ?? "";
        state.settings.artPrompt = normalized;
        if (artPromptInput && artPromptInput.value !== normalized) {
          artPromptInput.value = normalized;
        }
        if (normalized !== previous) {
          if (!skipLog) {
            const trimmed = normalized.trim();
            logDebug(trimmed ? `Art prompt updated (${trimmed.length} characters)` : "Art prompt cleared");
          }
          if (!skipAutosave) {
            scheduleAutosave("settings-art-prompt");
          }
        }
        return normalized;
      }

      function applyRegionLabelVisibility(_visible, options = {}) {
        const { skipLog = false, skipAutosave = false, forceRender = false, skipRender = false } = options;
        const previous = state.settings.showRegionLabels !== false;
        const visible = _visible !== false;
        state.settings.showRegionLabels = visible;
        if (showRegionLabelsToggle && showRegionLabelsToggle.checked !== visible) {
          showRegionLabelsToggle.checked = visible;
        }
        if (!skipRender && (forceRender || previous !== visible)) {
          renderPuzzle();
        }
        if (previous !== visible) {
          if (!skipLog) {
            logDebug(visible ? "Region numbers shown" : "Region numbers hidden");
          }
          if (!skipAutosave) {
            scheduleAutosave("settings-region-labels");
          }
        }
        return visible;
      }

      function applyTheme(theme, options = {}) {
        const { skipLog = false, skipAutosave = false, force = false } = options;
        const requested = typeof theme === "string" ? theme.trim().toLowerCase() : "";
        const current = state.settings.theme || DEFAULT_UI_THEME;
        const resolved = VALID_UI_THEMES.has(requested) ? requested : current || DEFAULT_UI_THEME;
        const changed = force || resolved !== current;
        state.settings.theme = resolved;
        if (typeof document !== "undefined" && document.body) {
          document.body.setAttribute("data-theme", resolved);
        }
        if (uiThemeSelect && uiThemeSelect.value !== resolved) {
          uiThemeSelect.value = resolved;
        }
        if (changed && !skipLog) {
          const label = resolved === "colorful"
            ? "Colourful"
            : resolved.charAt(0).toUpperCase() + resolved.slice(1);
          logDebug(`Interface theme set to ${label}`);
        }
        if (changed && !skipAutosave) {
          scheduleAutosave("settings-theme");
        }
        return resolved;
      }

      function applyBackgroundColor(hex, options = {}) {
        const { skipRender = false, skipLog = false, force = false } = options;
        const current = state.settings.backgroundColor ?? DEFAULT_BACKGROUND_HEX;
        const normalized = sanitizeHexColor(hex, current);
        const changed = force || normalized !== current;
        state.settings.backgroundColor = normalized;
        backgroundInk = computeInkStyles(normalized);
        if (state.renderCache) {
          state.renderCache.strokeWidth = computeOutlineStrokeWidth(
            state.renderCache.width,
            state.renderCache.height,
            {
              displayScale: canvasMetrics.displayScale,
              pixelRatio: canvasMetrics.pixelRatio,
              deviceWidth: 1,
            }
          );
        }
        if (backgroundColorInput && backgroundColorInput.value !== normalized) {
          backgroundColorInput.value = normalized;
        }
        if (!changed) {
          return normalized;
        }
        markOutlineLayerDirty();
        markFilledLayerDirty();
        if (!skipRender) {
          if (state.puzzle) {
            renderPuzzle();
          } else {
            if (state.rendering?.controller) {
              state.rendering.controller.fillBackground({
                color: normalized,
                metrics: { ...canvasMetrics },
              });
            } else {
              const fallbackCtx = puzzleCanvas?.getContext?.("2d") || null;
              if (fallbackCtx) {
                fallbackCtx.save();
                fallbackCtx.setTransform(1, 0, 0, 1, 0, 0);
                fallbackCtx.fillStyle = normalized;
                const width = puzzleCanvas.width || canvasMetrics.pixelWidth || 0;
                const height = puzzleCanvas.height || canvasMetrics.pixelHeight || 0;
                fallbackCtx.fillRect(0, 0, width, height);
                fallbackCtx.restore();
              }
            }
          }
        }
        if (changed && !skipLog) {
          logDebug(`Unfilled region colour set to ${normalized.toUpperCase()}`);
        }
        if (changed && !options.skipAutosave) {
          scheduleAutosave("background-colour");
        }
        return normalized;
      }

      function applyStageBackgroundColor(hex, options = {}) {
        const { skipLog = false, skipAutosave = false, force = false } = options;
        const current = state.settings.stageBackgroundColor ?? DEFAULT_STAGE_BACKGROUND_HEX;
        const normalized = sanitizeHexColor(hex, current);
        const changed = force || normalized !== current;
        state.settings.stageBackgroundColor = normalized;
        if (
          stageBackgroundColorInput &&
          typeof stageBackgroundColorInput.value === "string" &&
          stageBackgroundColorInput.value !== normalized
        ) {
          stageBackgroundColorInput.value = normalized;
        }
        if (typeof document !== "undefined" && document.documentElement) {
          document.documentElement.style.setProperty("--stage-background", normalized);
        }
        if (changed && !skipLog) {
          logDebug(`Stage background set to ${normalized.toUpperCase()}`);
        }
        if (changed && !skipAutosave) {
          scheduleAutosave("stage-background-colour");
        }
        return normalized;
      }

      function resolveSourceImageLimit(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_SOURCE_IMAGE_MAX_BYTES;
        }
        if (numeric < 0) {
          return DEFAULT_SOURCE_IMAGE_MAX_BYTES;
        }
        if (numeric === 0) {
          return MAX_SOURCE_IMAGE_LIMIT;
        }
        return numeric;
      }

      function formatSourceImageLimitLabel(value) {
        const resolved = resolveSourceImageLimit(value);
        const matchedOption = SOURCE_IMAGE_LIMIT_OPTIONS.find(
          (option) => option && option.value === resolved
        );
        if (matchedOption) {
          return matchedOption.label;
        }
        return formatBytes(resolved);
      }

      function updateOptionOutputs() {
        if (generatorOutputs.colorCount) {
          generatorOutputs.colorCount.textContent = String(colorCountEl.value);
        }
        if (generatorOutputs.minRegion) {
          generatorOutputs.minRegion.textContent = `${minRegionEl.value} px²`;
        }
        if (generatorOutputs.detail) {
          generatorOutputs.detail.textContent = `${detailEl.value} px`;
        }
        if (generatorOutputs.sample) {
          generatorOutputs.sample.textContent = `${sampleRateEl.value}%`;
        }
        if (generatorOutputs.iterations) {
          generatorOutputs.iterations.textContent = String(kmeansItersEl.value);
        }
        if (generatorOutputs.smoothing) {
          generatorOutputs.smoothing.textContent = String(smoothingEl.value);
        }
        if (sourceImageLimitOutput) {
          const limitSource = sourceImageLimitSelect
            ? sourceImageLimitSelect.value
            : DEFAULT_SOURCE_IMAGE_MAX_BYTES;
          sourceImageLimitOutput.textContent = formatSourceImageLimitLabel(limitSource);
        }
        if (settingsOutputs.uiScale) {
          const source = uiScaleInput ? parseFloat(uiScaleInput.value) : NaN;
          const value = Number.isFinite(source) && source > 0
            ? source
            : (Number.isFinite(state.settings.uiScale) && state.settings.uiScale > 0
                ? state.settings.uiScale
                : DEFAULT_UI_SCALE);
          settingsOutputs.uiScale.textContent = `${Math.round(value * 100)}%`;
        }
        if (settingsOutputs.labelScale) {
          const source = labelScaleInput ? parseFloat(labelScaleInput.value) : NaN;
          const value = Number.isFinite(source) && source > 0
            ? source
            : (Number.isFinite(state.settings.labelScale) && state.settings.labelScale > 0
                ? state.settings.labelScale
                : DEFAULT_LABEL_SCALE);
          settingsOutputs.labelScale.textContent = `${Math.round(value * 100)}%`;
        }
        if (settingsOutputs.hintFadeDuration) {
          const source = hintFadeDurationInput ? Number(hintFadeDurationInput.value) : state.settings.hintFadeDuration;
          const duration = normalizeHintFadeDuration(source);
          settingsOutputs.hintFadeDuration.textContent = `${(duration / 1000).toFixed(1)} s`;
        }
        if (settingsOutputs.hintIntensity) {
          const source = hintIntensityInput ? Number(hintIntensityInput.value) : state.settings.hintIntensity * 100;
          const intensity = normalizeHintIntensity(source);
          settingsOutputs.hintIntensity.textContent = `${Math.round(intensity * 100)}%`;
        }
      }

      function normalizeGenerationAlgorithm(value) {
        if (typeof value === "string") {
          const key = value.trim();
          if (VALID_GENERATION_ALGORITHMS.has(key)) {
            return key;
          }
        }
        return DEFAULT_GENERATION_ALGORITHM;
      }

      function hydrateAlgorithmOptions(catalog) {
        if (!algorithmEl || algorithmOptionsHydrated) {
          return;
        }
        if (!Array.isArray(catalog) || catalog.length === 0) {
          return;
        }
        const options = [];
        for (const entry of catalog) {
          if (!entry || typeof entry.id !== "string") {
            continue;
          }
          const id = entry.id.trim();
          if (!id) {
            continue;
          }
          const baseLabel = typeof entry.label === "string" && entry.label.trim()
            ? entry.label.trim()
            : id;
          const modeSuffix = entry.mode && entry.mode !== "local" ? ` (${entry.mode})` : "";
          options.push({ id, label: `${baseLabel}${modeSuffix}`.trim() });
        }
        if (options.length === 0) {
          return;
        }
        const previousValue = normalizeGenerationAlgorithm(algorithmEl.value);
        algorithmEl.innerHTML = "";
        const seen = new Set();
        for (const option of options) {
          if (seen.has(option.id)) {
            continue;
          }
          seen.add(option.id);
          VALID_GENERATION_ALGORITHMS.add(option.id);
          const opt = document.createElement("option");
          opt.value = option.id;
          opt.textContent = option.label;
          algorithmEl.appendChild(opt);
        }
        if (!seen.has(DEFAULT_GENERATION_ALGORITHM)) {
          const fallbackOption = document.createElement("option");
          fallbackOption.value = DEFAULT_GENERATION_ALGORITHM;
          fallbackOption.textContent = "Local palette clustering (k-means)";
          algorithmEl.appendChild(fallbackOption);
          VALID_GENERATION_ALGORITHMS.add(DEFAULT_GENERATION_ALGORITHM);
          seen.add(DEFAULT_GENERATION_ALGORITHM);
        }
        const targetAlgorithm = seen.has(previousValue)
          ? previousValue
          : DEFAULT_GENERATION_ALGORITHM;
        algorithmEl.value = targetAlgorithm;
        algorithmOptionsHydrated = true;
        markOptionsDirty();
      }

      function markOptionsDirty() {
        if (!state.puzzle || !state.sourceUrl) {
          applyBtn.disabled = true;
          return;
        }
        const current = getCurrentOptions();
        const last = state.lastOptions;
        const lastAlgorithm = last ? normalizeGenerationAlgorithm(last.algorithm) : DEFAULT_GENERATION_ALGORITHM;
        const lastLimit =
          last && Number.isFinite(last.sourceImageMaxBytes) && last.sourceImageMaxBytes >= 0
            ? last.sourceImageMaxBytes
            : DEFAULT_SOURCE_IMAGE_MAX_BYTES;
        const dirty =
          !last ||
          current.targetColors !== last.targetColors ||
          current.minRegion !== last.minRegion ||
          current.maxSize !== last.maxSize ||
          current.sampleRate !== last.sampleRate ||
          current.kmeansIters !== last.kmeansIters ||
          current.smoothingPasses !== last.smoothingPasses ||
          current.sourceImageMaxBytes !== lastLimit ||
          current.algorithm !== lastAlgorithm;
        applyBtn.disabled = !dirty;
      }

      function getCurrentOptions() {
        return {
          targetColors: clamp(Number(colorCountEl.value) || 16, 4, 64),
          minRegion: clamp(Number(minRegionEl.value) || 80, 1, 5000),
          maxSize: clamp(Number(detailEl.value) || 768, 256, 2000),
          sampleRate: clamp(Number(sampleRateEl.value) || 65, 10, 100) / 100,
          kmeansIters: clamp(Number(kmeansItersEl.value) || 12, 1, 64),
          smoothingPasses: clamp(Number(smoothingEl.value) || 1, 0, 6),
          sourceImageMaxBytes: resolveSourceImageLimit(
            sourceImageLimitSelect ? sourceImageLimitSelect.value : DEFAULT_SOURCE_IMAGE_MAX_BYTES
          ),
          algorithm: normalizeGenerationAlgorithm(algorithmEl ? algorithmEl.value : DEFAULT_GENERATION_ALGORITHM),
        };
      }

      function regenerateFromSource() {
        if (!state.sourceUrl) return;
        loadImage(state.sourceUrl);
      }

      function isJsonFile(file) {
        if (!file) {
          return false;
        }
        if (typeof file.type === "string" && file.type.toLowerCase().includes("json")) {
          return true;
        }
        const name = typeof file.name === "string" ? file.name.toLowerCase() : "";
        return name.endsWith(".json") || name.endsWith(".capy");
      }

      function describeImportIntent(file) {
        const fallbackName = "selected file";
        if (!file) {
          return {
            name: fallbackName,
            description: "",
            actionLabel: "Generate puzzle",
          };
        }
        const name =
          typeof file.name === "string" && file.name.trim().length > 0 ? file.name.trim() : fallbackName;
        if (isJsonFile(file)) {
          return {
            name,
            description:
              "Puzzle JSON or compact exports will replace the current puzzle and do not use the generator settings.",
            actionLabel: "Import puzzle",
          };
        }
        return {
          name,
          description:
            "Generation starts immediately using the current settings. Adjust the sliders before importing if needed.",
          actionLabel: "Generating puzzle",
        };
      }

      function shouldAutoImport(file) {
        return Boolean(file) && !isJsonFile(file);
      }

      function updateImportNotice() {
        if (!generatorImportNotice) {
          return;
        }
        if (!pendingImportFile) {
          generatorImportNotice.hidden = true;
          if (generatorImportFileEl) {
            generatorImportFileEl.textContent = "";
          }
          if (generatorImportDescriptionEl) {
            generatorImportDescriptionEl.textContent = "";
          }
          if (confirmImportBtn) {
            confirmImportBtn.hidden = true;
            confirmImportBtn.disabled = true;
            confirmImportBtn.textContent = "Generate puzzle";
          }
          if (cancelImportBtn) {
            cancelImportBtn.hidden = true;
          }
          return;
        }
        const { name, description, actionLabel } = describeImportIntent(pendingImportFile);
        const autoStart = pendingImportAutoStart;
        generatorImportNotice.hidden = false;
        if (generatorImportFileEl) {
          generatorImportFileEl.textContent = name;
        }
        if (generatorImportDescriptionEl) {
          const resolvedDescription = autoStart
            ? "Generating will begin immediately with the current settings. Adjust them beforehand if you need different results."
            : description;
          generatorImportDescriptionEl.textContent = resolvedDescription;
        }
        if (confirmImportBtn) {
          if (autoStart) {
            confirmImportBtn.hidden = true;
            confirmImportBtn.disabled = true;
          } else {
            confirmImportBtn.hidden = false;
            confirmImportBtn.disabled = false;
            confirmImportBtn.textContent = actionLabel;
          }
        }
        if (cancelImportBtn) {
          cancelImportBtn.hidden = autoStart;
        }
      }

      function clearPendingImport() {
        pendingImportFile = null;
        pendingImportAutoStart = false;
        updateImportNotice();
      }

      function normalizeExternalImageUrl(value) {
        if (typeof value !== "string") {
          return null;
        }
        const trimmed = value.trim();
        if (!trimmed) {
          return null;
        }
        try {
          const parsed = new URL(trimmed, window.location.href);
          if (parsed.protocol !== "http:" && parsed.protocol !== "https:") {
            return null;
          }
          return parsed.href;
        } catch (error) {
          return null;
        }
      }

      function deriveSourceTitleFromUrl(value) {
        if (typeof value !== "string") {
          return "Imported image";
        }
        try {
          const parsed = new URL(value, window.location.href);
          const segments = parsed.pathname.split("/").filter(Boolean);
          const last = segments[segments.length - 1];
          if (last) {
            const decoded = decodeURIComponent(last);
            const withoutExtension = decoded.replace(/\.[^.]+$/, "");
            if (withoutExtension.trim()) {
              return withoutExtension.trim();
            }
            if (decoded.trim()) {
              return decoded.trim();
            }
          }
          if (parsed.hostname) {
            return parsed.hostname;
          }
          return parsed.href;
        } catch (error) {
          return value;
        }
      }

      function clearSourceUrlError() {
        if (generatorUrlError) {
          generatorUrlError.hidden = true;
          generatorUrlError.textContent = "";
        }
        if (generatorUrlHint) {
          generatorUrlHint.hidden = false;
        }
      }

      function showSourceUrlError(message) {
        if (generatorUrlError) {
          generatorUrlError.textContent = message;
          generatorUrlError.hidden = false;
        }
        if (generatorUrlHint) {
          generatorUrlHint.hidden = true;
        }
      }

      function updateSourceUrlSubmitState() {
        if (!generatorUrlSubmit) {
          return;
        }
        const value = generatorUrlInput?.value?.trim() || "";
        const busy = pendingSourceUrlLoad === true;
        const shouldDisable = busy || value.length === 0;
        generatorUrlSubmit.disabled = shouldDisable;
        if (busy) {
          generatorUrlSubmit.setAttribute("aria-busy", "true");
        } else {
          generatorUrlSubmit.removeAttribute("aria-busy");
        }
      }

      function handleSourceImageUrl(rawUrl) {
        const normalized = normalizeExternalImageUrl(rawUrl);
        if (!normalized) {
          showSourceUrlError("Enter a valid https:// image URL.");
          updateSourceUrlSubmitState();
          return;
        }
        clearSourceUrlError();
        pendingSourceUrlLoad = true;
        updateSourceUrlSubmitState();
        disableSampleAutoload();
        clearPendingImport();
        resetPuzzleUI();
        state.sourceUrl = normalized;
        state.sourceTitle = deriveSourceTitleFromUrl(normalized) || "Imported image";
        hideStartScreen();
        logDebug(`Generating puzzle from image URL: ${state.sourceTitle}`);
        loadImage(normalized, {
          onError: (error) => {
            pendingSourceUrlLoad = false;
            const errorDetail = error instanceof Error && typeof error.message === "string" ? error.message.trim() : "";
            const hint = "Double-check that the link is reachable, allows cross-origin image loading, and isn’t blocked by your network.";
            const detailedMessage = errorDetail && errorDetail.toLowerCase() !== "unable to read source image"
              ? `Unable to load image from that URL. (${errorDetail}) ${hint}`
              : `Unable to load image from that URL. ${hint}`;
            showSourceUrlError(detailedMessage);
            state.sourceUrl = null;
            state.sourceTitle = null;
            updateSourceUrlSubmitState();
          },
          onSuccess: () => {
            pendingSourceUrlLoad = false;
            if (generatorUrlInput) {
              generatorUrlInput.value = normalized;
            }
            updateSourceUrlSubmitState();
          },
        });
      }

      function prepareImport(file) {
        if (!file) {
          return;
        }
        disableSampleAutoload();
        if (!generatorSheet) {
          handleFile(file);
          return;
        }
        pendingImportFile = file;
        pendingImportAutoStart = shouldAutoImport(file);
        updateImportNotice();
        openSheet(generatorSheet);
        requestAnimationFrame(() => {
          if (pendingImportAutoStart) {
            executePendingImport();
          } else if (confirmImportBtn && !confirmImportBtn.hidden) {
            confirmImportBtn.focus();
          }
        });
      }

      function executePendingImport() {
        if (!pendingImportFile) {
          return;
        }
        const file = pendingImportFile;
        if (confirmImportBtn) {
          confirmImportBtn.disabled = true;
        }
        clearPendingImport();
        handleFile(file);
      }

      function handleFile(file) {
        disableSampleAutoload();
        if (isJsonFile(file)) {
          resetPuzzleUI();
          const reader = new FileReader();
          reader.onload = () => {
            try {
              let payload = JSON.parse(reader.result);
              let formatLabel = "JSON";
              if (
                payload &&
                typeof payload === "object" &&
                typeof payload.format === "string" &&
                payload.format.startsWith("capy-export@") &&
                payload.data &&
                typeof payload.data === "object"
              ) {
                formatLabel = "capy export";
                payload = payload.data;
              }
              if (!payload || typeof payload !== "object") {
                throw new Error("Unsupported puzzle data");
              }
              const providedTitleRaw =
                (typeof payload?.title === "string" && payload.title.trim()) ||
                null;
              const providedTitle = providedTitleRaw;
              const fallbackTitle = file.name || "Imported puzzle";
              const resolvedTitle = providedTitle || fallbackTitle;
              state.sourceTitle = resolvedTitle;
              const applied = applyPuzzleResult(payload, {
                options: payload.options || getCurrentOptions(),
                activeColor: payload.activeColor,
                backgroundColor: payload.backgroundColor,
                stageBackgroundColor: payload.stageBackgroundColor,
                title: resolvedTitle,
              });
              if (applied) {
                hideStartScreen();
                state.sourceUrl = payload.sourceUrl || null;
                logDebug(`Imported puzzle from ${formatLabel}: ${resolvedTitle}`);
              } else {
                setProgressMessage("idle");
              }
            } catch (error) {
              console.error(error);
              setProgressMessage("idle");
            }
          };
          reader.onerror = () => {
            console.error("Unable to read that file.");
            setProgressMessage("idle");
          };
          reader.readAsText(file);
          return;
        }
        resetPuzzleUI();
        const reader = new FileReader();
        reader.onload = () => {
          const result = reader.result;
          if (typeof result === "string") {
            state.sourceUrl = result;
            state.sourceTitle = file.name || "Imported image";
            hideStartScreen();
            logDebug(`Generating puzzle from image: ${state.sourceTitle}`);
            loadImage(result);
          } else {
            console.error("Unsupported file format");
            setProgressMessage("idle");
          }
        };
        reader.onerror = () => {
          console.error("Unable to read that file.");
          setProgressMessage("idle");
        };
        reader.readAsDataURL(file);
      }

      function loadImage(url, loadOptions = {}) {
        const { logMessage, completionMessage, skipDefaultLog, onError, onSuccess } = loadOptions;
        if (logMessage) {
          logDebug(logMessage);
        }
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = async () => {
          try {
            const options = getCurrentOptions();
            const data = await createPuzzleData(img, options);
            if (!data) {
              if (typeof onError === "function") {
                try {
                  onError(new Error("Puzzle generation returned no data"));
                } catch (handlerError) {
                  console.error("Source image error handler failed", handlerError);
                }
              }
              return;
            }
            if (!isProbablyDataUrl(url)) {
              const originalWidth = Number.isFinite(data.originalWidth)
                ? data.originalWidth
                : Number.isFinite(img.naturalWidth) && img.naturalWidth > 0
                ? img.naturalWidth
                : data.width;
              const originalHeight = Number.isFinite(data.originalHeight)
                ? data.originalHeight
                : Number.isFinite(img.naturalHeight) && img.naturalHeight > 0
                ? img.naturalHeight
                : data.height;
              const scale =
                Number.isFinite(originalWidth) && originalWidth > 0 && Number.isFinite(data.width) && data.width > 0
                  ? data.width / originalWidth
                  : 1;
              data.sourceImage = {
                url,
                bytes: null,
                mimeType: null,
                width: data.width,
                height: data.height,
                originalWidth,
                originalHeight,
                scale,
                variant: SOURCE_IMAGE_VARIANT_ORIGINAL,
              };
            }
            const title = state.sourceTitle || "Generated puzzle";
            const applied = applyPuzzleResult(data, {
              options,
              title,
              backgroundColor: state.settings.backgroundColor,
              stageBackgroundColor: state.settings.stageBackgroundColor,
              logMessage: completionMessage,
              skipDefaultLog,
            });
            if (!applied) {
              setProgressMessage("idle");
              if (typeof onError === "function") {
                try {
                  onError(new Error("Failed to apply puzzle result"));
                } catch (handlerError) {
                  console.error("Source image error handler failed", handlerError);
                }
              }
            } else if (typeof onSuccess === "function") {
              try {
                onSuccess(data);
              } catch (handlerError) {
                console.error("Source image success handler failed", handlerError);
              }
            }
          } catch (error) {
            console.error("Failed to create puzzle", error);
            setProgressMessage("idle");
            if (typeof onError === "function") {
              try {
                onError(error);
              } catch (handlerError) {
                console.error("Source image error handler failed", handlerError);
              }
            }
          }
        };
        img.onerror = (error) => {
          console.error("Unable to read that image.", error);
          setProgressMessage("idle");
          if (typeof onError === "function") {
            try {
              onError(error instanceof Error ? error : new Error("Unable to read source image"));
            } catch (handlerError) {
              console.error("Source image error handler failed", handlerError);
            }
          }
        };
        img.src = url;
      }

      function resetPuzzleUI() {
        clearOverlayAnimations();
        state.puzzle = null;
        state.activeColor = null;
        state.filled = new Set();
        markFilledLayerDirty();
        state.sourceUrl = null;
        state.sourceTitle = null;
        if (paletteEl) {
          paletteEl.innerHTML = "";
        }
        if (paletteSortEl) {
          paletteSortEl.disabled = true;
          const target = state.paletteSort || "region";
          if (paletteSortEl.value !== target) {
            paletteSortEl.value = target;
          }
        }
        setProgressMessage("loading");
        const resetCtx = state.rendering?.controller?.getContext?.() || puzzleCanvas?.getContext?.("2d");
        if (resetCtx) {
          clearContext(resetCtx);
        }
        if (previewCtx) {
          previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        }
        previewCanvas.width = 0;
        previewCanvas.height = 0;
        state.previewImageData = null;
        state.renderCache = createRenderCache();
        state.previewVisible = false;
        updatePreviewState();
        updateCommandStates();
        activeTouches.clear();
        pinchSession = null;
        panPointerId = null;
        panCandidate = null;
        isPanning = false;
        document.body.classList.remove("panning");
        resetView({ recenter: true });
        hideCustomCursor();
      }

      function loadPuzzleGenerationModule() {
        if (!puzzleGenerationModulePromise) {
          puzzleGenerationModulePromise = import("./puzzle-generation.js")
            .then((module) => {
              try {
                if (module && Array.isArray(module.GENERATION_ALGORITHM_CATALOG)) {
                  hydrateAlgorithmOptions(module.GENERATION_ALGORITHM_CATALOG);
                }
                if (
                  module &&
                  typeof module.DEFAULT_GENERATION_ALGORITHM_ID === "string" &&
                  module.DEFAULT_GENERATION_ALGORITHM_ID.trim()
                ) {
                  VALID_GENERATION_ALGORITHMS.add(
                    module.DEFAULT_GENERATION_ALGORITHM_ID.trim()
                  );
                }
              } catch (hydrationError) {
                console.warn("Unable to hydrate generator algorithms", hydrationError);
              }
              return module;
            })
            .catch((error) => {
              puzzleGenerationModulePromise = null;
              throw error;
            });
        }
        return puzzleGenerationModulePromise;
      }

      async function createPuzzleData(image, options) {
        const module = await loadPuzzleGenerationModule();
        if (!module || typeof module.createPuzzleData !== "function") {
          throw new Error("Puzzle generation module unavailable");
        }
        return module.createPuzzleData(image, options, {
          beginJob: beginGenerationJob,
          reportStage: reportGenerationStage,
          isLatestJob: isLatestGenerationJob,
          logDebug,
        });
      }

      function resolvePaletteEntrySnapshot(entry, index = 0) {
        if (!entry) return null;
        if (Array.isArray(entry)) {
          const [idValue, hexValue, nameValue, r, g, b] = entry;
          const rgbaValues = [r, g, b].filter((component) => component != null);
          return resolvePaletteEntrySnapshot(
            {
              id: idValue,
              hex: hexValue,
              name: nameValue,
              rgba: rgbaValues.length === 3 ? rgbaValues : undefined,
            },
            index
          );
        }
        if (typeof entry !== "object") return null;
        const idSource = Number.isFinite(entry.id)
          ? entry.id
          : Number.isFinite(entry.i)
          ? entry.i
          : null;
        const id = idSource != null ? idSource : index + 1;
        let hex = null;
        if (typeof entry.hex === "string" && entry.hex.trim()) {
          hex = entry.hex.trim();
        } else if (typeof entry.h === "string" && entry.h.trim()) {
          hex = entry.h.trim();
        }
        if (hex && !hex.startsWith("#") && hex.length === 6) {
          hex = `#${hex}`;
        }
        const rgbaSource = Array.isArray(entry.rgba)
          ? entry.rgba
          : Array.isArray(entry.r)
          ? entry.r
          : null;
        let rgba = null;
        if (rgbaSource) {
          rgba = rgbaSource.slice(0, 3).map((value) => {
            const numeric = Math.round(Number(value) || 0);
            return clamp(numeric, 0, 255);
          });
        }
        const nameSource =
          typeof entry.name === "string" && entry.name.trim()
            ? entry.name.trim()
            : typeof entry.n === "string" && entry.n.trim()
            ? entry.n.trim()
            : typeof entry.label === "string" && entry.label.trim()
            ? entry.label.trim()
            : typeof entry.title === "string" && entry.title.trim()
            ? entry.title.trim()
            : null;
        return {
          id,
          hex,
          rgba,
          name: nameSource,
        };
      }

      function encodeCompactPaletteEntry(entry) {
        if (!entry) return null;
        const record = { i: entry.id };
        if (typeof entry.hex === "string" && entry.hex) {
          record.h = entry.hex;
        }
        if (typeof entry.name === "string" && entry.name) {
          record.n = entry.name;
        }
        if (Array.isArray(entry.rgba) && entry.rgba.length >= 3) {
          const rgba = entry.rgba.slice(0, 3).map((value) => clamp(Math.round(Number(value) || 0), 0, 255));
          if (record.h) {
            const reference = hexToRgb(record.h);
            const differs = reference.some((component, index) => component !== rgba[index]);
            if (differs) {
              record.r = rgba;
            }
          } else {
            record.r = rgba;
          }
        }
        return record;
      }

      function resolveRegionEntrySnapshot(entry, index = 0) {
        if (!entry || typeof entry !== "object") return null;
        const idSource = Number.isFinite(entry.id)
          ? entry.id
          : Number.isFinite(entry.i)
          ? entry.i
          : null;
        const id = idSource != null ? idSource : index;
        const colorIdSource = Number.isFinite(entry.colorId)
          ? entry.colorId
          : Number.isFinite(entry.c)
          ? entry.c
          : null;
        const colorId = colorIdSource != null ? colorIdSource : 1;
        let pixelCount = Number.isFinite(entry.pixelCount)
          ? entry.pixelCount
          : Number.isFinite(entry.p)
          ? entry.p
          : 0;
        if (pixelCount === 0 && Array.isArray(entry.pixels)) {
          pixelCount = entry.pixels.length;
        }
        let cx = null;
        if (Number.isFinite(entry.cx)) {
          cx = entry.cx;
        } else if (Number.isFinite(entry.x)) {
          cx = entry.x;
        }
        let cy = null;
        if (Number.isFinite(entry.cy)) {
          cy = entry.cy;
        } else if (Number.isFinite(entry.y)) {
          cy = entry.y;
        }
        return {
          id,
          colorId,
          pixelCount,
          cx,
          cy,
        };
      }

      function encodeCompactRegionEntry(entry) {
        if (!entry) return null;
        const record = {
          i: entry.id,
          c: entry.colorId,
          p: entry.pixelCount,
        };
        if (Number.isFinite(entry.cx)) {
          record.x = Math.round(entry.cx * 1000) / 1000;
        }
        if (Number.isFinite(entry.cy)) {
          record.y = Math.round(entry.cy * 1000) / 1000;
        }
        return record;
      }

      function decodeFilledRegionList(source) {
        if (source == null) return null;
        if (source instanceof Set) {
          return Array.from(source, (value) => {
            const numeric = Math.round(Number(value) || 0);
            return numeric >= 0 && Number.isFinite(numeric) ? numeric : null;
          }).filter((value) => value != null);
        }
        if (Array.isArray(source)) {
          return source
            .map((value) => {
              const numeric = Math.round(Number(value) || 0);
              return numeric >= 0 && Number.isFinite(numeric) ? numeric : null;
            })
            .filter((value) => value != null);
        }
        if (typeof source === "string") {
          const decoded = unpackFilledRegions(source);
          if (Array.isArray(decoded)) {
            return decoded;
          }
          return [];
        }
        if (ArrayBuffer.isView(source)) {
          return Array.from(source, (value) => {
            const numeric = Math.round(Number(value) || 0);
            return numeric >= 0 && Number.isFinite(numeric) ? numeric : null;
          }).filter((value) => value != null);
        }
        if (typeof source.length === "number" && source.length >= 0 && typeof source !== "string") {
          const values = [];
          for (let index = 0; index < source.length; index += 1) {
            const numeric = Math.round(Number(source[index]) || 0);
            if (numeric >= 0 && Number.isFinite(numeric)) {
              values.push(numeric);
            }
          }
          return values;
        }
        return null;
      }

      function resolveFilledRegions(metadataFilled, data) {
        const sources = [];
        if (metadataFilled != null) {
          sources.push(metadataFilled);
        }
        if (data) {
          if (data.filled != null) {
            sources.push(data.filled);
          }
          if (typeof data.filledPacked === "string") {
            sources.push(data.filledPacked);
          }
          if (typeof data.f === "string") {
            sources.push(data.f);
          }
        }
        for (const source of sources) {
          const decoded = decodeFilledRegionList(source);
          if (decoded != null) {
            return decoded;
          }
        }
        return [];
      }

      function isProbablyDataUrl(value) {
        if (typeof value !== "string") {
          return false;
        }
        return value.trim().toLowerCase().startsWith("data:");
      }

      function estimateDataUrlBytes(dataUrl) {
        if (typeof dataUrl !== "string") {
          return null;
        }
        const commaIndex = dataUrl.indexOf(",");
        if (commaIndex === -1) {
          return null;
        }
        const payload = dataUrl.slice(commaIndex + 1);
        if (!payload) {
          return 0;
        }
        const padding = payload.endsWith("==") ? 2 : payload.endsWith("=") ? 1 : 0;
        return Math.max(0, Math.floor(payload.length / 4) * 3 - padding);
      }

      function normalizeSourceImageSnapshot(snapshot, defaults = {}) {
        if (!snapshot) {
          return null;
        }
        const defaultWidth = Number.isFinite(defaults.width) ? defaults.width : null;
        const defaultHeight = Number.isFinite(defaults.height) ? defaults.height : null;
        const defaultOriginalWidth =
          Number.isFinite(defaults.originalWidth) ? defaults.originalWidth : defaultWidth;
        const defaultOriginalHeight =
          Number.isFinite(defaults.originalHeight) ? defaults.originalHeight : defaultHeight;
        const sourceObject = snapshot && typeof snapshot === "object" ? snapshot : null;
        let dataUrl = null;
        let url = null;
        if (typeof snapshot === "string") {
          const trimmed = snapshot.trim();
          if (!trimmed) {
            return null;
          }
          if (isProbablyDataUrl(trimmed)) {
            dataUrl = trimmed;
          } else {
            url = trimmed;
          }
        } else if (sourceObject) {
          const rawDataUrl =
            typeof sourceObject.dataUrl === "string" && sourceObject.dataUrl
              ? sourceObject.dataUrl.trim()
              : "";
          if (rawDataUrl) {
            if (isProbablyDataUrl(rawDataUrl)) {
              dataUrl = rawDataUrl;
            } else {
              url = rawDataUrl;
            }
          }
          const rawUrl =
            (typeof sourceObject.url === "string" && sourceObject.url.trim()) ||
            (typeof sourceObject.href === "string" && sourceObject.href.trim()) ||
            (typeof sourceObject.src === "string" && sourceObject.src.trim()) ||
            "";
          if (rawUrl) {
            url = rawUrl;
          }
        }
        if (!dataUrl && !url) {
          return null;
        }
        if (url) {
          try {
            const parsed = new URL(url, window.location.href);
            url = parsed.href;
          } catch (error) {
            // leave url as-is if it can't be normalised
          }
        }
        let mimeType =
          typeof sourceObject?.mimeType === "string" && sourceObject.mimeType
            ? sourceObject.mimeType
            : null;
        let bytes = Number.isFinite(sourceObject?.bytes) ? sourceObject.bytes : null;
        let width = Number.isFinite(sourceObject?.width) && sourceObject.width > 0
          ? sourceObject.width
          : defaultWidth;
        let height = Number.isFinite(sourceObject?.height) && sourceObject.height > 0
          ? sourceObject.height
          : defaultHeight;
        let originalWidth =
          Number.isFinite(sourceObject?.originalWidth) && sourceObject.originalWidth > 0
            ? sourceObject.originalWidth
            : defaultOriginalWidth;
        let originalHeight =
          Number.isFinite(sourceObject?.originalHeight) && sourceObject.originalHeight > 0
            ? sourceObject.originalHeight
            : defaultOriginalHeight;
        let scale = Number.isFinite(sourceObject?.scale) && sourceObject.scale > 0
          ? sourceObject.scale
          : null;
        let variant = SOURCE_IMAGE_VARIANT_ORIGINAL;
        if (typeof sourceObject?.variant === "string" && sourceObject.variant) {
          variant = sourceObject.variant;
        } else if (sourceObject?.generated === true) {
          variant = SOURCE_IMAGE_VARIANT_GENERATED;
        }
        const resolvedDataUrl = dataUrl && dataUrl.length > 0 ? dataUrl : null;
        const resolvedUrl = url && url.length > 0 ? url : null;
        if (!resolvedDataUrl && !resolvedUrl) {
          return null;
        }
        if (resolvedDataUrl) {
          if (!mimeType) {
            const match = /^data:([^;,]+)[;,]/.exec(resolvedDataUrl);
            if (match) {
              mimeType = match[1];
            }
          }
          if (!Number.isFinite(bytes) || bytes <= 0) {
            bytes = estimateDataUrlBytes(resolvedDataUrl);
          }
        } else {
          mimeType = typeof sourceObject?.mimeType === "string" && sourceObject.mimeType
            ? sourceObject.mimeType
            : null;
          bytes = null;
        }
        if (!Number.isFinite(width) || width <= 0) {
          width = defaultWidth || null;
        }
        if (!Number.isFinite(height) || height <= 0) {
          height = defaultHeight || null;
        }
        if (!Number.isFinite(originalWidth) || originalWidth <= 0) {
          originalWidth = width || defaultWidth || null;
        }
        if (!Number.isFinite(originalHeight) || originalHeight <= 0) {
          originalHeight = height || defaultHeight || null;
        }
        const resolvedScale =
          Number.isFinite(scale) && scale > 0
            ? scale
            : width && defaultWidth && defaultWidth > 0
            ? width / defaultWidth
            : 1;
        return {
          dataUrl: resolvedDataUrl,
          url: resolvedUrl,
          mimeType: resolvedDataUrl ? mimeType || "image/png" : mimeType,
          bytes: Number.isFinite(bytes) && bytes > 0 ? bytes : null,
          width: width || defaultWidth || originalWidth || null,
          height: height || defaultHeight || originalHeight || null,
          originalWidth: originalWidth || width || defaultWidth || null,
          originalHeight: originalHeight || height || defaultHeight || null,
          scale: resolvedScale,
          variant:
            variant === SOURCE_IMAGE_VARIANT_GENERATED
              ? SOURCE_IMAGE_VARIANT_GENERATED
              : SOURCE_IMAGE_VARIANT_ORIGINAL,
        };
      }

      function hydrateSourceImageSnapshot(snapshot, defaults = {}, options = {}) {
        const normalized = normalizeSourceImageSnapshot(snapshot, defaults);
        if (!normalized) {
          return null;
        }
        const image = new Image();
        image.decoding = "async";
        image.crossOrigin = "anonymous";
        const record = {
          ...normalized,
          snapshot: normalized,
          image,
          ready: false,
        };
        const finalize = () => {
          record.ready = true;
          if (image.naturalWidth > 0 && image.naturalHeight > 0) {
            record.width = image.naturalWidth;
            record.height = image.naturalHeight;
          }
          if (typeof options.onReady === "function") {
            try {
              options.onReady(record);
            } catch (error) {
              console.error("Source image onReady handler failed", error);
            }
          }
        };
        image.onload = finalize;
        image.onerror = (error) => {
          console.warn("Failed to load stored source image", error);
        };
        const source = normalized.dataUrl || normalized.url;
        if (source) {
          try {
            image.src = source;
          } catch (error) {
            console.error("Unable to assign source image", error);
          }
        }
        if (image.complete && image.naturalWidth > 0 && image.naturalHeight > 0) {
          finalize();
        }
        return record;
      }

      function buildGeneratedSourceImageSnapshot(puzzle) {
        if (!puzzle || !Number.isFinite(puzzle.width) || !Number.isFinite(puzzle.height)) {
          return null;
        }
        const { width, height, regions, palette } = puzzle;
        if (!Array.isArray(regions) || regions.length === 0) {
          return null;
        }
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          return null;
        }
        const imageData = ctx.createImageData(width, height);
        const data = imageData.data;
        const paletteById = new Map();
        for (const entry of palette || []) {
          if (!entry || !Number.isFinite(entry.id)) continue;
          let rgba = Array.isArray(entry.rgba) ? entry.rgba.slice(0, 3) : null;
          if (!rgba && typeof entry.hex === "string" && entry.hex) {
            rgba = hexToRgb(entry.hex);
          }
          if (!rgba) continue;
          paletteById.set(entry.id, rgba);
        }
        for (const region of regions) {
          if (!region || !Array.isArray(region.pixels)) continue;
          const rgba = paletteById.get(region.colorId);
          if (!rgba) continue;
          for (const idx of region.pixels) {
            const base = idx * 4;
            data[base] = rgba[0];
            data[base + 1] = rgba[1];
            data[base + 2] = rgba[2];
            data[base + 3] = 255;
          }
        }
        ctx.putImageData(imageData, 0, 0);
        let dataUrl = null;
        try {
          dataUrl = canvas.toDataURL("image/png");
        } catch (error) {
          console.warn("Failed to encode generated source image", error);
          return null;
        }
        const bytes = estimateDataUrlBytes(dataUrl);
        return {
          dataUrl,
          mimeType: "image/png",
          bytes: Number.isFinite(bytes) && bytes > 0 ? bytes : null,
          width,
          height,
          originalWidth: width,
          originalHeight: height,
          scale: 1,
          variant: SOURCE_IMAGE_VARIANT_GENERATED,
        };
      }

      function applyPuzzleResult(data, metadata = {}) {
        disableSampleAutoload();
        const loadedIdRaw =
          metadata && typeof metadata.loadedSaveId === "string" ? metadata.loadedSaveId.trim() : "";
        state.loadedSaveId = loadedIdRaw ? loadedIdRaw : null;
        if (!data || typeof data.width !== "number" || typeof data.height !== "number") {
          console.error("Puzzle data missing required dimensions.");
          setProgressMessage("idle");
          return false;
        }
        if (!Array.isArray(data.palette) || !Array.isArray(data.regions)) {
          console.error("Puzzle data missing palette information.");
          setProgressMessage("idle");
          return false;
        }
        const expectedCells = data.width * data.height;
        const regionMapPacked =
          (typeof data.m === "string" && data.m)
            ? data.m
            : (typeof data.map === "string" && data.map)
            ? data.map
            : data.regionMapPacked;
        const regionMapSource =
          unpackRegionMap(regionMapPacked, expectedCells) ||
          unpackRegionMap(data.regionMap, expectedCells);
        if (!regionMapSource || regionMapSource.length !== expectedCells) {
          console.error("Puzzle data is inconsistent.");
          setProgressMessage("idle");
          return false;
        }
        let needsPixelHydration = false;
        for (const region of data.regions) {
          if (!Array.isArray(region.pixels) || region.pixels.length === 0) {
            needsPixelHydration = true;
            break;
          }
        }
        let hydratedPixels = null;
        if (needsPixelHydration) {
          hydratedPixels = new Map();
          for (let i = 0; i < data.regions.length; i++) {
            const region = data.regions[i];
            const resolvedId = region.id != null ? region.id : i;
            hydratedPixels.set(resolvedId, []);
          }
          for (let idx = 0; idx < regionMapSource.length; idx++) {
            const regionId = regionMapSource[idx];
            if (hydratedPixels.has(regionId)) {
              hydratedPixels.get(regionId).push(idx);
            }
          }
        }
        const paletteSource = Array.isArray(data.palette) ? data.palette : [];
        const palette = [];
        for (let index = 0; index < paletteSource.length; index += 1) {
          const resolvedEntry = resolvePaletteEntrySnapshot(paletteSource[index], index);
          if (!resolvedEntry) continue;
          const hex = typeof resolvedEntry.hex === "string" && resolvedEntry.hex
            ? resolvedEntry.hex
            : "#ffffff";
          const rgba = Array.isArray(resolvedEntry.rgba)
            ? resolvedEntry.rgba.slice(0, 3)
            : hexToRgb(hex);
          const id = Number.isFinite(resolvedEntry.id) ? resolvedEntry.id : index + 1;
          const fallbackName = typeof hex === "string" ? hex.toUpperCase() : `Colour ${id}`;
          const providedName =
            typeof resolvedEntry.name === "string" && resolvedEntry.name
              ? resolvedEntry.name
              : null;
          palette.push({
            id,
            hex,
            rgba,
            name: providedName || fallbackName,
          });
        }
        const regionSource = Array.isArray(data.regions) ? data.regions : [];
        const regions = regionSource.map((region, index) => {
          const resolved = resolveRegionEntrySnapshot(region, index) || {
            id: index,
            colorId: 1,
            pixelCount: 0,
            cx: null,
            cy: null,
          };
          const resolvedId = resolved.id != null ? resolved.id : index;
          const pixelsSource =
            Array.isArray(region.pixels) && region.pixels.length > 0
              ? region.pixels
              : hydratedPixels?.get(resolvedId) || [];
          const pixels = Array.from(pixelsSource);
          const pixelCount = Number.isFinite(resolved.pixelCount)
            ? resolved.pixelCount
            : pixels.length;
          let cx = Number.isFinite(resolved.cx) ? resolved.cx : null;
          let cy = Number.isFinite(resolved.cy) ? resolved.cy : null;
          if (pixels.length && (cx == null || cy == null)) {
            let sumX = 0;
            let sumY = 0;
            for (const idx of pixels) {
              sumX += idx % data.width;
              sumY += (idx / data.width) | 0;
            }
            cx = sumX / pixels.length;
            cy = sumY / pixels.length;
          }
          return {
            id: resolvedId,
            colorId: Number.isFinite(resolved.colorId) ? resolved.colorId : 1,
            pixels,
            pixelCount,
            cx: cx ?? 0,
            cy: cy ?? 0,
          };
        });
        const regionMap = regionMapSource instanceof Int32Array
          ? regionMapSource
          : new Int32Array(regionMapSource);
        const sourceDefaults = {
          width: data.width,
          height: data.height,
          originalWidth: Number.isFinite(data.originalWidth) ? data.originalWidth : data.width,
          originalHeight: Number.isFinite(data.originalHeight) ? data.originalHeight : data.height,
        };
        const metadataTitle =
          typeof metadata.title === "string" && metadata.title.trim() ? metadata.title.trim() : null;
        const completionLog =
          metadata.logMessage != null && metadata.logMessage !== ""
            ? String(metadata.logMessage)
            : null;
        const skipLoadLog = Boolean(metadata.skipDefaultLog);
        if (metadataTitle) {
          state.sourceTitle = metadataTitle;
        } else if (typeof data.title === "string" && data.title.trim()) {
          state.sourceTitle = data.title.trim();
        }
        const paletteIds = new Set(palette.map((entry) => entry.id));
        const requestedColor = metadata.activeColor ?? palette[0]?.id ?? null;
        const backgroundHex = sanitizeHexColor(
          metadata.backgroundColor ?? data.backgroundColor ?? state.settings.backgroundColor ?? DEFAULT_BACKGROUND_HEX,
          state.settings.backgroundColor ?? DEFAULT_BACKGROUND_HEX
        );
        const stageBackgroundHex = sanitizeHexColor(
          metadata.stageBackgroundColor ??
            data.stageBackgroundColor ??
            state.settings.stageBackgroundColor ??
            DEFAULT_STAGE_BACKGROUND_HEX,
          state.settings.stageBackgroundColor ?? DEFAULT_STAGE_BACKGROUND_HEX
        );
        const puzzle = {
          width: data.width,
          height: data.height,
          palette,
          regions,
          regionMap,
        };
        state.puzzle = puzzle;
        const sourceSnapshot = metadata.sourceImage ?? data.sourceImage;
        let sourceImageRecord = hydrateSourceImageSnapshot(sourceSnapshot, sourceDefaults, {
          onReady: () => {
            if (state.puzzle === puzzle) {
              renderPuzzle();
            }
          },
        });
        if (!sourceImageRecord) {
          const fallbackSnapshot = buildGeneratedSourceImageSnapshot(puzzle);
          if (fallbackSnapshot) {
            sourceImageRecord = hydrateSourceImageSnapshot(fallbackSnapshot, sourceDefaults, {
              onReady: () => {
                if (state.puzzle === puzzle) {
                  renderPuzzle();
                }
              },
            });
          }
        }
        puzzle.sourceImage = sourceImageRecord;
        state.renderCache = createRenderCache();
        state.puzzle.backgroundColor = backgroundHex;
        state.activeColor =
          requestedColor != null && paletteIds.has(requestedColor)
            ? requestedColor
            : palette[0]?.id ?? null;
        const filledRegions = resolveFilledRegions(metadata.filled, data);
        state.filled = new Set(filledRegions ?? []);
        markFilledLayerDirty();
        const lastOptionsRaw = metadata.options ?? getCurrentOptions();
        const normalizedOptions = {
          ...lastOptionsRaw,
          sourceImageMaxBytes: resolveSourceImageLimit(lastOptionsRaw?.sourceImageMaxBytes),
          algorithm: normalizeGenerationAlgorithm(lastOptionsRaw?.algorithm),
        };
        state.lastOptions = normalizedOptions;
        if (algorithmEl) {
          const currentAlgorithm = normalizeGenerationAlgorithm(algorithmEl.value);
          const targetAlgorithm = normalizedOptions.algorithm || DEFAULT_GENERATION_ALGORITHM;
          if (currentAlgorithm !== targetAlgorithm) {
            algorithmEl.value = targetAlgorithm;
          }
        }
        if (sourceImageLimitSelect) {
          const limitText = String(
            Number.isFinite(normalizedOptions.sourceImageMaxBytes)
              ? normalizedOptions.sourceImageMaxBytes
              : DEFAULT_SOURCE_IMAGE_MAX_BYTES
          );
          if (sourceImageLimitSelect.value !== limitText) {
            sourceImageLimitSelect.value = limitText;
          }
        }
        updateOptionOutputs();
        const resolvedSettings = metadata.settings ?? data.settings;
        if (resolvedSettings) {
          applyGameplaySettings(resolvedSettings);
        }
        applyStageBackgroundColor(stageBackgroundHex, {
          skipLog: true,
          skipAutosave: true,
          force: true,
        });
        applyBackgroundColor(backgroundHex, { skipRender: true, skipLog: true });
        applyCanvasSizing();
        previewCanvas.width = data.width;
        previewCanvas.height = data.height;
        ensureRenderCache({ force: true });
        renderPreview();
        renderPuzzle();
        renderPalette();
        if (state.activeColor != null) {
          if (isHintTypeEnabled("matchingRegions")) {
            flashColorRegions(state.activeColor);
          }
        }
        updateProgress();
        updateCommandStates();
        updatePreviewState();
        markOptionsDirty();
        const restoredViewport = metadata.viewport ?? data.viewport;
        if (!restoreViewport(restoredViewport)) {
          resetView({ recenter: true });
        }
        const paletteCount = palette.length;
        const regionCount = regions.length;
        const descriptor =
          metadataTitle ||
          (typeof data.title === "string" && data.title.trim()) ||
          (state.sourceTitle && state.sourceTitle.trim()) ||
          "Puzzle";
        if (completionLog) {
          logDebug(completionLog);
        } else if (!skipLoadLog) {
          logDebug(
            `Loaded ${descriptor} (${data.width}×${data.height}, ${paletteCount} colours, ${regionCount} regions)`
          );
        }
        refreshSaveList();
        scheduleAutosave("puzzle-load", { immediate: true });
        return true;
      }

      function loadPuzzleFixtureData(puzzle) {
        if (!puzzle) return false;
        resetPuzzleUI();
        const resolvedTitle =
          (typeof puzzle.name === "string" && puzzle.name.trim()) ||
          (typeof puzzle.title === "string" && puzzle.title.trim()) ||
          "Fixture puzzle";
        state.sourceTitle = resolvedTitle;
        const applied = applyPuzzleResult(puzzle, {
          options: getCurrentOptions(),
          filled: puzzle.filled,
          activeColor: puzzle.activeColor,
          backgroundColor: puzzle.backgroundColor,
          stageBackgroundColor: puzzle.stageBackgroundColor,
          title: resolvedTitle,
        });
        if (applied) {
          hideStartScreen();
        }
        return applied;
      }

      function renderPreview() {
        if (!state.puzzle) {
          state.previewImageData = null;
          return null;
        }
        const controller = state.rendering?.controller;
        const imageData = controller
          ? controller.renderPreview({ state, previewCanvas, previewCtx })
          : renderPreviewImage({ state, previewCanvas, previewCtx });
        state.previewImageData = imageData || null;
        return imageData || null;
      }

      function renderPreviewImage({ state, previewCanvas, previewCtx }) {
        if (!state?.puzzle) return null;
        const { width, height, regions, palette } = state.puzzle;
        if (previewCanvas) {
          previewCanvas.width = width;
          previewCanvas.height = height;
        }
        let imageData = null;
        if (previewCtx && typeof previewCtx.createImageData === "function") {
          imageData = previewCtx.createImageData(width, height);
        } else if (typeof ImageData === "function") {
          imageData = new ImageData(width, height);
        }
        if (!imageData) {
          return null;
        }
        const data = imageData.data;
        for (const region of regions) {
          const color = palette[region.colorId - 1];
          if (!color) continue;
          const rgba = color.rgba;
          for (const idx of region.pixels) {
            const base = idx * 4;
            data[base] = rgba[0];
            data[base + 1] = rgba[1];
            data[base + 2] = rgba[2];
            data[base + 3] = 255;
          }
        }
        if (previewCtx && typeof previewCtx.putImageData === "function") {
          previewCtx.putImageData(imageData, 0, 0);
        }
        return imageData;
      }

      function renderPuzzle() {
        if (!state.puzzle) return;
        ensureCanvasMetricsInitialized();
        const cache = ensureRenderCache();
        const controller = state.rendering?.controller;
        if (!controller) return;
        controller.renderFrame({
          state,
          cache,
          metrics: { ...canvasMetrics },
          previewCanvas,
          previewCtx,
          previewImageData: state.previewImageData,
          previewVisible: state.previewVisible === true,
          backgroundColor: state.settings.backgroundColor || DEFAULT_BACKGROUND_HEX,
          defaultBackgroundColor: DEFAULT_BACKGROUND_HEX,
          renderPreview: () =>
            controller.renderPreview({ state, previewCanvas, previewCtx }) || state.previewImageData,
          setPreviewImageData: (imageData) => {
            state.previewImageData = imageData || null;
          },
        });
      }

      function renderPuzzleFrame({
        context,
        state,
        cache,
        metrics,
        previewCanvas,
        previewCtx,
        previewImageData,
        previewVisible,
        backgroundColor,
        defaultBackgroundColor,
        renderPreview,
        setPreviewImageData,
      }) {
        if (!context || !state?.puzzle) return;
        const pixelWidth = metrics?.pixelWidth ?? context.canvas?.width ?? 0;
        const pixelHeight = metrics?.pixelHeight ?? context.canvas?.height ?? 0;
        context.save();
        context.setTransform(1, 0, 0, 1, 0, 0);
        context.clearRect(0, 0, pixelWidth, pixelHeight);
        const fill = backgroundColor || defaultBackgroundColor;
        context.fillStyle = fill;
        context.fillRect(0, 0, pixelWidth, pixelHeight);
        if (previewVisible) {
          let imageData = previewImageData || null;
          if (!imageData && typeof renderPreview === "function") {
            imageData = renderPreview() || null;
            if (imageData && typeof setPreviewImageData === "function") {
              setPreviewImageData(imageData);
            }
          }
          if (imageData) {
            if (previewCanvas && previewCanvas.width && previewCanvas.height) {
              const sourceWidth = previewCanvas.width;
              const sourceHeight = previewCanvas.height;
              const targetWidth = metrics?.pixelWidth || pixelWidth;
              const targetHeight = metrics?.pixelHeight || pixelHeight;
              context.imageSmoothingEnabled = false;
              context.drawImage(
                previewCanvas,
                0,
                0,
                sourceWidth,
                sourceHeight,
                0,
                0,
                targetWidth,
                targetHeight
              );
            } else if (typeof context.putImageData === "function") {
              context.putImageData(imageData, 0, 0);
            }
          }
          context.restore();
          return;
        }
        const renderScale = cache?.renderScale > 0 ? cache.renderScale : 1;
        const puzzleImage = state.puzzle?.sourceImage;
        if (puzzleImage?.image && puzzleImage.ready) {
          const targetWidth = state.puzzle.width;
          const targetHeight = state.puzzle.height;
          if (targetWidth > 0 && targetHeight > 0) {
            context.save();
            context.setTransform(renderScale, 0, 0, renderScale, 0, 0);
            context.imageSmoothingEnabled = true;
            try {
              context.drawImage(puzzleImage.image, 0, 0, targetWidth, targetHeight);
            } catch (error) {
              console.warn("Failed to draw source image", error);
            }
            context.restore();
          }
        }
        if (cache?.ready) {
          let drewFromLayer = false;
          if (cache.filledLayer && cache.filledLayerCtx) {
            drewFromLayer = cache.filledLayerDirty ? rebuildFilledLayer(cache) : true;
            if (drewFromLayer && cache.filledLayer) {
              context.drawImage(cache.filledLayer, 0, 0);
            }
          }
          if (!drewFromLayer) {
            compositeFilledRegionsDirect(context, cache);
          }
        }
        context.restore();
        drawOutlines(context);
        drawNumbers(context);
      }

      function fillBackgroundLayer({ context, color, metrics }) {
        if (!context) return;
        const width = metrics?.pixelWidth ?? context.canvas?.width ?? 0;
        const height = metrics?.pixelHeight ?? context.canvas?.height ?? 0;
        context.save();
        context.setTransform(1, 0, 0, 1, 0, 0);
        context.fillStyle = color || DEFAULT_BACKGROUND_HEX;
        context.fillRect(0, 0, width, height);
        context.restore();
      }

      function drawNumbers(ctx) {
        if (!state.puzzle || !ctx) return;
        if (state.settings.showRegionLabels === false) return;
        const scale = canvasMetrics.renderScale > 0 ? canvasMetrics.renderScale : 1;
        const puzzleWidth = state.puzzle?.width || 0;
        const puzzleHeight = state.puzzle?.height || 0;
        const regionMap = state.puzzle?.regionMap || null;
        const hasRegionMap =
          regionMap && puzzleWidth > 0 && puzzleHeight > 0 && regionMap.length === puzzleWidth * puzzleHeight;
        withRenderScale(ctx, scale, () => {
          const fallbackNumberInk = backgroundInk.number;
          const fallbackOutlineInk = backgroundInk.outline;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.lineJoin = "round";
          ctx.lineCap = "round";
          ctx.strokeStyle = fallbackOutlineInk;
          for (const region of state.puzzle.regions) {
            if (!region || state.filled.has(region.id)) continue;
            const text = getRegionLabelText(region);
            if (!text) continue;
            let fontSize = computeRegionLabelFontSize(region, text);
            if (!Number.isFinite(fontSize) || fontSize <= 0) {
              continue;
            }
            let bounds = null;
            if (puzzleWidth > 0) {
              bounds = ensureRegionBounds(region, puzzleWidth);
            }
            let metrics = measureLabelMetrics(text, fontSize);
            let center = null;
            if (metrics && hasRegionMap) {
              center = findRegionLabelAnchor(
                region,
                metrics.halfWidth,
                metrics.halfHeight,
                bounds,
                puzzleWidth,
                puzzleHeight,
                regionMap
              );
              let attempts = 0;
              while (!center && attempts < 5 && fontSize > 0.5) {
                attempts += 1;
                fontSize = Math.max(fontSize * 0.85, fontSize - 0.75);
                metrics = measureLabelMetrics(text, fontSize);
                if (!metrics) {
                  break;
                }
                center = findRegionLabelAnchor(
                  region,
                  metrics.halfWidth,
                  metrics.halfHeight,
                  bounds,
                  puzzleWidth,
                  puzzleHeight,
                  regionMap
                );
              }
            }
            if (!center) {
              center = getRegionCenter(region);
              metrics = metrics || measureLabelMetrics(text, fontSize);
            }
            if (!center || !metrics) continue;
            const paletteColor = getPaletteEntry(region.colorId);
            const regionInk =
              paletteColor?.hex && typeof paletteColor.hex === "string"
                ? rgbaFromHex(paletteColor.hex, 1)
                : fallbackNumberInk;
            const strokeWidth = computeRegionLabelStrokeWidth(fontSize);
            ctx.fillStyle = regionInk;
            ctx.font = `${fontSize}px "Inter", "Segoe UI", sans-serif`;
            ctx.lineWidth = strokeWidth;
            ctx.strokeText(text, center.x, center.y);
            ctx.fillText(text, center.x, center.y);
          }
        });
      }

      function computeRegionLabelFontSize(region, labelText = "") {
        const uiScaleSetting =
          Number.isFinite(state?.settings?.uiScale) && state.settings.uiScale > 0
            ? state.settings.uiScale
            : DEFAULT_UI_SCALE;
        const labelScaleSetting =
          Number.isFinite(state?.settings?.labelScale) && state.settings.labelScale > 0
            ? state.settings.labelScale
            : DEFAULT_LABEL_SCALE;
        const scaleFactor = uiScaleSetting / DEFAULT_UI_SCALE;
        const baseSize =
          10 * (Number.isFinite(scaleFactor) && scaleFactor > 0 ? scaleFactor : 1) * labelScaleSetting;
        if (!region) {
          return baseSize;
        }
        const puzzleWidth = state.puzzle?.width || 0;
        const bounds =
          puzzleWidth > 0 ? ensureRegionBounds(region, puzzleWidth) : region.bounds ?? null;
        const pixelCount = Array.isArray(region.pixels) ? region.pixels.length : 0;
        const estimatedArea =
          pixelCount > 0
            ? pixelCount
            : bounds
            ? Math.max(1, bounds.width * bounds.height)
            : 0;
        const fallbackSpan = estimatedArea > 0 ? Math.sqrt(estimatedArea) : baseSize;
        const regionHeight = bounds ? Math.max(1, bounds.height) : Math.max(1, fallbackSpan);
        const regionWidth = bounds ? Math.max(1, bounds.width) : Math.max(1, fallbackSpan);
        const heightLimitRaw = regionHeight * 0.42;
        const heightLimit =
          Number.isFinite(heightLimitRaw) && heightLimitRaw > 0 ? heightLimitRaw : baseSize;
        const textLength = typeof labelText === "string" ? labelText.length : 0;
        const normalizedLength = Math.min(Math.max(textLength, 1), 6);
        const lengthPenalty = 1 + (normalizedLength - 1) * 0.25;
        const baseCandidate = baseSize / lengthPenalty;
        const effectiveLength = Math.max(textLength, 1);
        const averageGlyphWidth = 0.62;
        const widthLimitRaw =
          regionWidth > 0
            ? (regionWidth * 0.78) /
              Math.max(effectiveLength * averageGlyphWidth, averageGlyphWidth)
            : baseCandidate;
        const widthLimit =
          Number.isFinite(widthLimitRaw) && widthLimitRaw > 0 ? widthLimitRaw : baseCandidate;
        const limited = Math.min(baseCandidate, heightLimit, widthLimit);
        if (!Number.isFinite(limited) || limited <= 0) {
          const fallback = Math.min(heightLimit, widthLimit, baseCandidate > 0 ? baseCandidate : baseSize);
          return fallback > 0 ? fallback : 0.35;
        }
        return limited;
      }

      function computeRegionLabelStrokeWidth(fontSize) {
        const normalized = Number.isFinite(fontSize) ? fontSize : 10;
        return clamp(normalized / 28, 0.06, 0.45);
      }

      function getRegionLabelText(region) {
        if (!region) return "";
        const normalize = (value) => {
          if (typeof value === "string") {
            const trimmed = value.trim();
            return trimmed ? trimmed : null;
          }
          if (typeof value === "number" && Number.isFinite(value)) {
            return String(value);
          }
          return null;
        };
        const directLabel =
          normalize(region.label) ?? normalize(region.title) ?? normalize(region.name);
        if (directLabel) {
          return directLabel;
        }
        const displayNumber = getColorDisplayNumber(region.colorId);
        if (displayNumber != null) {
          return String(displayNumber);
        }
        const fallbackId = region.colorId != null ? String(region.colorId) : "";
        return fallbackId;
      }

      function getRegionCenter(region) {
        if (!region) return null;
        if (Number.isFinite(region.cx) && Number.isFinite(region.cy)) {
          return { x: region.cx, y: region.cy };
        }
        const cache = state.renderCache;
        const geometry = cache?.regionsById?.get(region.id);
        const bounds = geometry?.bounds || (state.puzzle ? ensureRegionBounds(region, state.puzzle.width) : null);
        if (!bounds) {
          return null;
        }
        const centerX = (bounds.minX + bounds.maxX + 1) / 2;
        const centerY = (bounds.minY + bounds.maxY + 1) / 2;
        if (!Number.isFinite(centerX) || !Number.isFinite(centerY)) {
          return null;
        }
        return { x: centerX, y: centerY };
      }

      function ensureRegionBounds(region, width) {
        if (region.bounds && Number.isFinite(region.bounds.minX)) {
          return region.bounds;
        }
        const bounds = calculateRegionBounds(region.pixels, width);
        region.bounds = bounds;
        return bounds;
      }

      function calculateRegionBounds(pixels, width) {
        if (!Array.isArray(pixels) || pixels.length === 0) {
          return { minX: 0, maxX: 0, minY: 0, maxY: 0, width: 0, height: 0 };
        }
        let minX = width;
        let minY = Number.POSITIVE_INFINITY;
        let maxX = 0;
        let maxY = 0;
        for (const idx of pixels) {
          const x = idx % width;
          const y = (idx / width) | 0;
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
        if (!Number.isFinite(minY)) {
          return { minX: 0, maxX: 0, minY: 0, maxY: 0, width: 0, height: 0 };
        }
        return {
          minX,
          maxX,
          minY,
          maxY,
          width: maxX - minX + 1,
          height: maxY - minY + 1,
        };
      }

      function measureLabelMetrics(text, size) {
        if (!text || size <= 0) return null;
        const ctx = getMeasurementContext();
        if (!ctx) return null;
        const font = `${size}px "Inter", "Segoe UI", sans-serif`;
        if (typeof ctx.save === "function") {
          ctx.save();
        }
        ctx.font = font;
        const metrics = ctx.measureText(text);
        const textWidth = metrics.width || size;
        const ascent = metrics.actualBoundingBoxAscent || size * 0.78;
        const descent = metrics.actualBoundingBoxDescent || size * 0.22;
        const textHeight = ascent + descent;
        const strokeWidth = clamp(size * 0.18, 0.65, Math.max(2.6, size * 0.24));
        const paddingX = clamp(
          size <= 7 ? size * 0.26 : size * 0.32,
          0.85,
          Math.max(3.6, size * 0.42)
        );
        const paddingY = clamp(
          size <= 7 ? size * 0.22 : size * 0.28,
          0.7,
          Math.max(3, size * 0.36)
        );
        const paddedWidth = textWidth + paddingX * 2 + strokeWidth;
        const paddedHeight = textHeight + paddingY * 2 + strokeWidth;
        if (typeof ctx.restore === "function") {
          ctx.restore();
        }
        return {
          font,
          paddedWidth,
          paddedHeight,
          halfWidth: paddedWidth / 2,
          halfHeight: paddedHeight / 2,
          strokeWidth,
        };
      }

      function getMeasurementContext() {
        const controller = state.rendering?.controller;
        if (controller && typeof controller.getContext === "function") {
          const ctx = controller.getContext();
          if (ctx) {
            return ctx;
          }
        }
        if (previewCtx) {
          return previewCtx;
        }
        if (!scratchMeasureCtx) {
          if (typeof OffscreenCanvas === "function") {
            try {
              scratchMeasureCanvas = new OffscreenCanvas(1, 1);
              scratchMeasureCtx = scratchMeasureCanvas.getContext("2d");
            } catch (error) {
              scratchMeasureCanvas = null;
              scratchMeasureCtx = null;
            }
          }
          if (!scratchMeasureCtx && typeof document !== "undefined") {
            scratchMeasureCanvas = document.createElement("canvas");
            scratchMeasureCtx = scratchMeasureCanvas.getContext("2d");
          }
        }
        return scratchMeasureCtx;
      }

      function findRegionLabelAnchor(region, halfWidth, halfHeight, bounds, width, height, regionMap) {
        if (!region || !Number.isFinite(halfWidth) || !Number.isFinite(halfHeight)) {
          return null;
        }
        const preferred = [];
        const visualAnchor = findRegionLabelAnchorPolylabel(
          region,
          halfWidth,
          halfHeight,
          bounds,
          width,
          height,
          regionMap
        );
        if (visualAnchor) {
          region._preferredLabelAnchors = null;
          return visualAnchor;
        }
        if (region._preferredLabelAnchors && Array.isArray(region._preferredLabelAnchors)) {
          preferred.push(...region._preferredLabelAnchors);
        }
        return findRegionLabelAnchorLegacy(
          region,
          halfWidth,
          halfHeight,
          bounds,
          width,
          height,
          regionMap,
          preferred
        );
      }

      function findRegionLabelAnchorPolylabel(
        region,
        halfWidth,
        halfHeight,
        bounds,
        width,
        height,
        regionMap
      ) {
        const polygon = ensureRegionLabelPolygon(region, width, height);
        if (!polygon) return null;
        const precision = resolvePolylabelPrecision(bounds);
        const visualCenter = ensureRegionVisualCenter(region, polygon, precision);
        if (!visualCenter) return null;
        const anchorX = clamp(
          visualCenter.x,
          bounds.minX + halfWidth,
          bounds.maxX + 1 - halfWidth
        );
        const anchorY = clamp(
          visualCenter.y,
          bounds.minY + halfHeight,
          bounds.maxY + 1 - halfHeight
        );
        if (
          rectangleFitsRegion(
            region.id,
            anchorX,
            anchorY,
            halfWidth,
            halfHeight,
            width,
            height,
            regionMap
          )
        ) {
          return { x: anchorX, y: anchorY };
        }
        const diagHalf = Math.sqrt(halfWidth * halfWidth + halfHeight * halfHeight);
        if (visualCenter.distance != null && visualCenter.distance >= diagHalf) {
          const epsilon = 1e-3;
          const adjustedX = clamp(
            visualCenter.x,
            bounds.minX + halfWidth + epsilon,
            bounds.maxX + 1 - halfWidth - epsilon
          );
          const adjustedY = clamp(
            visualCenter.y,
            bounds.minY + halfHeight + epsilon,
            bounds.maxY + 1 - halfHeight - epsilon
          );
          if (
            rectangleFitsRegion(
              region.id,
              adjustedX,
              adjustedY,
              halfWidth,
              halfHeight,
              width,
              height,
              regionMap
            )
          ) {
            return { x: adjustedX, y: adjustedY };
          }
        }
        region._preferredLabelAnchors = [
          {
            x: clamp(visualCenter.x, bounds.minX + halfWidth, bounds.maxX + 1 - halfWidth),
            y: clamp(visualCenter.y, bounds.minY + halfHeight, bounds.maxY + 1 - halfHeight),
            weight: 6,
          },
        ];
        return null;
      }

      function findRegionLabelAnchorLegacy(
        region,
        halfWidth,
        halfHeight,
        bounds,
        width,
        height,
        regionMap,
        preferredCandidates = []
      ) {
        const marginX = Math.max(0, Math.ceil(halfWidth - 0.5));
        const marginY = Math.max(0, Math.ceil(halfHeight - 0.5));
        const minCenterX = Math.max(bounds.minX + halfWidth, halfWidth);
        const maxCenterX = Math.min(bounds.maxX + 1 - halfWidth, width - halfWidth);
        const minCenterY = Math.max(bounds.minY + halfHeight, halfHeight);
        const maxCenterY = Math.min(bounds.maxY + 1 - halfHeight, height - halfHeight);
        if (minCenterX > maxCenterX || minCenterY > maxCenterY) return null;
        const centroidX = Number.isFinite(region.cx)
          ? region.cx
          : (bounds.minX + bounds.maxX + 1) / 2;
        const centroidY = Number.isFinite(region.cy)
          ? region.cy
          : (bounds.minY + bounds.maxY + 1) / 2;
        const seen = new Set();
        const candidates = [];
        const addCandidate = (x, y, weight = 1) => {
          const clampedX = clamp(x, minCenterX, maxCenterX);
          const clampedY = clamp(y, minCenterY, maxCenterY);
          const key = `${clampedX.toFixed(3)}:${clampedY.toFixed(3)}`;
          if (seen.has(key)) return;
          seen.add(key);
          candidates.push({ x: clampedX, y: clampedY, weight });
        };
        if (Array.isArray(preferredCandidates)) {
          for (const candidate of preferredCandidates) {
            if (!candidate || !Number.isFinite(candidate.x) || !Number.isFinite(candidate.y)) {
              continue;
            }
            addCandidate(candidate.x, candidate.y, candidate.weight ?? 4);
          }
        }
        addCandidate(centroidX, centroidY, 2);
        const minY = Math.max(bounds.minY + marginY, 0);
        const maxY = Math.min(bounds.maxY - marginY, height - 1);
        const startX = Math.max(bounds.minX, Math.floor(minCenterX - halfWidth));
        const endX = Math.min(bounds.maxX, Math.ceil(maxCenterX + halfWidth) - 1);
        for (let y = minY; y <= maxY; y++) {
          const rowOffset = y * width;
          let runStart = null;
          for (let x = startX; x <= endX; x++) {
            const belongs = regionMap[rowOffset + x] === region.id;
            if (belongs && runStart == null) {
              runStart = x;
            }
            const isRunEnd = !belongs || x === endX;
            if (runStart != null && isRunEnd) {
              const runEnd = belongs ? x : x - 1;
              const safeStart = Math.max(runStart, Math.floor(minCenterX - halfWidth));
              const safeEnd = Math.min(runEnd, Math.ceil(maxCenterX + halfWidth) - 1);
              if (safeStart <= safeEnd) {
                const runWidth = safeEnd - safeStart + 1;
                const rowY = y + 0.5;
                const centerX = safeStart + runWidth / 2;
                addCandidate(centerX, rowY, runWidth);
                if (runWidth > halfWidth * 2 + 1) {
                  const offset = Math.min(runWidth / 2 - 0.5, Math.max(1, halfWidth));
                  addCandidate(safeStart + 0.5 + offset, rowY, runWidth / 2);
                  addCandidate(safeEnd + 0.5 - offset, rowY, runWidth / 2);
                }
              }
              runStart = null;
            }
          }
        }
        if (candidates.length === 0) {
          for (let y = minY; y <= maxY; y++) {
            const rowOffset = y * width;
            for (let x = startX; x <= endX; x++) {
              if (regionMap[rowOffset + x] !== region.id) continue;
              addCandidate(x + 0.5, y + 0.5, 0.5);
            }
          }
        }
        candidates.sort((a, b) => {
          const aDist = (a.x - centroidX) * (a.x - centroidX) + (a.y - centroidY) * (a.y - centroidY);
          const bDist = (b.x - centroidX) * (b.x - centroidX) + (b.y - centroidY) * (b.y - centroidY);
          if (aDist === bDist) {
            return b.weight - a.weight;
          }
          return aDist - bDist;
        });
        let best = null;
        let bestScore = Number.POSITIVE_INFINITY;
        for (const candidate of candidates) {
          if (
            !rectangleFitsRegion(
              region.id,
              candidate.x,
              candidate.y,
              halfWidth,
              halfHeight,
              width,
              height,
              regionMap
            )
          ) {
            continue;
          }
          const dx = candidate.x - centroidX;
          const dy = candidate.y - centroidY;
          const slack = estimateAnchorSlack(
            region.id,
            candidate.x,
            candidate.y,
            halfWidth,
            halfHeight,
            width,
            height,
            regionMap
          );
          const score = dx * dx + dy * dy - slack * 4 - candidate.weight * 0.05;
          if (score < bestScore) {
            bestScore = score;
            best = { x: candidate.x, y: candidate.y };
            if (score <= 0) {
              break;
            }
          }
        }
        return best;
      }

      function resolvePolylabelPrecision(bounds) {
        if (!bounds || !Number.isFinite(bounds.width) || !Number.isFinite(bounds.height)) {
          return 0.25;
        }
        const largest = Math.max(1, bounds.width, bounds.height);
        const normalized = clamp(largest / 160, 0.05, 0.35);
        return normalized;
      }

      function ensureRegionVisualCenter(region, polygon, precision) {
        if (!Array.isArray(polygon) || polygon.length === 0) {
          return null;
        }
        const cachedPrecision = region?._labelVisualCenterPrecision;
        if (
          region &&
          region._labelVisualCenter &&
          cachedPrecision != null &&
          cachedPrecision <= precision + 1e-6
        ) {
          return region._labelVisualCenter;
        }
        const result = computeRegionPolylabel(polygon, precision);
        if (region) {
          region._labelVisualCenter = result || null;
          region._labelVisualCenterPrecision = precision;
        }
        return result;
      }

      function ensureRegionLabelPolygon(region, width, height) {
        if (
          !region ||
          !Array.isArray(region.pixels) ||
          region.pixels.length === 0 ||
          !Number.isFinite(width) ||
          width <= 0 ||
          !Number.isFinite(height) ||
          height <= 0
        ) {
          return null;
        }
        if (
          region._labelPolygon &&
          region._labelPolygonWidth === width &&
          region._labelPolygonHeight === height
        ) {
          return region._labelPolygon;
        }
        const polygon = buildRegionLabelPolygon(region, width, height);
        region._labelPolygon = polygon;
        region._labelPolygonWidth = width;
        region._labelPolygonHeight = height;
        region._labelVisualCenter = null;
        region._labelVisualCenterPrecision = null;
        region._preferredLabelAnchors = null;
        return polygon;
      }

      function buildRegionLabelPolygon(region, width, height) {
        const pixels = region.pixels;
        if (!Array.isArray(pixels) || pixels.length === 0) return null;
        const pixelSet = new Set(pixels);
        const edges = new Map();
        const addEdge = (sx, sy, ex, ey) => {
          const key = `${sx},${sy}`;
          const edge = { sx, sy, ex, ey };
          if (!edges.has(key)) edges.set(key, []);
          edges.get(key).push(edge);
        };
        const widthLimit = width;
        const heightLimit = height;
        for (const idx of pixels) {
          const x = idx % widthLimit;
          const y = (idx / widthLimit) | 0;
          const northIdx = idx - widthLimit;
          const southIdx = idx + widthLimit;
          const westIdx = idx - 1;
          const eastIdx = idx + 1;
          const hasNorth = y > 0 && pixelSet.has(northIdx);
          const hasSouth = y + 1 < heightLimit && pixelSet.has(southIdx);
          const hasWest = x > 0 && pixelSet.has(westIdx);
          const hasEast = x + 1 < widthLimit && pixelSet.has(eastIdx);
          if (!hasNorth) {
            addEdge(x + 1, y, x, y);
          }
          if (!hasWest) {
            addEdge(x, y, x, y + 1);
          }
          if (!hasSouth) {
            addEdge(x, y + 1, x + 1, y + 1);
          }
          if (!hasEast) {
            addEdge(x + 1, y + 1, x + 1, y);
          }
        }
        const loops = [];
        const takeEdge = (key) => {
          const bucket = edges.get(key);
          if (!bucket || bucket.length === 0) return null;
          const edge = bucket.pop();
          if (bucket.length === 0) {
            edges.delete(key);
          }
          return edge;
        };
        const maxSteps = pixels.length * 8 + 8;
        for (const startKey of Array.from(edges.keys())) {
          let edge = takeEdge(startKey);
          while (edge) {
            const loop = [];
            const originKey = `${edge.sx},${edge.sy}`;
            loop.push([edge.sx, edge.sy]);
            let current = edge;
            let guard = 0;
            while (current) {
              loop.push([current.ex, current.ey]);
              const nextKey = `${current.ex},${current.ey}`;
              if (nextKey === originKey) {
                break;
              }
              current = takeEdge(nextKey);
              guard += 1;
              if (guard > maxSteps) {
                loop.length = 0;
                break;
              }
            }
            if (loop.length >= 4 && pointsEqual(loop[0], loop[loop.length - 1])) {
              loops.push(loop);
            }
            edge = takeEdge(startKey);
          }
        }
        if (loops.length === 0) {
          return null;
        }
        let outerIndex = 0;
        let bestArea = -Infinity;
        for (let i = 0; i < loops.length; i++) {
          const area = Math.abs(polygonArea(loops[i]));
          if (area > bestArea) {
            bestArea = area;
            outerIndex = i;
          }
        }
        const polygon = [];
        const outerRing = normalizePolygonRing(loops[outerIndex], true);
        if (!outerRing || outerRing.length < 4) {
          return null;
        }
        polygon.push(outerRing);
        for (let i = 0; i < loops.length; i++) {
          if (i === outerIndex) continue;
          const holeRing = normalizePolygonRing(loops[i], false);
          if (holeRing && holeRing.length >= 4) {
            polygon.push(holeRing);
          }
        }
        return polygon;
      }

      function normalizePolygonRing(points, makeCounterClockwise) {
        if (!Array.isArray(points) || points.length === 0) {
          return [];
        }
        const normalized = [];
        for (let i = 0; i < points.length; i++) {
          const point = points[i];
          if (i > 0 && pointsEqual(point, points[i - 1])) continue;
          normalized.push([point[0], point[1]]);
        }
        if (normalized.length === 0) return normalized;
        if (!pointsEqual(normalized[0], normalized[normalized.length - 1])) {
          normalized.push([normalized[0][0], normalized[0][1]]);
        }
        if (normalized.length < 4) {
          return normalized;
        }
        const area = polygonArea(normalized);
        if (makeCounterClockwise) {
          if (area < 0) {
            normalized.reverse();
          }
        } else if (area > 0) {
          normalized.reverse();
        }
        return normalized;
      }

      function polygonArea(points) {
        if (!Array.isArray(points) || points.length < 3) {
          return 0;
        }
        let sum = 0;
        for (let i = 0; i < points.length - 1; i++) {
          const a = points[i];
          const b = points[i + 1];
          sum += a[0] * b[1] - b[0] * a[1];
        }
        return sum / 2;
      }

      function pointsEqual(a, b) {
        return (
          Array.isArray(a) &&
          Array.isArray(b) &&
          Math.abs(a[0] - b[0]) < 1e-6 &&
          Math.abs(a[1] - b[1]) < 1e-6
        );
      }

      function computeRegionPolylabel(polygon, precision = 0.25) {
        if (!Array.isArray(polygon) || polygon.length === 0) {
          return null;
        }
        const outer = polygon[0];
        if (!Array.isArray(outer) || outer.length < 4) {
          return null;
        }
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        for (let i = 0; i < outer.length; i++) {
          const [x, y] = outer[i];
          if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        }
        if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) {
          return null;
        }
        const width = maxX - minX;
        const height = maxY - minY;
        const normalizedPrecision = Math.max(precision, 1e-4);
        const cellSize = Math.max(normalizedPrecision, Math.min(width, height));
        if (!(cellSize > normalizedPrecision)) {
          const start = outer[0];
          const distance = pointToPolygonDistance(start[0], start[1], polygon);
          return { x: start[0], y: start[1], distance };
        }
        let bestCell = getCentroidPolylabelCell(polygon);
        const bboxCell = createPolylabelCell(minX + width / 2, minY + height / 2, 0, polygon);
        if (!bestCell || bestCell.d < 0) {
          bestCell = bboxCell;
        } else if (bboxCell && bboxCell.d > bestCell.d) {
          bestCell = bboxCell;
        }
        const queue = createPolylabelMaxHeap();
        const half = cellSize / 2;
        const enqueueCell = (cell) => {
          if (!cell) return;
          if (cell.d > bestCell.d) {
            bestCell = cell;
          }
          if (cell.max > bestCell.d + normalizedPrecision) {
            queue.push(cell);
          }
        };
        for (let x = minX; x < maxX; x += cellSize) {
          for (let y = minY; y < maxY; y += cellSize) {
            enqueueCell(createPolylabelCell(x + half, y + half, half, polygon));
          }
        }
        let iterations = 0;
        const maxIterations = 6000;
        while (!queue.isEmpty() && iterations < maxIterations) {
          const cell = queue.pop();
          if (!cell) break;
          if (cell.d > bestCell.d) {
            bestCell = cell;
          }
          if (cell.max - bestCell.d <= normalizedPrecision) {
            iterations += 1;
            continue;
          }
          const h = cell.h / 2;
          if (h <= 0) {
            iterations += 1;
            continue;
          }
          enqueueCell(createPolylabelCell(cell.x - h, cell.y - h, h, polygon));
          enqueueCell(createPolylabelCell(cell.x + h, cell.y - h, h, polygon));
          enqueueCell(createPolylabelCell(cell.x - h, cell.y + h, h, polygon));
          enqueueCell(createPolylabelCell(cell.x + h, cell.y + h, h, polygon));
          iterations += 1;
        }
        if (!bestCell) return null;
        return { x: bestCell.x, y: bestCell.y, distance: bestCell.d };
      }

      function createPolylabelCell(x, y, h, polygon) {
        if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(h)) return null;
        const d = pointToPolygonDistance(x, y, polygon);
        return {
          x,
          y,
          h,
          d,
          max: d + h * Math.SQRT2,
        };
      }

      function getCentroidPolylabelCell(polygon) {
        if (!Array.isArray(polygon) || polygon.length === 0) return null;
        const points = polygon[0];
        if (!Array.isArray(points) || points.length < 3) return null;
        let area = 0;
        let x = 0;
        let y = 0;
        for (let i = 0, len = points.length, j = len - 1; i < len; j = i++) {
          const a = points[i];
          const b = points[j];
          const f = a[0] * b[1] - b[0] * a[1];
          x += (a[0] + b[0]) * f;
          y += (a[1] + b[1]) * f;
          area += f * 3;
        }
        if (area === 0) {
          const first = points[0];
          return createPolylabelCell(first[0], first[1], 0, polygon);
        }
        const centroid = createPolylabelCell(x / area, y / area, 0, polygon);
        if (!centroid || centroid.d < 0) {
          const fallback = points[0];
          return createPolylabelCell(fallback[0], fallback[1], 0, polygon);
        }
        return centroid;
      }

      function pointToPolygonDistance(x, y, polygon) {
        let inside = false;
        let minDistSq = Infinity;
        for (const ring of polygon) {
          for (let i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
            const a = ring[i];
            const b = ring[j];
            if ((a[1] > y) !== (b[1] > y) && x < ((b[0] - a[0]) * (y - a[1])) / (b[1] - a[1]) + a[0]) {
              inside = !inside;
            }
            const distSq = pointToSegmentDistanceSquared(x, y, a, b);
            if (distSq < minDistSq) {
              minDistSq = distSq;
            }
          }
        }
        if (minDistSq === Infinity) {
          return 0;
        }
        if (minDistSq === 0) {
          return 0;
        }
        const distance = Math.sqrt(minDistSq);
        return inside ? distance : -distance;
      }

      function pointToSegmentDistanceSquared(px, py, a, b) {
        let x = a[0];
        let y = a[1];
        let dx = b[0] - x;
        let dy = b[1] - y;
        if (dx !== 0 || dy !== 0) {
          const t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);
          if (t > 1) {
            x = b[0];
            y = b[1];
          } else if (t > 0) {
            x += dx * t;
            y += dy * t;
          }
        }
        dx = px - x;
        dy = py - y;
        return dx * dx + dy * dy;
      }

      function createPolylabelMaxHeap() {
        const items = [];

        function isEmpty() {
          return items.length === 0;
        }

        function push(cell) {
          if (!cell) return;
          items.push(cell);
          siftUp(items.length - 1);
        }

        function pop() {
          if (items.length === 0) return null;
          const top = items[0];
          const last = items.pop();
          if (items.length > 0) {
            items[0] = last;
            siftDown(0);
          }
          return top;
        }

        function siftUp(index) {
          let i = index;
          while (i > 0) {
            const parent = (i - 1) >> 1;
            if (items[parent].max >= items[i].max) break;
            const tmp = items[parent];
            items[parent] = items[i];
            items[i] = tmp;
            i = parent;
          }
        }

        function siftDown(index) {
          let i = index;
          const length = items.length;
          while (true) {
            const left = i * 2 + 1;
            const right = left + 1;
            let largest = i;
            if (left < length && items[left].max > items[largest].max) {
              largest = left;
            }
            if (right < length && items[right].max > items[largest].max) {
              largest = right;
            }
            if (largest === i) break;
            const tmp = items[i];
            items[i] = items[largest];
            items[largest] = tmp;
            i = largest;
          }
        }

        return { isEmpty, push, pop };
      }

      function rectangleFitsRegion(regionId, centerX, centerY, halfWidth, halfHeight, width, height, regionMap) {
        const minX = Math.max(0, Math.floor(centerX - halfWidth));
        const maxX = Math.min(width - 1, Math.ceil(centerX + halfWidth));
        const minY = Math.max(0, Math.floor(centerY - halfHeight));
        const maxY = Math.min(height - 1, Math.ceil(centerY + halfHeight));
        for (let y = minY; y <= maxY; y++) {
          const rowOffset = y * width;
          for (let x = minX; x <= maxX; x++) {
            if (regionMap[rowOffset + x] !== regionId) {
              return false;
            }
          }
        }
        return true;
      }

      function estimateAnchorSlack(regionId, centerX, centerY, halfWidth, halfHeight, width, height, regionMap) {
        let slack = 0;
        const steps = [0.25, 0.5, 0.75, 1, 1.5, 2];
        for (const step of steps) {
          if (
            rectangleFitsRegion(
              regionId,
              centerX,
              centerY,
              halfWidth + step,
              halfHeight + step,
              width,
              height,
              regionMap
            )
          ) {
            slack = step;
          } else {
            break;
          }
        }
        return slack;
      }

      
      function scrollPaletteToColor(colorId) {
        if (!paletteEl) return;
        if (colorId == null) return;
        const swatch = paletteEl.querySelector(`.swatch[data-color-id="${colorId}"]`);
        if (!swatch) return;
        const scrollBehavior =
          prefersReducedMotionQuery && prefersReducedMotionQuery.matches ? "auto" : "smooth";
        try {
          swatch.scrollIntoView({
            block: "nearest",
            inline: "nearest",
            behavior: scrollBehavior,
          });
        } catch (error) {
          swatch.scrollIntoView();
        }
      }

      function activateColor(colorId, options = {}) {
        if (!state.puzzle) return false;
        if (colorId == null) return false;
        const { flash = true, redraw = true } = options;
        const hasColour = state.puzzle.palette.some((entry) => entry.id === colorId);
        if (!hasColour) return false;
        const changed = state.activeColor !== colorId;
        state.activeColor = colorId;
        if (redraw) {
          renderPalette();
        }
        scrollPaletteToColor(colorId);
        if (flash && isHintTypeEnabled("matchingRegions")) {
          flashColorRegions(colorId);
        }
        const remaining = getRegionsByColor(colorId, { includeFilled: false }).length;
        const suffix = remaining > 0 ? `${remaining} regions remaining` : "complete";
        if (changed) {
          scheduleAutosave("color-select");
        }
        logDebug(
          `${changed ? "Selected" : "Re-selected"} ${describeColour(colorId, { includeCompleted: true })} (${suffix})`
        );
        refreshCustomCursorHighlight();
        return changed;
      }

      function resolvePaletteSortMode() {
        const requested = typeof state.paletteSort === "string" ? state.paletteSort : "";
        const normalized = LEGACY_PALETTE_SORT_ALIASES.get(requested) || requested;
        if (ALLOWED_PALETTE_SORT_MODES.has(normalized)) {
          if (normalized !== requested) {
            state.paletteSort = normalized;
          }
          return normalized;
        }
        state.paletteSort = "region";
        return "region";
      }

      function getPaletteEntryOrder(options = {}) {
        const includeCompleted = options?.includeCompleted === true;
        const totalByColor = new Map();
        const remainingByColor = new Map();
        const nameCache = new Map();
        const toneCache = new Map();
        const getNameData = (color) => {
          if (!color) {
            return { text: "", sortKey: "" };
          }
          if (nameCache.has(color.id)) {
            return nameCache.get(color.id);
          }
          const text =
            (typeof color.name === "string" && color.name.trim()) ||
            (typeof color.hex === "string" ? color.hex.toUpperCase() : `Colour ${color.id}`);
          const entry = { text, sortKey: text.toLocaleLowerCase() };
          nameCache.set(color.id, entry);
          return entry;
        };
        const getToneData = (color) => {
          if (!color) {
            return {
              lightness: 0,
              chroma: 0,
              hue: 0,
              warmth: 0,
              isNeutral: true,
            };
          }
          if (toneCache.has(color.id)) {
            return toneCache.get(color.id);
          }
          const sourceHex = typeof color.hex === "string" ? color.hex : "#ffffff";
          const tone = oklchFromHex(sourceHex);
          const hueRadians = (tone.hue * Math.PI) / 180;
          const warmth = Math.cos(hueRadians - WARM_HUE_PIVOT_RADIANS) * tone.chroma;
          const entry = {
            lightness: tone.lightness,
            chroma: tone.chroma,
            hue: tone.hue,
            warmth,
            isNeutral: tone.chroma < 0.03,
          };
          toneCache.set(color.id, entry);
          return entry;
        };
        const sortMode = resolvePaletteSortMode();
        if (!state.puzzle) {
          return {
            entries: [],
            totalByColor,
            remainingByColor,
            sortMode,
            getNameData,
          };
        }
        for (const region of state.puzzle.regions) {
          const total = totalByColor.get(region.colorId) || 0;
          totalByColor.set(region.colorId, total + 1);
          if (!state.filled.has(region.id)) {
            const remaining = remainingByColor.get(region.colorId) || 0;
            remainingByColor.set(region.colorId, remaining + 1);
          }
        }
        const entries = state.puzzle.palette
          .filter((color) => includeCompleted || (remainingByColor.get(color.id) || 0) > 0)
          .slice();
        entries.sort((a, b) => {
          if (sortMode === "spectrum") {
            const aTone = getToneData(a);
            const bTone = getToneData(b);
            if (aTone.isNeutral !== bTone.isNeutral) {
              return aTone.isNeutral ? 1 : -1;
            }
            const hueDelta = aTone.hue - bTone.hue;
            if (Math.abs(hueDelta) > 0.0001) {
              return hueDelta;
            }
            const chromaDelta = bTone.chroma - aTone.chroma;
            if (Math.abs(chromaDelta) > 0.0001) {
              return chromaDelta;
            }
            const lightnessDelta = aTone.lightness - bTone.lightness;
            if (Math.abs(lightnessDelta) > 0.0001) {
              return lightnessDelta;
            }
            return a.id - b.id;
          }
          if (sortMode === "warmth") {
            const aTone = getToneData(a);
            const bTone = getToneData(b);
            if (aTone.isNeutral !== bTone.isNeutral) {
              return aTone.isNeutral ? 1 : -1;
            }
            const warmthDelta = bTone.warmth - aTone.warmth;
            if (Math.abs(warmthDelta) > 0.0001) {
              return warmthDelta;
            }
            const chromaDelta = bTone.chroma - aTone.chroma;
            if (Math.abs(chromaDelta) > 0.0001) {
              return chromaDelta;
            }
            const lightnessDelta = aTone.lightness - bTone.lightness;
            if (Math.abs(lightnessDelta) > 0.0001) {
              return lightnessDelta;
            }
            return a.id - b.id;
          }
          if (sortMode === "lightness") {
            const aTone = getToneData(a);
            const bTone = getToneData(b);
            const lightnessDelta = aTone.lightness - bTone.lightness;
            if (Math.abs(lightnessDelta) > 0.0001) {
              return lightnessDelta;
            }
            const chromaDelta = bTone.chroma - aTone.chroma;
            if (Math.abs(chromaDelta) > 0.0001) {
              return chromaDelta;
            }
            const hueDelta = aTone.hue - bTone.hue;
            if (Math.abs(hueDelta) > 0.0001) {
              return hueDelta;
            }
            return a.id - b.id;
          }
          if (sortMode === "remaining") {
            const remainingDelta =
              (remainingByColor.get(b.id) || 0) - (remainingByColor.get(a.id) || 0);
            if (remainingDelta !== 0) {
              return remainingDelta;
            }
            const totalDelta = (totalByColor.get(b.id) || 0) - (totalByColor.get(a.id) || 0);
            if (totalDelta !== 0) {
              return totalDelta;
            }
            return a.id - b.id;
          }
          if (sortMode === "name") {
            const aName = getNameData(a);
            const bName = getNameData(b);
            const nameDelta = aName.sortKey.localeCompare(bName.sortKey, undefined, {
              sensitivity: "base",
              numeric: true,
            });
            if (nameDelta !== 0) {
              return nameDelta;
            }
            return a.id - b.id;
          }
          return a.id - b.id;
        });
        return {
          entries,
          totalByColor,
          remainingByColor,
          sortMode,
          getNameData,
        };
      }

      function renderPalette() {
        if (!paletteEl) return;
        paletteEl.innerHTML = "";
        const displayNumbers = new Map();
        state.paletteDisplayNumbers = displayNumbers;
        if (!state.puzzle) {
          if (paletteSortEl) {
            paletteSortEl.disabled = true;
            const target = state.paletteSort || "region";
            if (paletteSortEl.value !== target) {
              paletteSortEl.value = target;
            }
          }
          return;
        }
        const {
          entries: paletteEntries,
          totalByColor,
          remainingByColor,
          sortMode,
          getNameData,
        } = getPaletteEntryOrder();
        if (paletteEntries.length === 0) {
          if (paletteSortEl) {
            paletteSortEl.disabled = true;
          }
          return;
        }
        if (paletteSortEl) {
          paletteSortEl.disabled = false;
          if (paletteSortEl.value !== sortMode) {
            paletteSortEl.value = sortMode;
          }
        }

        let displayIndex = 0;
        for (const color of paletteEntries) {
          const remaining = remainingByColor.get(color.id) || 0;
          if (remaining <= 0) {
            continue;
          }
          const total = totalByColor.get(color.id) || 0;
          const { text: rawLabelText } = getNameData(color);
          const regionWord = remaining === 1 ? "region" : "regions";
          const totalWord = total === 1 ? "region" : "regions";
          const tooltipText = `${remaining} ${regionWord} left`;
          const ariaSummary = `${remaining} of ${total} ${totalWord} remaining.`;
          const displayNumber = displayIndex + 1;
          const labelText =
            rawLabelText === `Colour ${color.id}` ? `Colour ${displayNumber}` : rawLabelText;
          displayNumbers.set(color.id, displayNumber);
          const swatch = document.createElement("button");
          swatch.type = "button";
          swatch.className = "swatch";
          swatch.dataset.testid = "palette-swatch";
          swatch.dataset.colorId = String(color.id);
          swatch.dataset.remaining = String(remaining);
          swatch.dataset.total = String(total);
          swatch.dataset.name = labelText;
          swatch.dataset.displayIndex = String(displayNumber);
          swatch.setAttribute("role", "listitem");
          swatch.setAttribute(
            "aria-label",
            `Colour ${displayNumber}: ${labelText}. ${ariaSummary}`
          );
          swatch.title = `${labelText} · ${tooltipText} (${total} total)`;
          if (state.activeColor === color.id) swatch.classList.add("active");
          swatch.style.setProperty("--swatch-color", color.hex || "transparent");
          const labelStyles = computeSwatchLabelStyles(color.hex);
          swatch.style.setProperty("--swatch-label-color", labelStyles.color);
          swatch.style.setProperty("--swatch-outline", labelStyles.outline);
          swatch.style.setProperty("--swatch-label-shadow", labelStyles.shadow);
          const label = document.createElement("span");
          label.className = "label";
          const number = document.createElement("strong");
          number.textContent = String(displayNumber);
          label.appendChild(number);
          swatch.appendChild(label);
          const tooltipId = `swatchTooltip-${color.id}`;
          const tooltip = document.createElement("span");
          tooltip.id = tooltipId;
          tooltip.className = "swatch-tooltip";
          tooltip.textContent = tooltipText;
          swatch.appendChild(tooltip);
          swatch.setAttribute("aria-describedby", tooltipId);
          swatch.addEventListener("click", () => {
            activateColor(color.id);
          });
          swatch.addEventListener("pointerdown", (event) => {
            if (event.button !== 2) {
              return;
            }
            event.preventDefault();
            activateColor(color.id);
          });
          swatch.addEventListener("contextmenu", (event) => {
            event.preventDefault();
            activateColor(color.id);
          });
          paletteEl.appendChild(swatch);
          displayIndex += 1;
        }
      }

      function getColorDisplayNumber(colorId, options = {}) {
        if (colorId == null) {
          return null;
        }
        const source =
          state?.paletteDisplayNumbers instanceof Map ? state.paletteDisplayNumbers : null;
        if (source && source.size > 0 && source.has(colorId)) {
          return source.get(colorId);
        }
        const { entries } = getPaletteEntryOrder(options);
        for (let index = 0; index < entries.length; index += 1) {
          const entry = entries[index];
          if (entry.id === colorId) {
            return index + 1;
          }
        }
        return null;
      }

      function describeColour(colorId, options = {}) {
        const displayNumber = getColorDisplayNumber(colorId, options);
        if (displayNumber != null && colorId != null) {
          return `colour ${displayNumber} (#${colorId})`;
        }
        if (displayNumber != null) {
          return `colour ${displayNumber}`;
        }
        if (colorId != null) {
          return `colour #${colorId}`;
        }
        return "colour";
      }

      function handlePaletteWheel(event) {
        if (!paletteEl) return;
        if (event.defaultPrevented) return;
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          return;
        }
        const { deltaX, deltaY, deltaMode } = event;
        if (Math.abs(deltaX) >= Math.abs(deltaY) || deltaY === 0) {
          return;
        }
        event.preventDefault();
        const WHEEL_DELTA_LINE = 1;
        const WHEEL_DELTA_PAGE = 2;
        let delta = deltaY;
        if (deltaMode === WHEEL_DELTA_LINE) {
          delta *= 24;
        } else if (deltaMode === WHEEL_DELTA_PAGE) {
          delta *= paletteEl.clientWidth;
        }
        paletteEl.scrollLeft += delta;
      }

      function updateGenerationProgress(progress, label) {
        if (!generatorProgressMeterEl || !generatorProgressBarEl) {
          return;
        }
        const hasProgress = typeof progress === "number" && Number.isFinite(progress);
        if (!hasProgress) {
          generatorProgressMeterEl.setAttribute("aria-hidden", "true");
          generatorProgressMeterEl.setAttribute("aria-valuenow", "0");
          generatorProgressMeterEl.setAttribute("aria-label", label || defaultProgressLabel);
          generatorProgressBarEl.style.width = "0%";
          return;
        }
        const clamped = Math.min(1, Math.max(0, progress));
        generatorProgressMeterEl.setAttribute("aria-hidden", "false");
        generatorProgressMeterEl.setAttribute("aria-valuenow", String(Math.round(clamped * 100)));
        generatorProgressMeterEl.setAttribute("aria-label", label || defaultProgressLabel);
        generatorProgressBarEl.style.width = `${(clamped * 100).toFixed(1)}%`;
        if (generatorProgressEl && generatorProgressEl.hidden && generatorProgressMessageEl?.textContent) {
          generatorProgressEl.hidden = false;
        }
      }

      function clearGenerationProgress() {
        if (!generatorProgressMeterEl || !generatorProgressBarEl) {
          return;
        }
        generatorProgressMeterEl.setAttribute("aria-hidden", "true");
        generatorProgressMeterEl.setAttribute("aria-valuenow", "0");
        generatorProgressMeterEl.setAttribute("aria-label", defaultProgressLabel);
        generatorProgressBarEl.style.width = "0%";
      }

      function beginGenerationJob() {
        generationJobCounter += 1;
        latestGenerationJobId = generationJobCounter;
        return generationJobCounter;
      }

      function isLatestGenerationJob(id) {
        return id === latestGenerationJobId;
      }

      function reportGenerationStage(jobId, progress, label) {
        if (!isLatestGenerationJob(jobId)) {
          return;
        }
        const safeLabel =
          typeof label === "string" && label.trim().length > 0
            ? label
            : PROGRESS_MESSAGES.generating;
        const hasProgress = typeof progress === "number" && Number.isFinite(progress);
        const normalized = hasProgress ? Math.min(1, Math.max(0, progress)) : null;
        const summary =
          hasProgress && normalized != null
            ? `${safeLabel} (${Math.round(normalized * 100)}%)`
            : safeLabel;
        setProgressMessage("generating", summary);
        if (hasProgress && normalized != null) {
          updateGenerationProgress(normalized, safeLabel);
        }
      }

      function setProgressMessage(status, customMessage) {
        const normalized = typeof status === "string" && status ? status : "idle";
        const shouldShow = normalized === "loading" || normalized === "generating" || normalized === "complete";
        const message = shouldShow
          ? typeof customMessage === "string" && customMessage.length > 0
            ? customMessage
            : PROGRESS_MESSAGES[normalized] || DEFAULT_PROGRESS_MESSAGE
          : "";
        if (generatorProgressMessageEl) {
          generatorProgressMessageEl.textContent = message;
          generatorProgressMessageEl.setAttribute("data-status", normalized);
        }
        if (generatorProgressEl) {
          generatorProgressEl.hidden = !shouldShow || message.length === 0;
          generatorProgressEl.setAttribute("data-status", normalized);
        }
        if (normalized !== "generating") {
          clearGenerationProgress();
        }
      }

      function updateProgress() {
        if (!state.puzzle) {
          setProgressMessage("idle");
          if (paletteSortEl) {
            paletteSortEl.disabled = true;
            const target = state.paletteSort || "region";
            if (paletteSortEl.value !== target) {
              paletteSortEl.value = target;
            }
          }
          return;
        }
        const total = state.puzzle.regions.length;
        const done = state.filled.size;
        if (!Number.isFinite(total) || total <= 0) {
          setProgressMessage("idle");
          return;
        }
        const remaining = Math.max(0, total - done);
        if (done >= total) {
          setProgressMessage("complete");
        } else {
          const summary = `${done} / ${total} filled · ${remaining} remaining`;
          setProgressMessage("active", summary);
        }
      }

      function updateMouseControlInputs() {
        const controls = getMouseControls();
        for (const button of MOUSE_BUTTON_KEYS) {
          const inputs = mouseControlInputs[button];
          if (!inputs) continue;
          const clickEl = inputs.click;
          const dragEl = inputs.drag;
          const buttonControls = controls[button];
          if (clickEl && buttonControls && clickEl.value !== buttonControls.click) {
            clickEl.value = buttonControls.click;
          }
          if (dragEl && buttonControls && dragEl.value !== buttonControls.drag) {
            dragEl.value = buttonControls.drag;
          }
        }
      }

      function applyMouseControls(next, options = {}) {
        const { skipLog = false, skipAutosave = true } = options;
        const previous = state.settings?.mouseControls
          ? normalizeMouseControls(state.settings.mouseControls, DEFAULT_MOUSE_CONTROLS)
          : cloneMouseControls(DEFAULT_MOUSE_CONTROLS);
        const normalizedSource =
          next && typeof next === "object"
            ? normalizeMouseControls(next, previous)
            : previous;
        const normalized = cloneMouseControls(normalizedSource);
        state.settings.mouseControls = normalized;
        updateMouseControlInputs();
        if (!skipLog) {
          const changes = [];
          for (const button of MOUSE_BUTTON_KEYS) {
            const prev = previous[button];
            const curr = normalized[button];
            if (prev.click !== curr.click) {
              changes.push(
                `${describeMouseButton(button)} click → ${describeMouseClickAction(curr.click)}`
              );
            }
            if (prev.drag !== curr.drag) {
              changes.push(
                `${describeMouseButton(button)} click + drag → ${describeMouseDragAction(curr.drag)}`
              );
            }
          }
          if (changes.length > 0) {
            logDebug(`Mouse controls updated: ${changes.join("; ")}`);
          }
        }
        if (!skipAutosave) {
          scheduleAutosave("settings-mouse-controls");
        }
      }

      function setMouseControl(button, type, rawValue) {
        if (!MOUSE_BUTTON_KEYS.includes(button)) {
          return;
        }
        const current = getMouseControls();
        const nextValue =
          type === "click"
            ? normalizeMouseClickAction(rawValue, current[button]?.click)
            : normalizeMouseDragAction(rawValue, current[button]?.drag);
        if (current[button] && current[button][type] === nextValue) {
          updateMouseControlInputs();
          return;
        }
        const nextControls = cloneMouseControls(current);
        if (!nextControls[button]) {
          const fallback = DEFAULT_MOUSE_CONTROLS[button] || DEFAULT_MOUSE_CONTROLS.left;
          nextControls[button] = { click: fallback.click, drag: fallback.drag };
        }
        nextControls[button][type] = nextValue;
        applyMouseControls(nextControls, { skipLog: true, skipAutosave: true });
        const actionLabel =
          type === "click" ? describeMouseClickAction(nextValue) : describeMouseDragAction(nextValue);
        logDebug(`${describeMouseButton(button)} ${type === "click" ? "click" : "click + drag"} set to ${actionLabel}`);
        scheduleAutosave("settings-mouse-controls");
      }

      function applyPaletteSort(sort, { skipLog } = {}) {
        const normalized = LEGACY_PALETTE_SORT_ALIASES.get(sort) || sort;
        const next = ALLOWED_PALETTE_SORT_MODES.has(normalized) ? normalized : "region";
        if (state.paletteSort === next) {
          if (paletteSortEl && paletteSortEl.value !== next) {
            paletteSortEl.value = next;
          }
          return;
        }
        state.paletteSort = next;
        if (paletteSortEl && paletteSortEl.value !== next) {
          paletteSortEl.value = next;
        }
        renderPalette();
        if (!skipLog) {
          const label =
            next === "spectrum"
              ? "rainbow spectrum"
              : next === "warmth"
              ? "warm to cool"
              : next === "lightness"
              ? "perceptual lightness"
              : next === "remaining"
              ? "remaining regions"
              : next === "name"
              ? "colour name"
              : "region number";
          logDebug(`Palette sorted by ${label}`);
        }
      }

      function handleKeyDown(event) {
        const target = event.target;
        if (event.ctrlKey || event.metaKey) {
          return;
        }
        if (
          target instanceof HTMLInputElement ||
          target instanceof HTMLTextAreaElement ||
          (target instanceof HTMLElement && target.isContentEditable)
        ) {
          return;
        }

        if (event.code === "Space") {
          if (!event.repeat) {
            spacePressed = true;
          }
          if (
            target === document.body ||
            target === viewportEl ||
            target === canvasStage ||
            target === canvasTransform ||
            target === puzzleCanvas
          ) {
            event.preventDefault();
          }
          return;
        }

        if (!state.puzzle) return;

        const key = event.key;
        if (key === "+" || key === "=" || event.code === "Equal" || event.code === "NumpadAdd") {
          event.preventDefault();
          applyZoom(1.1);
          return;
        }

        if (key === "-" || event.code === "Minus" || event.code === "NumpadSubtract") {
          event.preventDefault();
          applyZoom(0.9);
        }
      }

      function handleKeyUp(event) {
        if (event.code === "Space") {
          spacePressed = false;
        }
      }

      function defaultPanCaptureTarget() {
        return canvasStage || puzzleCanvas || viewportEl || document.body;
      }

      function resolvePanCaptureTarget(event, fallback) {
        if (event) {
          const current = event.currentTarget;
          if (current instanceof Element) {
            return current;
          }
          const target = event.target;
          if (target instanceof Element) {
            return target;
          }
        }
        return fallback || defaultPanCaptureTarget();
      }

      function attachGlobalPanListeners() {
        if (panGlobalListenersAttached) {
          return;
        }
        window.addEventListener("pointermove", handlePanMove, globalPanListenerOptions);
        window.addEventListener("pointerup", handlePanEnd, globalPanListenerOptions);
        window.addEventListener("pointercancel", handlePanEnd, globalPanListenerOptions);
        panGlobalListenersAttached = true;
      }

      function detachGlobalPanListeners() {
        if (!panGlobalListenersAttached) {
          return;
        }
        window.removeEventListener("pointermove", handlePanMove, globalPanListenerOptions);
        window.removeEventListener("pointerup", handlePanEnd, globalPanListenerOptions);
        window.removeEventListener("pointercancel", handlePanEnd, globalPanListenerOptions);
        panGlobalListenersAttached = false;
      }

      function handlePanCaptureLost(event) {
        if (event.pointerId !== panPointerId) {
          return;
        }
        panHasPointerCapture = false;
        if (!isPanning) {
          return;
        }
        logDebug("Pointer capture lost; maintaining pan via window listeners");
        attachGlobalPanListeners();
      }

      function handleMouseDragFill(event, session) {
        if (!session) return;
        session.lastX = event.clientX;
        session.lastY = event.clientY;
        const dx = event.clientX - session.startX;
        const dy = event.clientY - session.startY;
        const distance = Math.hypot(dx, dy);
        const threshold = 4;
        if (!session.dragStarted && distance >= threshold) {
          session.dragStarted = true;
          session.preventClick = true;
          suppressNextCanvasClickUntil = Date.now() + POINTER_CLICK_SUPPRESSION_MS;
        }
        if (!session.dragStarted) {
          return;
        }
        event.preventDefault();
        if (!state.puzzle || state.previewVisible) {
          return;
        }
        const hit = getRegionFromEvent(event);
        if (!hit) {
          session.lastRegionId = null;
          return;
        }
        if (session.lastRegionId === hit.regionId) {
          return;
        }
        session.lastRegionId = hit.regionId;
        attemptFillRegion(hit, { label: "drag" });
      }

      function handleMouseDragZoom(event, session) {
        if (!session) return;
        const previousY = session.lastY ?? session.startY;
        session.lastX = event.clientX;
        session.lastY = event.clientY;
        const dx = event.clientX - session.startX;
        const dy = event.clientY - session.startY;
        const distance = Math.hypot(dx, dy);
        const threshold = 4;
        if (!session.dragStarted && distance >= threshold) {
          session.dragStarted = true;
          session.preventClick = true;
          suppressNextCanvasClickUntil = Date.now() + POINTER_CLICK_SUPPRESSION_MS;
        }
        if (!session.dragStarted) {
          return;
        }
        event.preventDefault();
        const deltaY = event.clientY - previousY;
        if (!Number.isFinite(deltaY) || Math.abs(deltaY) < 0.5) {
          return;
        }
        const multiplier = Math.exp(-deltaY / 200);
        if (!Number.isFinite(multiplier) || Math.abs(multiplier - 1) < 0.001) {
          return;
        }
        applyZoom(multiplier, event.clientX, event.clientY, { skipLog: true });
        session.zoomChanged = true;
      }

      function finalizeMouseSession(session, event) {
        if (!session) return;
        pointerSessions.delete(session.pointerId);
        const now = Date.now();
        const buttonName = session.buttonName;
        if (session.dragAction === "fill" && session.dragStarted) {
          suppressNextCanvasClickUntil = now + POINTER_CLICK_SUPPRESSION_MS;
          return;
        }
        if (session.dragAction === "zoom" && session.dragStarted) {
          suppressNextCanvasClickUntil = now + POINTER_CLICK_SUPPRESSION_MS;
          if (session.zoomChanged) {
            const baseScale = viewState.baseScale > 0 ? viewState.baseScale : 1;
            const { minScale, maxScale } = getScaleBounds(baseScale);
            const currentZoom = normalizeZoomValue(viewState.zoom, 1);
            const currentScale = clamp(baseScale * currentZoom, minScale, maxScale);
            logDebug(
              `${describeMouseButton(buttonName)} drag zoom ended at ${(currentScale * 100).toFixed(0)}%`
            );
          }
          return;
        }
        if (session.dragAction === "pan" && (session.dragStarted || session.panActive)) {
          let panMoved = session.panMoved === true;
          if (!panMoved) {
            const lastX =
              typeof session.lastX === "number"
                ? session.lastX
                : typeof event?.clientX === "number"
                ? event.clientX
                : session.startX;
            const lastY =
              typeof session.lastY === "number"
                ? session.lastY
                : typeof event?.clientY === "number"
                ? event.clientY
                : session.startY;
            const deltaX = lastX - session.startX;
            const deltaY = lastY - session.startY;
            const distance = Math.hypot(deltaX, deltaY);
            const threshold = session.pointerType === "touch" ? 6 : 4;
            panMoved = distance >= threshold;
          }
          if (panMoved) {
            return;
          }
          if (buttonName === "left") {
            suppressNextCanvasClickUntil = now + POINTER_CLICK_SUPPRESSION_MS;
            return;
          }
        }
        const action = session.clickAction;
        if (action === "fill") {
          if (buttonName !== "left") {
            const hit = getRegionFromEvent(event);
            if (hit) {
              const result = attemptFillRegion(hit, { label: "click" });
              if (result !== "ignored") {
                suppressNextCanvasClickUntil = now + POINTER_CLICK_SUPPRESSION_MS;
              }
            }
          }
          return;
        }
        suppressNextCanvasClickUntil = now + POINTER_CLICK_SUPPRESSION_MS;
        if (action === "select") {
          const hit = getRegionFromEvent(event);
          if (hit && hit.region) {
            const remaining = getRegionsByColor(hit.region.colorId, { includeFilled: false });
            if (remaining.length > 0) {
              activateColor(hit.region.colorId);
            } else {
              logDebug(
                `${describeColour(hit.region.colorId, { includeCompleted: true })} already complete; ${describeMouseButton(buttonName)} click ignored`
              );
            }
          } else {
            logDebug("No region under pointer to select a colour");
          }
          return;
        }
        if (action === "select-fill") {
          const hit = getRegionFromEvent(event);
          if (!hit || !hit.region) {
            logDebug("No region under pointer to select and fill");
            return;
          }
          activateColor(hit.region.colorId, { flash: false });
          attemptFillRegion(hit, { label: "click" });
          return;
        }
        if (action === "zoom-in" || action === "zoom-out") {
          const multiplier = action === "zoom-in" ? 1.15 : 0.85;
          applyZoom(multiplier, event.clientX, event.clientY);
          return;
        }
      }

      function beginPanSession(
        pointerId,
        originX,
        originY,
        startPanX,
        startPanY,
        captureTarget,
        pointerType
      ) {
        const session = pointerSessions.get(pointerId);
        panPointerId = pointerId;
        panOrigin.x = originX;
        panOrigin.y = originY;
        panOrigin.panX = startPanX;
        panOrigin.panY = startPanY;
        panCandidate = null;
        isPanning = true;
        document.body.classList.add("panning");
        logDebug("Began panning view");
        hideCustomCursor();
        const fallbackTarget = defaultPanCaptureTarget();
        panCaptureTarget = captureTarget || fallbackTarget;
        panPointerType = typeof pointerType === "string" ? pointerType : null;
        if (session) {
          session.dragStarted = true;
          session.panActive = true;
          session.preventClick = true;
          session.panMoved = false;
        }
        let captured = false;
        if (panCaptureTarget && typeof panCaptureTarget.setPointerCapture === "function") {
          try {
            panCaptureTarget.setPointerCapture(pointerId);
            captured =
              typeof panCaptureTarget.hasPointerCapture === "function"
                ? panCaptureTarget.hasPointerCapture(pointerId)
                : true;
          } catch (error) {
            captured = false;
          }
        }
        panHasPointerCapture = captured;
        const pointerIsTouchLike = panPointerType === "touch" || panPointerType === "pen";
        const needsGlobalListeners = !captured || pointerIsTouchLike;
        if (needsGlobalListeners) {
          attachGlobalPanListeners();
        } else {
          detachGlobalPanListeners();
        }
      }

      function handlePanStart(event) {
        if (!state.puzzle) return;
        panCandidate = null;
        const captureTarget = resolvePanCaptureTarget(event);
        const isTouch = event.pointerType === "touch";
        if (isTouch) {
          event.preventDefault();
          hideCustomCursor();
          activeTouches.set(event.pointerId, { x: event.clientX, y: event.clientY });
          if (!pinchSession && activeTouches.size >= 2) {
            const entries = Array.from(activeTouches.entries()).slice(0, 2);
            const first = entries[0];
            const second = entries[1];
            if (first && second) {
              const a = first[1];
              const b = second[1];
              const distance = Math.max(10, Math.hypot(b.x - a.x, b.y - a.y));
              pinchSession = {
                ids: [first[0], second[0]],
                initialDistance: distance,
                initialZoom: viewState.zoom,
                initialPanX: viewState.panX,
                initialPanY: viewState.panY,
                centerX: (a.x + b.x) / 2,
                centerY: (a.y + b.y) / 2,
                lastCenterX: (a.x + b.x) / 2,
                lastCenterY: (a.y + b.y) / 2,
                hasChanged: false,
              };
              document.body.classList.add("panning");
              isPanning = true;
              logDebug("Pinch zoom started");
            }
          } else if (!pinchSession) {
            panCandidate = {
              pointerId: event.pointerId,
              startX: event.clientX,
              startY: event.clientY,
              panX: viewState.panX,
              panY: viewState.panY,
              pointerType: "touch",
              captureTarget,
            };
          }
          return;
        }
        const usesModifier = spacePressed || event.altKey || event.ctrlKey || event.metaKey;
        const pointerType = event.pointerType;
        if (pointerType !== "mouse" && pointerType !== "pen") {
          return;
        }
        pointerSessions.delete(event.pointerId);
        const buttonName = getMouseButtonName(event.button);
        const controls = getMouseControlsForButton(buttonName);
        let clickAction = controls.click;
        let dragAction = controls.drag;
        if (usesModifier) {
          dragAction = "pan";
          clickAction = "none";
        }
        const session = {
          pointerId: event.pointerId,
          pointerType,
          button: event.button,
          buttonName,
          clickAction,
          dragAction,
          startX: event.clientX,
          startY: event.clientY,
          lastX: event.clientX,
          lastY: event.clientY,
          captureTarget,
          dragStarted: false,
          panActive: false,
          zoomChanged: false,
          lastRegionId: null,
          panMoved: false,
        };
        pointerSessions.set(event.pointerId, session);
        if (dragAction === "pan") {
          session.panStartX = viewState.panX;
          session.panStartY = viewState.panY;
          const immediatePan = usesModifier || buttonName !== "left";
          if (immediatePan) {
            event.preventDefault();
            beginPanSession(
              event.pointerId,
              event.clientX,
              event.clientY,
              viewState.panX,
              viewState.panY,
              captureTarget,
              event.pointerType
            );
            return;
          }
          panCandidate = {
            pointerId: event.pointerId,
            startX: event.clientX,
            startY: event.clientY,
            panX: viewState.panX,
            panY: viewState.panY,
            pointerType: event.pointerType,
            captureTarget,
            session,
          };
          return;
        }
        if (dragAction === "fill") {
          session.lastRegionId = null;
          return;
        }
        if (dragAction === "zoom") {
          session.zoomStart = viewState.zoom;
          return;
        }
      }

      function handlePanMove(event) {
        const isTouch = event.pointerType === "touch";
        if (isTouch) {
          if (activeTouches.has(event.pointerId)) {
            activeTouches.set(event.pointerId, { x: event.clientX, y: event.clientY });
          }
          if (
            pinchSession &&
            pinchSession.ids.every((id) => activeTouches.has(id))
          ) {
            event.preventDefault();
            const [firstId, secondId] = pinchSession.ids;
            const first = activeTouches.get(firstId);
            const second = activeTouches.get(secondId);
            if (first && second) {
              const distance = Math.max(10, Math.hypot(second.x - first.x, second.y - first.y));
              const ratio = distance / pinchSession.initialDistance;
              const currentZoom = viewState.zoom;
              const targetZoom = normalizeZoomValue(
                pinchSession.initialZoom * ratio,
                pinchSession.initialZoom
              );
              if (Math.abs(targetZoom - currentZoom) > 0.0001) {
                pinchSession.hasChanged = true;
                const multiplier = targetZoom / currentZoom;
                const centerX = (first.x + second.x) / 2;
                const centerY = (first.y + second.y) / 2;
                applyZoom(multiplier, centerX, centerY, { skipLog: true, defer: true });
              }
              const centerX = (first.x + second.x) / 2;
              const centerY = (first.y + second.y) / 2;
              const previousCenterX =
                typeof pinchSession.lastCenterX === "number"
                  ? pinchSession.lastCenterX
                  : pinchSession.centerX;
              const previousCenterY =
                typeof pinchSession.lastCenterY === "number"
                  ? pinchSession.lastCenterY
                  : pinchSession.centerY;
              const deltaX = centerX - previousCenterX;
              const deltaY = centerY - previousCenterY;
              if (Math.abs(deltaX) > 0.0001 || Math.abs(deltaY) > 0.0001) {
                viewState.panX += deltaX;
                viewState.panY += deltaY;
                clampViewPanToPuzzleBounds();
                pinchSession.hasChanged = true;
                scheduleViewTransform({ skipSizing: true });
              }
              pinchSession.lastCenterX = centerX;
              pinchSession.lastCenterY = centerY;
            }
            return;
          }
        }
        const session = pointerSessions.get(event.pointerId);
        if (session && session.pointerType !== "touch") {
          if (session.dragAction === "fill") {
            handleMouseDragFill(event, session);
            return;
          }
          if (session.dragAction === "zoom") {
            handleMouseDragZoom(event, session);
            return;
          }
        }
        if (panPointerId === event.pointerId && isPanning) {
          event.preventDefault();
          const dx = event.clientX - panOrigin.x;
          const dy = event.clientY - panOrigin.y;
          viewState.panX = panOrigin.panX + dx;
          viewState.panY = panOrigin.panY + dy;
          clampViewPanToPuzzleBounds();
          if (session) {
            session.dragStarted = true;
            session.panActive = true;
            session.lastX = event.clientX;
            session.lastY = event.clientY;
            const deltaX = event.clientX - session.startX;
            const deltaY = event.clientY - session.startY;
            const distance = Math.hypot(deltaX, deltaY);
            const moveThreshold = session.pointerType === "touch" ? 6 : 4;
            if (distance >= moveThreshold) {
              session.panMoved = true;
            }
          }
          scheduleViewTransform({ skipSizing: true });
          return;
        }
        if (!panCandidate || panCandidate.pointerId !== event.pointerId) return;
        const dx = event.clientX - panCandidate.startX;
        const dy = event.clientY - panCandidate.startY;
        const distance = Math.hypot(dx, dy);
        const threshold = panCandidate.pointerType === "touch" ? 6 : 4;
        if (distance < threshold) return;
        event.preventDefault();
        beginPanSession(
          event.pointerId,
          panCandidate.startX,
          panCandidate.startY,
          panCandidate.panX,
          panCandidate.panY,
          panCandidate.captureTarget || resolvePanCaptureTarget(event, panCandidate.captureTarget),
          panCandidate.pointerType || event.pointerType
        );
        panCandidate = null;
        handlePanMove(event);
      }

      function handlePanEnd(event) {
        const session = pointerSessions.get(event.pointerId);
        if (event.pointerType === "touch") {
          activeTouches.delete(event.pointerId);
          if (pinchSession && !pinchSession.ids.every((id) => activeTouches.has(id))) {
            const changed = pinchSession.hasChanged;
            pinchSession = null;
            if (isPanning && panPointerId == null) {
              document.body.classList.remove("panning");
              isPanning = false;
            }
            if (changed) {
              logDebug(`Pinch zoom ended at ${(viewState.zoom * 100).toFixed(0)}%`);
            } else {
              logDebug("Pinch zoom ended");
            }
            if (activeTouches.size === 1) {
              const [nextId, point] = activeTouches.entries().next().value || [];
              if (nextId != null && point) {
                panCandidate = {
                  pointerId: nextId,
                  startX: point.x,
                  startY: point.y,
                  panX: viewState.panX,
                  panY: viewState.panY,
                  pointerType: "touch",
                  captureTarget: pointerSurface || defaultPanCaptureTarget(),
                };
              }
            }
          }
        }
        if (panCandidate && panCandidate.pointerId === event.pointerId) {
          panCandidate = null;
        }
        if (event.pointerId !== panPointerId) {
          if (session && session.pointerType !== "touch") {
            finalizeMouseSession(session, event);
          }
          return;
        }
        panPointerId = null;
        panPointerType = null;
        if (isPanning) {
          isPanning = false;
          document.body.classList.remove("panning");
          logDebug("Stopped panning view");
        }
        if (
          panCaptureTarget &&
          panHasPointerCapture &&
          typeof panCaptureTarget.releasePointerCapture === "function"
        ) {
          try {
            panCaptureTarget.releasePointerCapture(event.pointerId);
          } catch (error) {}
        }
        panCaptureTarget = null;
        panHasPointerCapture = false;
        detachGlobalPanListeners();
        if (session && session.pointerType !== "touch") {
          finalizeMouseSession(session, event);
        }
        if (event.pointerType === "touch") {
          hideCustomCursor();
        } else {
          updateCustomCursor(event);
        }
      }

      function hideCustomCursor() {
        if (!cursorOverlay) return;
        cursorOverlay.classList.remove("active", "matching", "mismatch", "filled");
        cursorOverlay.style.setProperty("--cursor-x", "-9999px");
        cursorOverlay.style.setProperty("--cursor-y", "-9999px");
        cursorOverlay.style.removeProperty("--cursor-ring");
        cursorOverlay.style.removeProperty("--cursor-fill");
        cursorOverlay.style.removeProperty("--cursor-swatch");
        if (cursorNumberEl) {
          cursorNumberEl.textContent = "";
          cursorNumberEl.style.removeProperty("color");
        }
        cursorHoverRegionId = null;
        cursorLastClientX = null;
        cursorLastClientY = null;
      }

      function applyCustomCursor(region, paletteColor, clientX, clientY) {
        if (!cursorOverlay) return;
        const hasPoint = typeof clientX === "number" && typeof clientY === "number";
        if (hasPoint) {
          cursorLastClientX = clientX;
          cursorLastClientY = clientY;
        }
        cursorHoverRegionId = region.id;
        if (!document.body.classList.contains("custom-cursor")) {
          return;
        }
        if (cursorLastClientX == null || cursorLastClientY == null) {
          return;
        }
        cursorOverlay.style.setProperty("--cursor-x", `${cursorLastClientX}px`);
        cursorOverlay.style.setProperty("--cursor-y", `${cursorLastClientY}px`);
        const colorId = paletteColor?.id ?? region.colorId;
        if (cursorNumberEl) {
          cursorNumberEl.textContent = String(colorId);
          const pointerNumberColor =
            paletteColor?.hex != null ? computePointerNumberColor(paletteColor.hex) : null;
          if (pointerNumberColor) {
            cursorNumberEl.style.color = pointerNumberColor;
          } else {
            cursorNumberEl.style.removeProperty("color");
          }
        }
        const fillTint = paletteColor?.hex ? rgbaFromHex(paletteColor.hex, 0.3) : "rgba(148, 163, 184, 0.3)";
        const ringTint = paletteColor?.hex ? rgbaFromHex(paletteColor.hex, 0.85) : "rgba(226, 232, 240, 0.95)";
        cursorOverlay.style.setProperty("--cursor-fill", fillTint);
        cursorOverlay.style.setProperty("--cursor-ring", ringTint);
        cursorOverlay.style.setProperty("--cursor-swatch", paletteColor?.hex || "transparent");
        const isFilled = state.filled.has(region.id);
        const matchesActive =
          !isFilled && state.activeColor != null && state.activeColor === region.colorId;
        const mismatchActive =
          !isFilled && state.activeColor != null && state.activeColor !== region.colorId;
        cursorOverlay.classList.toggle("filled", isFilled);
        cursorOverlay.classList.toggle("matching", matchesActive);
        cursorOverlay.classList.toggle("mismatch", mismatchActive);
        cursorOverlay.classList.add("active");
      }

      function updateCustomCursor(event) {
        if (!cursorOverlay || !puzzleCanvas) return;
        if (!state.puzzle || state.previewVisible) {
          hideCustomCursor();
          return;
        }
        if (event && event.pointerType === "touch") {
          hideCustomCursor();
          return;
        }
        if (isPanning) {
          return;
        }
        const rect = getPuzzleCanvasRect();
        if (!rect || rect.width <= 0 || rect.height <= 0) {
          hideCustomCursor();
          return;
        }
        const withinX = event.clientX >= rect.left && event.clientX <= rect.right;
        const withinY = event.clientY >= rect.top && event.clientY <= rect.bottom;
        if (!withinX || !withinY) {
          hideCustomCursor();
          return;
        }
        const scaleX = state.puzzle.width / rect.width;
        const scaleY = state.puzzle.height / rect.height;
        const x = Math.floor((event.clientX - rect.left) * scaleX);
        const y = Math.floor((event.clientY - rect.top) * scaleY);
        if (x < 0 || y < 0 || x >= state.puzzle.width || y >= state.puzzle.height) {
          hideCustomCursor();
          return;
        }
        const idx = y * state.puzzle.width + x;
        const regionId = state.puzzle.regionMap[idx];
        const region = state.puzzle.regions[regionId];
        if (!region) {
          hideCustomCursor();
          return;
        }
        const paletteColor = getPaletteEntry(region.colorId);
        applyCustomCursor(region, paletteColor, event.clientX, event.clientY);
        maybeShowRegionHint(region, paletteColor, {
          trigger: event.type === "pointerdown" ? "press" : "hover",
        });
      }

      function refreshCustomCursorHighlight() {
        if (!cursorOverlay) return;
        if (cursorHoverRegionId == null) return;
        if (!state.puzzle) {
          hideCustomCursor();
          return;
        }
        const region = state.puzzle.regions[cursorHoverRegionId];
        if (!region) {
          hideCustomCursor();
          return;
        }
        const paletteColor = getPaletteEntry(region.colorId);
        applyCustomCursor(region, paletteColor);
      }

      function setupCustomCursorPreference() {
        if (!cursorOverlay) return;
        if (typeof window === "undefined") return;
        const applyPreference = (matches) => {
          if (matches) {
            document.body.classList.add("custom-cursor");
            refreshCustomCursorHighlight();
          } else {
            document.body.classList.remove("custom-cursor");
            hideCustomCursor();
          }
        };
        if (!window.matchMedia) {
          applyPreference(true);
          return;
        }
        const pointerQuery = window.matchMedia("(pointer: fine)");
        applyPreference(pointerQuery.matches);
        const listener = (event) => applyPreference(event.matches);
        if (typeof pointerQuery.addEventListener === "function") {
          pointerQuery.addEventListener("change", listener);
        } else if (typeof pointerQuery.addListener === "function") {
          pointerQuery.addListener(listener);
        }
      }

      function normalizeZoomValue(value, fallback = MIN_VIEWPORT_ZOOM) {
        if (!Number.isFinite(value) || value <= 0) {
          return clamp(fallback, MIN_VIEWPORT_ZOOM, MAX_VIEWPORT_ZOOM);
        }
        return clamp(value, MIN_VIEWPORT_ZOOM, MAX_VIEWPORT_ZOOM);
      }

      function getScaleBounds(baseScale = 1) {
        const safeBase = Number.isFinite(baseScale) && baseScale > 0 ? baseScale : 1;
        const minScale = clamp(safeBase * MIN_VIEWPORT_ZOOM, MIN_RENDER_SCALE, MAX_RENDER_SCALE);
        const maxScale = clamp(safeBase * MAX_VIEWPORT_ZOOM, MIN_RENDER_SCALE, MAX_RENDER_SCALE);
        return { minScale, maxScale };
      }

      function applyZoom(multiplier, clientX, clientY, options = {}) {
        if (!state.puzzle) return;
        const baseScale = viewState.baseScale > 0 ? viewState.baseScale : 1;
        const { minScale, maxScale } = getScaleBounds(baseScale);
        const currentZoom = normalizeZoomValue(viewState.zoom > 0 ? viewState.zoom : 1, 1);
        const currentScale = clamp(baseScale * currentZoom, minScale, maxScale);
        const targetScale = clamp(currentScale * multiplier, minScale, maxScale);
        const change = targetScale / currentScale;
        if (!Number.isFinite(change) || Math.abs(change - 1) < 0.00001) return;
        const viewportRect = viewportEl.getBoundingClientRect();
        const centerX = viewportRect.left + viewportRect.width / 2;
        const centerY = viewportRect.top + viewportRect.height / 2;
        const anchorX = typeof clientX === "number" ? clientX : centerX;
        const anchorY = typeof clientY === "number" ? clientY : centerY;
        const offsetX = anchorX - centerX - viewState.panX;
        const offsetY = anchorY - centerY - viewState.panY;
        viewState.panX += offsetX - offsetX * change;
        viewState.panY += offsetY - offsetY * change;
        clampViewPanToPuzzleBounds();
        const nextZoom = normalizeZoomValue(targetScale / baseScale, currentZoom);
        const significant = Math.abs(targetScale - currentScale) >= Math.max(0.01, currentScale * 0.001);
        viewState.zoom = nextZoom;
        if (options.defer) {
          scheduleViewTransform({ forceRender: true });
        } else {
          applyViewTransform({ forceRender: true });
        }
        if (significant && !options.skipLog) {
          logDebug(`Zoom set to ${(targetScale * 100).toFixed(0)}%`);
        }
      }

      function handleWheel(event) {
        if (!state.puzzle) return;
        event.preventDefault();
        let deltaY = event.deltaY;
        if (!Number.isFinite(deltaY) || deltaY === 0) {
          return;
        }
        if (event.deltaMode === 1) {
          deltaY *= WHEEL_LINE_HEIGHT;
        } else if (event.deltaMode === 2) {
          const viewportHeight = viewportEl?.clientHeight || WHEEL_PAGE_HEIGHT;
          deltaY *= viewportHeight;
        }
        const step = clamp(deltaY / 120, -WHEEL_ZOOM_MAX_STEP, WHEEL_ZOOM_MAX_STEP);
        if (Math.abs(step) < 0.001) {
          return;
        }
        const multiplier = Math.pow(WHEEL_ZOOM_BASE, -step);
        if (!Number.isFinite(multiplier) || Math.abs(multiplier - 1) < 0.001) {
          return;
        }
        applyZoom(multiplier, event.clientX, event.clientY);
      }

      function applyViewTransform(options = {}) {
        const { forceRender = false, skipSizing = false } = options;
        if (viewTransformFrame != null && typeof cancelViewTransformFrame === "function") {
          cancelViewTransformFrame(viewTransformFrame);
          viewTransformFrame = null;
          cancelViewTransformFrame = null;
          pendingViewTransform = null;
        }
        clampViewPanToPuzzleBounds();
        if (canvasStage) {
          canvasStage.style.setProperty("--pan-x", `${viewState.panX}px`);
          canvasStage.style.setProperty("--pan-y", `${viewState.panY}px`);
        }
        invalidateCanvasRect();
        if (!state.puzzle) {
          return;
        }
        const metricsChanged = skipSizing ? false : applyCanvasSizing();
        if (metricsChanged || forceRender) {
          ensureRenderCache();
          renderPuzzle();
        }
      }

      function scheduleViewTransform(options = {}) {
        const { forceRender = false, skipSizing = false } = options;
        if (!pendingViewTransform) {
          pendingViewTransform = { forceRender: false, skipSizing: true };
        }
        if (forceRender) {
          pendingViewTransform.forceRender = true;
        }
        if (!skipSizing) {
          pendingViewTransform.skipSizing = false;
        }
        if (viewTransformFrame != null) {
          return;
        }
        const hasWindow = typeof window !== "undefined";
        const canRaf = hasWindow && typeof window.requestAnimationFrame === "function";
        if (canRaf) {
          cancelViewTransformFrame = (id) => {
            if (typeof window.cancelAnimationFrame === "function") {
              window.cancelAnimationFrame(id);
            }
          };
          viewTransformFrame = window.requestAnimationFrame(() => {
            viewTransformFrame = null;
            cancelViewTransformFrame = null;
            const payload = pendingViewTransform;
            pendingViewTransform = null;
            applyViewTransform(payload || {});
          });
        } else {
          cancelViewTransformFrame = (id) => clearTimeout(id);
          viewTransformFrame = setTimeout(() => {
            viewTransformFrame = null;
            cancelViewTransformFrame = null;
            const payload = pendingViewTransform;
            pendingViewTransform = null;
            applyViewTransform(payload || {});
          }, 16);
        }
      }

      function computeFitScale() {
        if (!state.puzzle) return 1;
        const styles = window.getComputedStyle(viewportEl);
        const paddingX =
          parseFloat(styles.paddingLeft || "0") + parseFloat(styles.paddingRight || "0");
        const paddingY =
          parseFloat(styles.paddingTop || "0") + parseFloat(styles.paddingBottom || "0");
        const availableWidth = Math.max(1, viewportEl.clientWidth - paddingX);
        const availableHeight = Math.max(1, viewportEl.clientHeight - paddingY);
        const widthScale = availableWidth / state.puzzle.width;
        const heightScale = availableHeight / state.puzzle.height;
        const fit = Math.min(widthScale, heightScale);
        if (!Number.isFinite(fit) || fit <= 0) {
          return 1;
        }
        return fit;
      }

      function resetView(options = {}) {
        const { preserveZoom = false, recenter = false } = options;
        if (!state.puzzle) {
          viewState.panX = 0;
          viewState.panY = 0;
          viewState.zoom = 1;
          viewState.baseScale = 1;
          applyViewTransform();
          return;
        }
        const nextBase = computeFitScale();
        const previousBase = viewState.baseScale > 0 ? viewState.baseScale : 1;
        const { minScale: prevMinScale, maxScale: prevMaxScale } = getScaleBounds(previousBase);
        const currentZoom = normalizeZoomValue(Math.max(viewState.zoom, MIN_VIEWPORT_ZOOM), 1);
        const currentScale = clamp(previousBase * currentZoom, prevMinScale, prevMaxScale);
        if (preserveZoom) {
          const ratio = Number.isFinite(previousBase) && previousBase > 0 ? nextBase / previousBase : 1;
          if (Number.isFinite(ratio)) {
            viewState.panX *= ratio;
            viewState.panY *= ratio;
          }
          const safeNextBase = nextBase > 0 ? nextBase : 1;
          const { minScale: nextMinScale, maxScale: nextMaxScale } = getScaleBounds(safeNextBase);
          const targetScale = clamp(currentScale, nextMinScale, nextMaxScale);
          const targetZoom = safeNextBase > 0 ? targetScale / safeNextBase : 1;
          viewState.zoom = normalizeZoomValue(targetZoom, viewState.zoom);
          if (recenter) {
            viewState.panX = 0;
            viewState.panY = 0;
          }
        } else {
          viewState.panX = 0;
          viewState.panY = 0;
          viewState.zoom = normalizeZoomValue(1);
        }
        viewState.baseScale = nextBase;
        clampViewPanToPuzzleBounds();
        applyViewTransform();
      }

      function restoreViewport(viewport = {}) {
        if (!state.puzzle) return false;
        if (!viewport || typeof viewport !== "object") return false;
        const hasZoom = typeof viewport.zoom === "number";
        const hasBase = typeof viewport.baseScale === "number";
        const hasPanX = typeof viewport.panX === "number";
        const hasPanY = typeof viewport.panY === "number";
        if (!hasZoom && !hasBase && !hasPanX && !hasPanY) return false;
        const nextBase = computeFitScale();
        const savedBase = hasBase && Number.isFinite(viewport.baseScale) && viewport.baseScale > 0
          ? viewport.baseScale
          : nextBase;
        const scaleRatio =
          savedBase && Number.isFinite(savedBase) && nextBase > 0 ? nextBase / savedBase : 1;
        const savedZoom = hasZoom && Number.isFinite(viewport.zoom) && viewport.zoom > 0
          ? viewport.zoom
          : 1;
        const targetZoom = Number.isFinite(scaleRatio) && scaleRatio > 0 ? savedZoom * scaleRatio : savedZoom;
        viewState.baseScale = nextBase;
        viewState.zoom = normalizeZoomValue(targetZoom, savedZoom);
        viewState.panX = hasPanX && Number.isFinite(viewport.panX) ? viewport.panX * scaleRatio : 0;
        viewState.panY = hasPanY && Number.isFinite(viewport.panY) ? viewport.panY * scaleRatio : 0;
        clampViewPanToPuzzleBounds();
        applyViewTransform();
        return true;
      }

      function useHint() {
        if (!state.puzzle) return;
        const candidates = state.puzzle.regions.filter((region) => !state.filled.has(region.id));
        if (candidates.length === 0) {
          logDebug("Hint requested, but puzzle is complete");
          return;
        }
        let target = candidates
          .filter((region) => region.colorId === state.activeColor)
          .sort((a, b) => a.pixelCount - b.pixelCount)[0];
        if (!target) {
          target = candidates.sort((a, b) => a.pixelCount - b.pixelCount)[0];
          activateColor(target.colorId, { flash: false });
        }
        if (state.settings.animateHints) {
          const paletteColor = getPaletteEntry(target.colorId);
          flashRegion(target.id, { paletteColor });
          if (isHintTypeEnabled("matchingRegions")) {
            flashColorRegions(target.colorId, { paletteColor, onlyUnfilled: true });
          }
        }
        logDebug(
          `Hint spotlighted region ${target.id} (${describeColour(target.colorId, { includeCompleted: true })})`
        );
      }

      function flashColorRegions(colorId, options = {}) {
        if (!state.puzzle) return;
        if (colorId == null) return;
        if (!isHintTypeEnabled("matchingRegions") && !options.force) return;
        const includeFilled = options.onlyUnfilled ? false : true;
        const targets = getRegionsByColor(colorId, { includeFilled });
        if (targets.length === 0) {
          overlayAnimations.delete(`color:${colorId}:${includeFilled ? "all" : "remaining"}`);
          if (overlayAnimations.size === 0) {
            renderPuzzle();
          }
          return;
        }
        const paletteColor = options.paletteColor || getPaletteEntry(colorId);
        const duration = normalizeHintFadeDuration(
          typeof options.duration === "number" ? options.duration : state.settings.hintFadeDuration
        );
        const alpha = normalizeHintIntensity(
          typeof options.alpha === "number" ? options.alpha : state.settings.hintIntensity
        );
        const fallbackRgb = options.tint ? parseTintToRgb(options.tint) : null;
        queueOverlayAnimation(
          `color:${colorId}:${includeFilled ? "all" : "remaining"}`,
          targets.map((region) => region.id),
          {
            paletteColor,
            fallbackRgb,
            baseAlpha: alpha,
            duration,
            includeFilled,
          }
        );
      }

      function flashRegion(regionId, options = {}) {
        if (!state.puzzle) return;
        const region = state.puzzle.regions[regionId];
        if (!region) return;
        const paletteColor = options.paletteColor || getPaletteEntry(region.colorId);
        const duration = normalizeHintFadeDuration(
          typeof options.duration === "number" ? options.duration : state.settings.hintFadeDuration
        );
        const alpha = normalizeHintIntensity(
          typeof options.alpha === "number" ? options.alpha : state.settings.hintIntensity
        );
        const fallbackRgb = options.tint ? parseTintToRgb(options.tint) : null;
        queueOverlayAnimation(`region:${regionId}`, [regionId], {
          paletteColor,
          fallbackRgb,
          baseAlpha: alpha,
          duration,
          includeFilled: options.includeFilled !== false,
        });
      }

      function queueOverlayAnimation(key, regionIds, options = {}) {
        if (!state.puzzle) return;
        if (!Array.isArray(regionIds) || regionIds.length === 0) return;
        const ids = regionIds
          .map((id) => Number(id))
          .filter((id) => Number.isFinite(id) && id >= 0);
        if (ids.length === 0) return;
        const includeFilled = options.includeFilled !== false;
        const baseAlpha = clamp(
          typeof options.baseAlpha === "number" ? options.baseAlpha : state.settings.hintIntensity ?? DEFAULT_HINT_INTENSITY,
          MIN_HINT_INTENSITY,
          MAX_HINT_INTENSITY
        );
        const duration = normalizeHintFadeDuration(options.duration);
        overlayAnimations.set(key, {
          regionIds: ids,
          includeFilled,
          paletteColor: options.paletteColor || null,
          fallbackRgb: Array.isArray(options.fallbackRgb) ? options.fallbackRgb : null,
          baseAlpha,
          duration,
          start: getNow(),
          power: typeof options.power === "number" && options.power > 0 ? options.power : 2,
        });
        scheduleOverlayFrame();
      }

      function scheduleOverlayFrame() {
        if (overlayAnimations.size === 0) {
          return;
        }
        if (overlayAnimationFrame != null || overlayAnimationTimeout != null) {
          return;
        }
        if (typeof window?.requestAnimationFrame === "function") {
          overlayAnimationFrame = window.requestAnimationFrame(stepOverlayAnimations);
        } else {
          overlayAnimationTimeout = window.setTimeout(() => {
            overlayAnimationTimeout = null;
            stepOverlayAnimations(getNow());
          }, 16);
        }
      }

      function stepOverlayAnimations(timestamp) {
        if (overlayAnimationFrame != null && typeof window?.cancelAnimationFrame === "function") {
          window.cancelAnimationFrame(overlayAnimationFrame);
        }
        overlayAnimationFrame = null;
        if (overlayAnimationTimeout != null) {
          clearTimeout(overlayAnimationTimeout);
          overlayAnimationTimeout = null;
        }
        if (!state.puzzle || overlayAnimations.size === 0) {
          renderPuzzle();
          return;
        }
        const now = typeof timestamp === "number" && Number.isFinite(timestamp) ? timestamp : getNow();
        const overlaysByTint = new Map();
        overlayAnimations.forEach((animation, key) => {
          const duration = animation.duration <= 0 ? MIN_HINT_FADE_DURATION : animation.duration;
          const elapsed = now - animation.start;
          const progress = clamp(duration > 0 ? elapsed / duration : 1, 0, 1);
          if (progress >= 1) {
            overlayAnimations.delete(key);
            return;
          }
          const strength = Math.pow(1 - progress, animation.power || 2);
          if (strength <= 0.0001) {
            overlayAnimations.delete(key);
            return;
          }
          const alpha = clamp(animation.baseAlpha * strength, 0.01, 1);
          const tint = resolveOverlayTint(animation.paletteColor, animation.fallbackRgb, alpha);
          if (!tint) {
            overlayAnimations.delete(key);
            return;
          }
          const regions = [];
          for (const regionId of animation.regionIds) {
            const region = state.puzzle.regions[regionId];
            if (!region) continue;
            if (!animation.includeFilled && state.filled.has(regionId)) {
              continue;
            }
            regions.push(region);
          }
          if (regions.length === 0) {
            overlayAnimations.delete(key);
            return;
          }
          if (overlaysByTint.has(tint)) {
            overlaysByTint.get(tint).push(...regions);
          } else {
            overlaysByTint.set(tint, regions.slice());
          }
        });
        renderPuzzle();
        overlaysByTint.forEach((regions, tint) => {
          paintRegions(regions, tint);
        });
        if (overlayAnimations.size > 0) {
          scheduleOverlayFrame();
        }
      }

      function resolveOverlayTint(paletteColor, fallbackRgb, alpha) {
        const normalizedAlpha = clamp(alpha, 0, 1);
        if (paletteColor) {
          if (Array.isArray(paletteColor.rgba) && paletteColor.rgba.length >= 3) {
            const [r, g, b] = paletteColor.rgba;
            return `rgba(${clamp(Math.round(r), 0, 255)}, ${clamp(Math.round(g), 0, 255)}, ${clamp(Math.round(b), 0, 255)}, ${normalizedAlpha})`;
          }
          if (typeof paletteColor.hex === "string" && paletteColor.hex) {
            return rgbaFromHex(paletteColor.hex, normalizedAlpha);
          }
        }
        const rgb = Array.isArray(fallbackRgb) && fallbackRgb.length >= 3 ? fallbackRgb : [96, 165, 250];
        const [r, g, b] = rgb.map((value) => clamp(Math.round(value), 0, 255));
        return `rgba(${r}, ${g}, ${b}, ${normalizedAlpha})`;
      }

      function parseTintToRgb(value) {
        if (typeof value !== "string") return null;
        const match = value.match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/i);
        if (!match) return null;
        return match.slice(1, 4).map((component) => clamp(Number(component) || 0, 0, 255));
      }

      function getNow() {
        if (typeof performance !== "undefined" && typeof performance.now === "function") {
          return performance.now();
        }
        return Date.now();
      }

      function clearOverlayAnimations() {
        overlayAnimations.clear();
        if (overlayAnimationFrame != null && typeof window?.cancelAnimationFrame === "function") {
          window.cancelAnimationFrame(overlayAnimationFrame);
        }
        overlayAnimationFrame = null;
        if (overlayAnimationTimeout != null) {
          clearTimeout(overlayAnimationTimeout);
          overlayAnimationTimeout = null;
        }
        if (state.puzzle) {
          renderPuzzle();
        }
      }

      function normalizeHintFadeDuration(value) {
        let candidate = Number(value);
        if (!Number.isFinite(candidate) || candidate <= 0) {
          const stateValue = state?.settings?.hintFadeDuration;
          candidate = Number.isFinite(stateValue) && stateValue > 0 ? stateValue : DEFAULT_HINT_FADE_DURATION;
        }
        return clamp(Math.round(candidate), MIN_HINT_FADE_DURATION, MAX_HINT_FADE_DURATION);
      }

      function normalizeHintIntensity(value) {
        let candidate = Number(value);
        if (!Number.isFinite(candidate)) {
          const stateValue = state?.settings?.hintIntensity;
          candidate = Number.isFinite(stateValue) ? stateValue : DEFAULT_HINT_INTENSITY;
        }
        if (candidate > 1) {
          candidate /= 100;
        }
        if (!Number.isFinite(candidate) || candidate <= 0) {
          candidate = DEFAULT_HINT_INTENSITY;
        }
        return clamp(candidate, MIN_HINT_INTENSITY, MAX_HINT_INTENSITY);
      }

      function normalizeHintTypes(source, fallback = DEFAULT_HINT_TYPES) {
        const base = fallback && typeof fallback === "object" ? fallback : DEFAULT_HINT_TYPES;
        const target = {};
        for (const key of HINT_TYPE_KEYS) {
          if (!Object.prototype.hasOwnProperty.call(base, key)) {
            continue;
          }
          if (source && typeof source === "object" && key in source) {
            target[key] = source[key] !== false;
          } else {
            target[key] = base[key] !== false;
          }
        }
        return target;
      }

      function isHintTypeEnabled(key) {
        if (state.settings.animateHints === false) {
          return false;
        }
        if (!HINT_TYPE_KEYS.includes(key)) {
          return true;
        }
        const source = state.settings?.hintTypes;
        if (!source || typeof source !== "object") {
          return DEFAULT_HINT_TYPES[key] !== false;
        }
        return source[key] !== false;
      }

      function syncHintTypeToggles() {
        const normalized = normalizeHintTypes(state.settings?.hintTypes);
        state.settings.hintTypes = normalized;
        if (hintMatchingToggle) {
          hintMatchingToggle.checked = normalized.matchingRegions !== false;
        }
        if (hintHoverToggle) {
          hintHoverToggle.checked = normalized.hoverRegions !== false;
        }
      }

      function resolveDifficulty(value) {
        if (typeof value === "string") {
          const normalized = value.trim().toLowerCase();
          if (VALID_DIFFICULTY_LEVELS.has(normalized)) {
            return normalized;
          }
        }
        return DEFAULT_DIFFICULTY;
      }

      function autoAdvanceColor(currentColorId) {
        if (!state.puzzle) return;
        const remainingForColor = getRegionsByColor(currentColorId, { includeFilled: false });
        if (remainingForColor.length > 0) return;
        const { entries, remainingByColor } = getPaletteEntryOrder({ includeCompleted: true });
        if (entries.length === 0) {
          return;
        }
        const currentIndex = entries.findIndex((entry) => entry.id === currentColorId);
        if (currentIndex >= 0) {
          for (let index = currentIndex + 1; index < entries.length; index += 1) {
            const candidate = entries[index];
            if ((remainingByColor.get(candidate.id) || 0) > 0) {
              activateColor(candidate.id);
              return;
            }
          }
        }
        for (const entry of entries) {
          if ((remainingByColor.get(entry.id) || 0) > 0) {
            activateColor(entry.id);
            return;
          }
        }
      }

      // Helper to collect regions for a colour with optional filtering of filled cells.
      function getRegionsByColor(colorId, options = {}) {
        const { includeFilled = true } = options;
        if (!state.puzzle) return [];
        return state.puzzle.regions.filter((region) => {
          if (region.colorId !== colorId) return false;
          if (!includeFilled && state.filled.has(region.id)) return false;
          return true;
        });
      }

      function getCompletedColorIds() {
        const completed = new Set();
        if (!state.puzzle) return completed;
        const pendingColors = new Set();
        for (const region of state.puzzle.regions) {
          if (!state.filled.has(region.id)) {
            pendingColors.add(region.colorId);
          }
        }
        for (const entry of state.puzzle.palette) {
          if (!pendingColors.has(entry.id)) {
            completed.add(entry.id);
          }
        }
        return completed;
      }

      function getPaletteEntry(colorId) {
        if (!state.puzzle) return null;
        return state.puzzle.palette.find((entry) => entry.id === colorId) || null;
      }

      // Shared renderer for flashing overlays (hints + colour selection pulses).
      function paintRegions(regions, fillStyle) {
        if (!state.puzzle || regions.length === 0) return;
        const cache = ensureRenderCache();
        if (!cache.ready) return;
        const controller = state.rendering?.controller;
        if (!controller) return;
        controller.flashRegions({ state, cache, regions, fillStyle, metrics: { ...canvasMetrics } });
      }

      function flashRegionsWithContext({ context, state, cache, regions, fillStyle }) {
        if (!context || !state?.puzzle || !Array.isArray(regions) || regions.length === 0) {
          return;
        }
        const scale = canvasMetrics.renderScale > 0 ? canvasMetrics.renderScale : 1;
        const strokeWidth = cache?.strokeWidth > 0 ? cache.strokeWidth : 1;
        withRenderScale(context, scale, () => {
          context.fillStyle = fillStyle;
          context.strokeStyle = fillStyle;
          context.lineWidth = strokeWidth;
          context.lineJoin = "round";
          context.lineCap = "round";
          if (SUPPORTS_PATH2D) {
            for (const region of regions) {
              const geometry = cache?.regionsById?.get(region.id);
              if (!geometry?.path) continue;
              context.fill(geometry.path);
              context.stroke(geometry.path);
            }
            return;
          }
          for (const region of regions) {
            const geometry = cache?.regionsById?.get(region.id);
            if (!geometry?.contours) continue;
            context.beginPath();
            for (const contour of geometry.contours) {
              if (contour.length === 0) continue;
              const first = contour[0];
              context.moveTo(first[0], first[1]);
              for (let i = 1; i < contour.length; i++) {
                const point = contour[i];
                context.lineTo(point[0], point[1]);
              }
              context.closePath();
            }
            context.fill();
            context.stroke();
          }
        });
      }

      function flashPaletteSwatch(colorId, options = {}) {
        if (!paletteEl) return;
        const swatch = paletteEl.querySelector(`.swatch[data-color-id="${colorId}"]`);
        if (!swatch) return;
        const hex = typeof options.hex === "string" && options.hex ? options.hex : null;
        if (hex) {
          swatch.style.setProperty("--flash-color", rgbaFromHex(hex, 0.6));
          swatch.style.setProperty("--flash-border", rgbaFromHex(hex, 0.95));
        } else {
          swatch.style.removeProperty("--flash-color");
          swatch.style.removeProperty("--flash-border");
        }
        swatch.classList.remove("flash");
        void swatch.offsetWidth;
        swatch.classList.add("flash");
        window.setTimeout(() => {
          swatch.classList.remove("flash");
          if (hex) {
            swatch.style.removeProperty("--flash-color");
            swatch.style.removeProperty("--flash-border");
          }
        }, 480);
      }

      function compactPuzzleSnapshot(snapshot) {
        if (!snapshot || typeof snapshot !== "object") return null;
        const width = Number(snapshot.width);
        const height = Number(snapshot.height);
        if (!Number.isFinite(width) || !Number.isFinite(height)) {
          return null;
        }
        const payload = {
          format:
            typeof snapshot.format === "string" && snapshot.format
              ? snapshot.format
              : "capy-puzzle@2",
          width,
          height,
        };
        if (typeof snapshot.title === "string" && snapshot.title.trim()) {
          payload.title = snapshot.title.trim();
        }
        const paletteSource = Array.isArray(snapshot.palette)
          ? snapshot.palette
          : Array.isArray(snapshot.colors)
          ? snapshot.colors
          : [];
        const palette = [];
        for (let index = 0; index < paletteSource.length; index += 1) {
          const resolved = resolvePaletteEntrySnapshot(paletteSource[index], index);
          if (!resolved) continue;
          const encoded = encodeCompactPaletteEntry(resolved);
          if (encoded) {
            palette.push(encoded);
          }
        }
        payload.palette = palette;
        const regionSource = Array.isArray(snapshot.regions) ? snapshot.regions : [];
        const regions = [];
        for (let index = 0; index < regionSource.length; index += 1) {
          const resolved = resolveRegionEntrySnapshot(regionSource[index], index);
          if (!resolved) continue;
          const encoded = encodeCompactRegionEntry(resolved);
          if (encoded) {
            regions.push(encoded);
          }
        }
        payload.regions = regions;
        let packed = null;
        if (typeof snapshot.m === "string" && snapshot.m) {
          packed = snapshot.m;
        } else if (typeof snapshot.map === "string" && snapshot.map) {
          packed = snapshot.map;
        } else if (typeof snapshot.regionMapPacked === "string" && snapshot.regionMapPacked) {
          packed = snapshot.regionMapPacked;
        } else if (snapshot.regionMap) {
          packed = packRegionMap(snapshot.regionMap);
        }
        if (packed) {
          payload.m = packed;
        }
        const filledPacked = packFilledRegions(snapshot.f ?? snapshot.filled ?? snapshot.filledPacked);
        if (filledPacked) {
          payload.f = filledPacked;
        }
        if (snapshot.options && typeof snapshot.options === "object") {
          const options = { ...snapshot.options };
          if (Object.keys(options).length > 0) {
            payload.options = options;
          }
        }
        if (typeof snapshot.sourceUrl === "string" && snapshot.sourceUrl) {
          payload.sourceUrl = snapshot.sourceUrl;
        }
        const sourceImageSnapshot = normalizeSourceImageSnapshot(snapshot.sourceImage, {
          width: payload.width,
          height: payload.height,
          originalWidth: payload.width,
          originalHeight: payload.height,
        });
        if (sourceImageSnapshot) {
          payload.sourceImage = sourceImageSnapshot;
        }
        if (typeof snapshot.activeColor === "number" && Number.isFinite(snapshot.activeColor)) {
          payload.activeColor = snapshot.activeColor;
        }
        if (typeof snapshot.backgroundColor === "string" && snapshot.backgroundColor) {
          payload.backgroundColor = snapshot.backgroundColor;
        }
        if (
          typeof snapshot.stageBackgroundColor === "string" &&
          snapshot.stageBackgroundColor
        ) {
          payload.stageBackgroundColor = snapshot.stageBackgroundColor;
        }
        if (snapshot.viewport && typeof snapshot.viewport === "object") {
          const { panX, panY, zoom, baseScale } = snapshot.viewport;
          payload.viewport = {
            panX: Number.isFinite(panX) ? panX : 0,
            panY: Number.isFinite(panY) ? panY : 0,
            zoom: Number.isFinite(zoom) ? zoom : 1,
            baseScale: Number.isFinite(baseScale) ? baseScale : 1,
          };
        }
        return payload;
      }


      function serializeCurrentPuzzle() {
        if (!state.puzzle) return {};
        const { puzzle } = state;
        const regionMapPacked = packRegionMap(puzzle.regionMap);
        const palette = puzzle.palette.map((entry, index) => {
          const resolved = {
            id:
              typeof entry.id === "number" && Number.isFinite(entry.id)
                ? entry.id
                : index + 1,
          };
          if (typeof entry.hex === "string" && entry.hex) {
            resolved.hex = entry.hex;
          }
          if (Array.isArray(entry.rgba)) {
            resolved.rgba = entry.rgba.slice(0, 3);
          }
          if (typeof entry.name === "string" && entry.name.trim()) {
            resolved.name = entry.name.trim();
          }
          return resolved;
        });
        const regions = puzzle.regions.map((region, index) => {
          const resolvedId =
            typeof region.id === "number" && Number.isFinite(region.id)
              ? region.id
              : index;
          const payload = {
            id: resolvedId,
            colorId:
              typeof region.colorId === "number" && Number.isFinite(region.colorId)
                ? region.colorId
                : 1,
            pixelCount:
              typeof region.pixelCount === "number" && Number.isFinite(region.pixelCount)
                ? region.pixelCount
                : Array.isArray(region.pixels)
                ? region.pixels.length
                : 0,
          };
          if (typeof region.cx === "number" && Number.isFinite(region.cx)) {
            payload.cx = Math.round(region.cx * 1000) / 1000;
          }
          if (typeof region.cy === "number" && Number.isFinite(region.cy)) {
            payload.cy = Math.round(region.cy * 1000) / 1000;
          }
          return payload;
        });
        const snapshot = {
          format: "capy-puzzle@2",
          title: state.sourceTitle || "capy-puzzle",
          width: puzzle.width,
          height: puzzle.height,
          palette,
          regions,
          filled: Array.from(state.filled),
          options: state.lastOptions,
          sourceUrl: state.sourceUrl,
          activeColor: state.activeColor,
          backgroundColor: state.settings.backgroundColor,
          stageBackgroundColor: state.settings.stageBackgroundColor,
          viewport: {
            panX: viewState.panX,
            panY: viewState.panY,
            zoom: viewState.zoom,
            baseScale: viewState.baseScale,
          },
        };
        if (regionMapPacked) {
          snapshot.regionMapPacked = regionMapPacked;
        } else if (puzzle.regionMap) {
          snapshot.regionMap = Array.from(puzzle.regionMap);
        }
        const sourceImageSnapshot = normalizeSourceImageSnapshot(
          state.puzzle.sourceImage?.snapshot ?? state.puzzle.sourceImage,
          {
            width: puzzle.width,
            height: puzzle.height,
            originalWidth:
              state.puzzle.sourceImage?.snapshot?.originalWidth ?? puzzle.width,
            originalHeight:
              state.puzzle.sourceImage?.snapshot?.originalHeight ?? puzzle.height,
          }
        );
        if (sourceImageSnapshot) {
          snapshot.sourceImage = sourceImageSnapshot;
        }
        return compactPuzzleSnapshot(snapshot) || snapshot;
      }

      function isSettingsAutosaveReason(reason) {
        return typeof reason === "string" && SETTINGS_AUTOSAVE_REASONS.has(reason);
      }

      function getUserSettingsSnapshot(source = state?.settings) {
        if (!source || typeof source !== "object") return null;
        const base = source;
        const hintTypes = normalizeHintTypes(base.hintTypes, DEFAULT_HINT_TYPES);
        const hintFadeDuration = normalizeHintFadeDuration(base.hintFadeDuration);
        const hintIntensity = normalizeHintIntensity(base.hintIntensity);
        const difficulty = resolveDifficulty(base.difficulty);
        const scaleCandidate = Number(base.uiScale);
        const uiScale = Number.isFinite(scaleCandidate)
          ? clamp(scaleCandidate, 0.2, 3)
          : DEFAULT_UI_SCALE;
        const renderer = normalizeRendererType(base.renderer) || "canvas2d";
        const themeCandidate =
          typeof base.theme === "string" ? base.theme.trim().toLowerCase() : "";
        const theme = VALID_UI_THEMES.has(themeCandidate) ? themeCandidate : DEFAULT_UI_THEME;
        const backgroundColor = sanitizeHexColor(
          base.backgroundColor ?? DEFAULT_BACKGROUND_HEX,
          DEFAULT_BACKGROUND_HEX
        );
        const stageBackgroundColor = sanitizeHexColor(
          base.stageBackgroundColor ?? DEFAULT_STAGE_BACKGROUND_HEX,
          DEFAULT_STAGE_BACKGROUND_HEX
        );
        const mouseControls = cloneMouseControls(
          normalizeMouseControls(base.mouseControls, DEFAULT_MOUSE_CONTROLS)
        );
        const artPrompt = typeof base.artPrompt === "string" ? base.artPrompt : "";
        const imageDescription =
          typeof base.imageDescription === "string" ? base.imageDescription : "";
        return {
          autoAdvance: base.autoAdvance !== false,
          animateHints: base.animateHints !== false,
          hintTypes,
          hintFadeDuration,
          hintIntensity,
          difficulty,
          uiScale,
          artPrompt,
          imageDescription,
          showRegionLabels: base.showRegionLabels !== false,
          theme,
          renderer,
          backgroundColor,
          stageBackgroundColor,
          mouseControls,
        };
      }

      function persistUserSettings(snapshot) {
        if (!snapshot || typeof snapshot !== "object") return null;
        if (typeof localStorage === "undefined") return null;
        const record = { version: 1, settings: snapshot };
        let serialized = null;
        try {
          serialized = JSON.stringify(record);
        } catch (error) {
          console.error("Failed to serialise settings", error);
          return null;
        }
        if (serialized === lastStoredSettingsJson) {
          return record;
        }
        try {
          localStorage.setItem(SETTINGS_STORAGE_KEY, serialized);
          lastStoredSettingsJson = serialized;
        } catch (error) {
          console.error("Failed to persist settings", error);
        }
        return record;
      }

      function scheduleSettingsPersist(options = {}) {
        if (typeof localStorage === "undefined") return null;
        if (!state || !state.settings) return null;
        const { immediate = false, delay = 350 } = options || {};
        const snapshot = getUserSettingsSnapshot(state.settings);
        if (!snapshot) return null;
        if (immediate) {
          pendingSettingsPersistPayload = null;
          if (
            settingsPersistTimer != null &&
            typeof window !== "undefined" &&
            typeof window.clearTimeout === "function"
          ) {
            window.clearTimeout(settingsPersistTimer);
          }
          settingsPersistTimer = null;
          return persistUserSettings(snapshot);
        }
        pendingSettingsPersistPayload = snapshot;
        if (
          settingsPersistTimer != null &&
          typeof window !== "undefined" &&
          typeof window.clearTimeout === "function"
        ) {
          window.clearTimeout(settingsPersistTimer);
        }
        const timeout = Math.max(120, Number.isFinite(delay) ? delay : 350);
        if (typeof window === "undefined" || typeof window.setTimeout !== "function") {
          return persistUserSettings(snapshot);
        }
        settingsPersistTimer = window.setTimeout(() => {
          settingsPersistTimer = null;
          const payload =
            pendingSettingsPersistPayload || getUserSettingsSnapshot(state.settings);
          pendingSettingsPersistPayload = null;
          persistUserSettings(payload);
        }, timeout);
        return null;
      }

      function normalizeStoredUserSettings(source) {
        if (!source || typeof source !== "object") return null;
        const payload =
          source.settings && typeof source.settings === "object"
            ? source.settings
            : source;
        if (!payload || typeof payload !== "object") return null;
        const normalized = {};
        if (typeof payload.autoAdvance === "boolean") {
          normalized.autoAdvance = payload.autoAdvance;
        }
        if (typeof payload.animateHints === "boolean") {
          normalized.animateHints = payload.animateHints;
        }
        if (payload.hintTypes != null) {
          normalized.hintTypes = normalizeHintTypes(payload.hintTypes, DEFAULT_HINT_TYPES);
        }
        if (payload.hintFadeDuration != null) {
          const candidate = Number(payload.hintFadeDuration);
          if (Number.isFinite(candidate) && candidate > 0) {
            normalized.hintFadeDuration = clamp(
              Math.round(candidate),
              MIN_HINT_FADE_DURATION,
              MAX_HINT_FADE_DURATION
            );
          }
        }
        if (payload.hintIntensity != null) {
          let candidate = Number(payload.hintIntensity);
          if (Number.isFinite(candidate)) {
            if (candidate > 1) {
              candidate /= 100;
            }
            normalized.hintIntensity = clamp(
              candidate,
              MIN_HINT_INTENSITY,
              MAX_HINT_INTENSITY
            );
          }
        }
        if (payload.difficulty != null) {
          normalized.difficulty = resolveDifficulty(payload.difficulty);
        }
        if (payload.uiScale != null) {
          const candidate = Number(payload.uiScale);
          if (Number.isFinite(candidate)) {
            normalized.uiScale = clamp(candidate, 0.2, 3);
          }
        }
        if (payload.labelScale != null) {
          const candidate = Number(payload.labelScale);
          if (Number.isFinite(candidate)) {
            normalized.labelScale = clamp(candidate, 0.2, 2);
          }
        }
        if (typeof payload.artPrompt === "string") {
          normalized.artPrompt = payload.artPrompt;
        }
        if (typeof payload.imageDescription === "string") {
          normalized.imageDescription = payload.imageDescription;
        }
        if (payload.showRegionLabels != null) {
          normalized.showRegionLabels = payload.showRegionLabels !== false;
        }
        if (payload.theme != null) {
          const themeCandidate =
            typeof payload.theme === "string" ? payload.theme.trim().toLowerCase() : "";
          if (VALID_UI_THEMES.has(themeCandidate)) {
            normalized.theme = themeCandidate;
          }
        }
        if (payload.renderer != null) {
          const renderer = normalizeRendererType(payload.renderer);
          if (renderer) {
            normalized.renderer = renderer;
          }
        }
        if (payload.backgroundColor != null) {
          normalized.backgroundColor = sanitizeHexColor(
            payload.backgroundColor,
            DEFAULT_BACKGROUND_HEX
          );
        }
        if (payload.stageBackgroundColor != null) {
          normalized.stageBackgroundColor = sanitizeHexColor(
            payload.stageBackgroundColor,
            DEFAULT_STAGE_BACKGROUND_HEX
          );
        }
        if (payload.mouseControls != null) {
          normalized.mouseControls = cloneMouseControls(
            normalizeMouseControls(payload.mouseControls, DEFAULT_MOUSE_CONTROLS)
          );
        }
        return Object.keys(normalized).length > 0 ? normalized : null;
      }

      function loadUserSettings() {
        if (typeof localStorage === "undefined") return null;
        try {
          const raw = localStorage.getItem(SETTINGS_STORAGE_KEY);
          if (!raw) return null;
          const parsed = JSON.parse(raw);
          const normalized = normalizeStoredUserSettings(parsed);
          if (!normalized) return null;
          let rewritePayload = null;
          try {
            const snapshot = getUserSettingsSnapshot(normalized);
            if (snapshot) {
              const record = { version: 1, settings: snapshot };
              const serialized = JSON.stringify(record);
              if (serialized !== raw) {
                rewritePayload = serialized;
              } else {
                lastStoredSettingsJson = serialized;
              }
            }
          } catch (prepareError) {
            console.error("Failed to prepare settings rewrite", prepareError);
          }
          if (rewritePayload) {
            try {
              localStorage.setItem(SETTINGS_STORAGE_KEY, rewritePayload);
              lastStoredSettingsJson = rewritePayload;
            } catch (persistError) {
              console.error("Failed to rewrite stored settings", persistError);
            }
          }
          return normalized;
        } catch (error) {
          console.error("Failed to load stored settings", error);
        }
        return null;
      }

      function scheduleAutosave(reason, options = {}) {
        const { immediate = false, delay = 350 } = options;
        const resolvedReason = reason || pendingAutosaveReason || "update";
        const settingsUpdate = isSettingsAutosaveReason(resolvedReason);
        if (settingsUpdate) {
          scheduleSettingsPersist({ immediate, delay });
        }
        if (!state.puzzle) {
          if (settingsUpdate) {
            pendingAutosaveReason = null;
          }
          return null;
        }
        if (immediate) {
          pendingAutosaveReason = null;
          if (autosaveTimer) {
            window.clearTimeout(autosaveTimer);
            autosaveTimer = null;
          }
          return persistAutosave(resolvedReason);
        }
        pendingAutosaveReason = resolvedReason;
        if (autosaveTimer) {
          window.clearTimeout(autosaveTimer);
        }
        const timeout = Math.max(120, delay);
        autosaveTimer = window.setTimeout(() => {
          autosaveTimer = null;
          const finalReason = pendingAutosaveReason || "update";
          pendingAutosaveReason = null;
          persistAutosave(finalReason);
        }, timeout);
        return null;
      }

      function persistAutosave(reason = "update") {
        if (!state.puzzle) return null;
        const snapshot = serializeCurrentPuzzle();
        const settingsSnapshot = getUserSettingsSnapshot(state.settings);
        const now = Date.now();
        const resolvedTitle =
          (typeof snapshot?.title === "string" && snapshot.title.trim()) ||
          (typeof state.sourceTitle === "string" && state.sourceTitle.trim()) ||
          getDefaultGameTitle();
        if (snapshot && typeof snapshot === "object") {
          snapshot.title = resolvedTitle;
        }
        let activeSaveId = typeof state.loadedSaveId === "string" ? state.loadedSaveId : null;
        let entry = activeSaveId ? state.saves.find((item) => item.id === activeSaveId) : null;
        if (!entry) {
          activeSaveId = `save-${now}-${Math.floor(Math.random() * 10000)}`;
          entry = { id: activeSaveId };
          state.saves.unshift(entry);
        }
        entry.title = resolvedTitle;
        entry.timestamp = now;
        entry.data = snapshot;
        if (settingsSnapshot) {
          entry.settings = settingsSnapshot;
        } else {
          delete entry.settings;
        }
        state.loadedSaveId = activeSaveId;
        state.saves = [entry, ...state.saves.filter((item) => item.id !== activeSaveId)];
        persistSaves();
        logDebug(`Autosaved ${resolvedTitle} (${reason})`);
        return entry;
      }


      function getLatestBackupRecord() {
        if (!Array.isArray(state.saves) || state.saves.length === 0) {
          return null;
        }
        let candidate = null;
        if (typeof state.loadedSaveId === "string") {
          candidate = state.saves.find((entry) => entry.id === state.loadedSaveId) || null;
        }
        if (!candidate) {
          [candidate] = [...state.saves].sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
        }
        if (candidate && candidate.data) {
          return {
            id: candidate.id,
            timestamp: candidate.timestamp,
            data: candidate.data,
            title: candidate.title,
            settings: candidate.settings,
            origin: "save slot",
          };
        }
        return null;
      }

      function getStoredStringSize(raw) {
        if (!raw) return 0;
        try {
          if (typeof Blob !== "undefined") {
            return new Blob([raw]).size;
          }
          if (typeof TextEncoder !== "undefined") {
            return new TextEncoder().encode(raw).length;
          }
        } catch (error) {
          console.error("Failed to inspect storage size", error);
        }
        return raw.length * 2;
      }

      function collectSaveStorageStats() {
        let manualBytes = 0;
        let manualCount = Array.isArray(state.saves) ? state.saves.length : 0;
        try {
          const raw = localStorage.getItem(SAVE_STORAGE_KEY);
          manualBytes = getStoredStringSize(raw);
          if (!Number.isFinite(manualCount)) {
            manualCount = 0;
          }
          if (manualCount === 0 && raw) {
            try {
              const parsed = JSON.parse(raw);
              manualCount = Array.isArray(parsed) ? parsed.length : 0;
            } catch (error) {
              console.error("Failed to parse save records for stats", error);
            }
          }
        } catch (error) {
          console.error("Failed to read save storage size", error);
        }
        return {
          manualBytes,
          manualCount,
          totalBytes: manualBytes,
        };
      }

      function decodeLegacyAutosaveStorageRecord(record) {
        if (!record || typeof record !== "object") return null;
        const { puzzle, settings } = decodeStoredPuzzleSnapshot(record.data ?? record.payload ?? null);
        if (!puzzle) return null;
        const normalized = {
          timestamp:
            typeof record.timestamp === "number" && Number.isFinite(record.timestamp)
              ? record.timestamp
              : Date.now(),
          data: puzzle,
        };
        if (typeof record.id === "string" && record.id.trim()) {
          normalized.id = record.id.trim();
        }
        if (settings && typeof settings === "object") {
          normalized.settings = settings;
        } else if (record.settings && typeof record.settings === "object") {
          const snapshot = getUserSettingsSnapshot(record.settings);
          if (snapshot) {
            normalized.settings = snapshot;
          }
        }
        if (typeof record.title === "string" && record.title.trim()) {
          normalized.title = record.title.trim();
        } else if (typeof puzzle.title === "string" && puzzle.title) {
          normalized.title = puzzle.title;
        }
        return normalized;
      }

      function migrateLegacyAutosave() {
        if (typeof localStorage === "undefined") {
          return;
        }
        let raw = null;
        try {
          raw = localStorage.getItem(LEGACY_AUTOSAVE_STORAGE_KEY);
        } catch (error) {
          console.error("Failed to read legacy autosave", error);
          return;
        }
        if (!raw) {
          return;
        }
        try {
          const parsed = JSON.parse(raw);
          const legacy = decodeLegacyAutosaveStorageRecord(parsed);
          if (!legacy || !legacy.data) {
            return;
          }
          const timestamp = Number.isFinite(legacy.timestamp) ? legacy.timestamp : Date.now();
          const seed = Math.floor(Math.random() * 10000);
          const id = legacy.id && typeof legacy.id === "string" && legacy.id.trim()
            ? legacy.id.trim()
            : `save-${timestamp}-${seed}-autosave`;
          const entry = {
            id,
            timestamp,
            data: legacy.data,
          };
          if (legacy.settings && typeof legacy.settings === "object") {
            const snapshot = getUserSettingsSnapshot(legacy.settings);
            if (snapshot) {
              entry.settings = snapshot;
            }
          }
          if (legacy.title) {
            entry.title = legacy.title;
          }
          state.saves = [entry, ...state.saves.filter((item) => item.id !== id)];
          state.loadedSaveId = id;
          persistSaves();
          logDebug("Migrated legacy autosave into manual slot");
        } catch (error) {
          console.error("Failed to migrate legacy autosave", error);
        } finally {
          try {
            localStorage.removeItem(LEGACY_AUTOSAVE_STORAGE_KEY);
          } catch (removeError) {
            console.error("Failed to clear legacy autosave key", removeError);
          }
        }
      }

      function formatBytes(bytes) {
        if (!Number.isFinite(bytes) || bytes <= 0) {
          return "0 B";
        }
        const units = ["B", "KB", "MB", "GB"];
        let value = bytes;
        let unitIndex = 0;
        while (value >= 1024 && unitIndex < units.length - 1) {
          value /= 1024;
          unitIndex += 1;
        }
        const rounded = unitIndex === 0 || value >= 10 ? Math.round(value) : Math.round(value * 10) / 10;
        return `${rounded} ${units[unitIndex]}`;
      }

      function logStorageFailureDetails(kind, attemptedBytes) {
        if (Number.isFinite(attemptedBytes) && attemptedBytes > 0) {
          const label = formatBytes(attemptedBytes);
          logDebug(`Save snapshot payload ≈${label}.`);
        }
        if (navigator.storage && typeof navigator.storage.estimate === "function") {
          navigator.storage
            .estimate()
            .then((estimate) => {
              if (!estimate) return;
              const usage = Number(estimate.usage);
              const quota = Number(estimate.quota);
              if (Number.isFinite(usage) && Number.isFinite(quota) && quota > 0) {
                const percent = Math.min(100, Math.round((usage / quota) * 1000) / 10);
                const percentSuffix = Number.isFinite(percent) ? ` (${percent}% used)` : "";
                logDebug(`Storage usage ${formatBytes(usage)} of ${formatBytes(quota)} quota${percentSuffix}.`);
              } else if (Number.isFinite(usage)) {
                logDebug(`Storage usage ${formatBytes(usage)} (quota unavailable).`);
              } else if (Number.isFinite(quota)) {
                logDebug(`Storage quota ${formatBytes(quota)} (usage unavailable).`);
              }
            })
            .catch((error) => {
              console.error("Failed to estimate storage quota", error);
            });
        } else {
          logDebug("Storage usage estimate unavailable in this browser.");
        }
      }

      function updateStorageUsageSummary() {
        if (!saveStorageSummary) return;
        const token = ++storageSummaryUpdateToken;
        let stats = { manualBytes: 0, manualCount: 0, totalBytes: 0 };
        try {
          stats = collectSaveStorageStats();
        } catch (error) {
          console.error("Failed to update save storage summary", error);
        }
        let summaryText =
          "Save data lives entirely in this browser. The active slot updates automatically as you play.";
        let disableClearButton = stats.manualCount === 0;
        if (stats.manualCount > 0) {
          const manualLabel =
            stats.manualCount === 1
              ? "1 save"
              : `${stats.manualCount} saves`;
          summaryText = `${manualLabel} using ${formatBytes(stats.manualBytes)} stored locally.`;
        }
        saveStorageSummary.textContent = summaryText;
        if (deleteAllSavesButton) {
          deleteAllSavesButton.disabled = disableClearButton;
        }
        if (navigator.storage && typeof navigator.storage.estimate === "function") {
          const baseSummary = summaryText;
          const statsSnapshot = { ...stats };
          navigator.storage
            .estimate()
            .then((estimate) => {
              if (token !== storageSummaryUpdateToken) return;
              if (!estimate) return;
              const quota = Number(estimate.quota);
              const usage = Number(estimate.usage);
              if (!Number.isFinite(quota) || quota <= 0) {
                if (Number.isFinite(usage) && usage > 0) {
                  const usageText = `Storage usage: ${formatBytes(usage)}.`;
                  saveStorageSummary.textContent = `${baseSummary}${baseSummary ? " " : ""}${usageText}`;
                }
                return;
              }
              const usedBytes = Number.isFinite(usage) && usage >= 0 ? usage : statsSnapshot.totalBytes;
              const usageLabel = formatBytes(usedBytes);
              const quotaLabel = formatBytes(quota);
              let percentText = "";
              if (quota > 0 && Number.isFinite(usedBytes)) {
                const percent = Math.min(100, Math.round((usedBytes / quota) * 1000) / 10);
                if (Number.isFinite(percent)) {
                  percentText = ` (${percent}% used)`;
                }
              }
              const quotaText = `Storage quota: ${usageLabel} of ${quotaLabel}${percentText}.`;
              saveStorageSummary.textContent = `${baseSummary}${baseSummary ? " " : ""}${quotaText}`;
            })
            .catch((error) => {
              if (token !== storageSummaryUpdateToken) return;
              console.error("Failed to estimate storage quota", error);
            });
        }
      }

      function loadInitialSession() {
        const latest = getLatestBackupRecord();
        if (latest && latest.data) {
          const descriptor =
            latest.title ||
            latest.data.title ||
            state.sourceTitle ||
            "Puzzle";
          const applied = applyPuzzleResult(latest.data, {
            options: latest.data.options,
            activeColor: latest.data.activeColor,
            backgroundColor: latest.data.backgroundColor,
            stageBackgroundColor: latest.data.stageBackgroundColor,
            viewport: latest.data.viewport,
            settings: latest.settings ?? latest.data.settings,
            title: descriptor,
            logMessage: `Restoring ${descriptor} from backup`,
            skipDefaultLog: true,
            loadedSaveId: latest.id || null,
          });
          if (applied) {
            state.sourceUrl = latest.data.sourceUrl ?? null;
            state.sourceTitle = descriptor;
            state.loadedSaveId = latest.id || null;
            hideStartScreen();
            logDebug(`Restored previous session from ${latest.origin || "backup storage"}`);
            return true;
          }
        }
        return false;
      }

      function packFilledRegions(source) {
        const decoded = decodeFilledRegionList(source);
        if (!Array.isArray(decoded) || decoded.length === 0) {
          return "";
        }
        const normalized = decoded
          .map((value) => Math.max(0, Math.round(Number(value) || 0)))
          .filter((value) => Number.isFinite(value));
        if (normalized.length === 0) {
          return "";
        }
        normalized.sort((a, b) => a - b);
        const bytes = [];
        let previous = -1;
        for (const value of normalized) {
          if (value === previous) {
            continue;
          }
          const delta = previous < 0 ? value : value - previous;
          previous = value;
          let remaining = delta >>> 0;
          while (remaining >= 0x80) {
            bytes.push((remaining & 0x7f) | 0x80);
            remaining >>>= 7;
          }
          bytes.push(remaining & 0x7f);
        }
        if (bytes.length === 0) {
          return "";
        }
        return encodeBytesToBase64(new Uint8Array(bytes));
      }

      function unpackFilledRegions(packed) {
        if (typeof packed !== "string") {
          return [];
        }
        if (packed.length === 0) {
          return [];
        }
        try {
          const bytes = decodeBase64ToBytes(packed);
          const values = [];
          let value = 0;
          let shift = 0;
          let delta = 0;
          for (let index = 0; index < bytes.length; index += 1) {
            const byte = bytes[index];
            delta |= (byte & 0x7f) << shift;
            if (byte & 0x80) {
              shift += 7;
              continue;
            }
            value += delta;
            if (Number.isFinite(value) && value >= 0) {
              values.push(value);
            }
            delta = 0;
            shift = 0;
          }
          if (shift !== 0) {
            return [];
          }
          return values;
        } catch (error) {
          console.error("Failed to unpack filled regions", error);
          return [];
        }
      }

      function packRegionMap(map) {
        if (!map || typeof map.length !== "number") return null;
        try {
          const typed =
            map instanceof Int32Array
              ? new Int32Array(map)
              : map instanceof Uint32Array
              ? new Int32Array(map)
              : new Int32Array(Array.from(map));
          const bytes = new Uint8Array(typed.buffer);
          let binary = "";
          for (let i = 0; i < bytes.length; i++) {
            binary += String.fromCharCode(bytes[i]);
          }
          return btoa(binary);
        } catch (error) {
          console.error("Failed to pack region map", error);
          return null;
        }
      }

      function unpackRegionMap(source, expectedLength) {
        if (!source) return null;
        try {
          if (typeof source === "string") {
            const binary = atob(source);
            const buffer = new ArrayBuffer(binary.length);
            const bytes = new Uint8Array(buffer);
            for (let i = 0; i < binary.length; i++) {
              bytes[i] = binary.charCodeAt(i);
            }
            if (typeof expectedLength === "number" && buffer.byteLength / 4 !== expectedLength) {
              return null;
            }
            return new Int32Array(buffer);
          }
          if (source instanceof Int32Array) {
            if (typeof expectedLength === "number" && source.length !== expectedLength) {
              return null;
            }
            return new Int32Array(source);
          }
          if (source instanceof Uint32Array) {
            const copy = new Int32Array(source);
            if (typeof expectedLength === "number" && copy.length !== expectedLength) {
              return null;
            }
            return copy;
          }
          if (Array.isArray(source) || ArrayBuffer.isView(source)) {
            const array = Array.isArray(source) ? source : Array.from(source);
            if (typeof expectedLength === "number" && array.length !== expectedLength) {
              return null;
            }
            return new Int32Array(array);
          }
        } catch (error) {
          console.error("Failed to unpack region map", error);
          return null;
        }
        return null;
      }

      let cachedTextEncoder = null;
      let cachedTextDecoder = null;

      function encodeUtf8String(input) {
        if (typeof input !== "string" || input.length === 0) {
          return new Uint8Array(0);
        }
        if (typeof TextEncoder !== "undefined") {
          if (!cachedTextEncoder) {
            cachedTextEncoder = new TextEncoder();
          }
          return cachedTextEncoder.encode(input);
        }
        const bytes = new Uint8Array(input.length);
        for (let index = 0; index < input.length; index += 1) {
          bytes[index] = input.charCodeAt(index) & 0xff;
        }
        return bytes;
      }

      function decodeUtf8Bytes(bytes) {
        if (!bytes || bytes.length === 0) {
          return "";
        }
        if (typeof TextDecoder !== "undefined") {
          if (!cachedTextDecoder) {
            cachedTextDecoder = new TextDecoder();
          }
          return cachedTextDecoder.decode(bytes);
        }
        let result = "";
        for (let index = 0; index < bytes.length; index += 1) {
          result += String.fromCharCode(bytes[index]);
        }
        return result;
      }

      function encodeBytesToBase64(bytes) {
        if (!bytes || typeof bytes.length !== "number" || bytes.length === 0) {
          return "";
        }
        let binary = "";
        for (let index = 0; index < bytes.length; index += 1) {
          binary += String.fromCharCode(bytes[index]);
        }
        return btoa(binary);
      }

      function decodeBase64ToBytes(base64) {
        if (typeof base64 !== "string" || base64.length === 0) {
          return new Uint8Array(0);
        }
        const binary = atob(base64);
        const buffer = new ArrayBuffer(binary.length);
        const bytes = new Uint8Array(buffer);
        for (let index = 0; index < binary.length; index += 1) {
          bytes[index] = binary.charCodeAt(index);
        }
        return bytes;
      }

      function simpleLZ77Decompress(bytes) {
        if (!bytes || bytes.length === 0) {
          return new Uint8Array(0);
        }
        const output = [];
        let index = 0;
        while (index < bytes.length) {
          const controlByte = bytes[index++];
          for (let bit = 0; bit < 8 && index < bytes.length; bit += 1) {
            const isMatch = (controlByte >> bit) & 1;
            if (isMatch) {
              if (index + 1 >= bytes.length) {
                return null;
              }
              const first = bytes[index++];
              const second = bytes[index++];
              const offset = ((first << 4) | (second >> 4)) & 0xfff;
              const length = (second & 0x0f) + 3;
              if (offset === 0 || offset > output.length) {
                return null;
              }
              const start = output.length - offset;
              for (let i = 0; i < length; i += 1) {
                output.push(output[start + i]);
              }
            } else {
              output.push(bytes[index++]);
            }
          }
        }
        return new Uint8Array(output);
      }

      function lzwDecompress(codes) {
        if (!codes || codes.length === 0) {
          return "";
        }
        const dictionary = [];
        for (let index = 0; index < 256; index += 1) {
          dictionary[index] = String.fromCharCode(index);
        }
        let dictSize = 256;
        let previous = String.fromCharCode(codes[0]);
        let output = previous;
        for (let index = 1; index < codes.length; index += 1) {
          const code = codes[index];
          let entry = "";
          if (dictionary[code] != null) {
            entry = dictionary[code];
          } else if (code === dictSize) {
            entry = previous + previous.charAt(0);
          } else {
            return null;
          }
          output += entry;
          if (dictSize < 65535) {
            dictionary[dictSize] = previous + entry.charAt(0);
            dictSize += 1;
          }
          previous = entry;
        }
        return output;
      }

      function decodeLegacySnapshotPayload(source) {
        if (!source || typeof source !== "object") {
          return null;
        }
        const payload = typeof source.payload === "string" ? source.payload : "";
        if (!payload) {
          return null;
        }
        const encoding = typeof source.encoding === "string" ? source.encoding : "identity";
        if (encoding === "identity") {
          return payload;
        }
        if (encoding === "lz77") {
          try {
            const bytes = decodeBase64ToBytes(payload);
            const decompressed = simpleLZ77Decompress(bytes);
            return decompressed ? decodeUtf8Bytes(decompressed) : null;
          } catch (error) {
            console.error("Failed to decompress legacy LZ77 payload", error);
            return null;
          }
        }
        if (encoding === "lzw16") {
          try {
            const bytes = decodeBase64ToBytes(payload);
            if (bytes.byteLength === 0) {
              return "";
            }
            const length = Math.floor(bytes.byteLength / 2);
            const codes = new Uint16Array(bytes.buffer, bytes.byteOffset, length);
            return lzwDecompress(codes);
          } catch (error) {
            console.error("Failed to decompress legacy LZW payload", error);
            return null;
          }
        }
        console.error(`Unsupported legacy snapshot encoding: ${encoding}`);
        return null;
      }

      function decodeStoredPuzzleSnapshot(source) {
        if (!source) {
          return { puzzle: null, settings: null };
        }
        let data = source;
        if (typeof source === "string") {
          try {
            data = JSON.parse(source);
          } catch (error) {
            console.error("Failed to parse snapshot string", error);
            return { puzzle: null, settings: null };
          }
        } else if (
          typeof source === "object" &&
          source.__compressed === true &&
          typeof source.payload === "string"
        ) {
          const textPayload = decodeLegacySnapshotPayload(source);
          if (typeof textPayload !== "string") {
            return { puzzle: null, settings: null };
          }
          try {
            data = JSON.parse(textPayload);
          } catch (error) {
            console.error("Failed to parse legacy compressed snapshot", error);
            return { puzzle: null, settings: null };
          }
        }
        if (!data || typeof data !== "object") {
          return { puzzle: null, settings: null };
        }
        let settingsSource = null;
        if (data.settings && typeof data.settings === "object") {
          settingsSource = data.settings;
          data = { ...data };
          delete data.settings;
        }
        const puzzle = compactPuzzleSnapshot(data);
        const settings =
          settingsSource && typeof settingsSource === "object"
            ? getUserSettingsSnapshot(settingsSource)
            : null;
        return { puzzle, settings };
      }

      function encodeStoredSnapshot(snapshot) {
        const data = compactPuzzleSnapshot(snapshot);
        if (!data) return null;
        return data;
      }



      function encodeSaveStorageEntry(entry) {
        if (!entry || typeof entry !== "object") return null;
        const data = encodeStoredSnapshot(entry.data);
        if (!data) return null;
        const storageEntry = {
          id: entry.id,
          timestamp: entry.timestamp,
          data,
        };
        if (entry.settings && typeof entry.settings === "object") {
          storageEntry.settings = entry.settings;
        }
        if (typeof entry.title === "string" && entry.title.trim()) {
          storageEntry.title = entry.title.trim();
        }
        return storageEntry;
      }

      function decodeSaveStorageEntry(entry) {
        if (!entry || typeof entry !== "object") return null;
        const { puzzle, settings } = decodeStoredPuzzleSnapshot(entry.data ?? null);
        if (!puzzle) return null;
        const decoded = {
          id: entry.id,
          timestamp: entry.timestamp,
          data: puzzle,
        };
        if (settings && typeof settings === "object") {
          decoded.settings = settings;
        } else if (entry.settings && typeof entry.settings === "object") {
          const snapshot = getUserSettingsSnapshot(entry.settings);
          if (snapshot) {
            decoded.settings = snapshot;
          }
        }
        if (typeof entry.title === "string" && entry.title.trim()) {
          decoded.title = entry.title.trim();
        }
        return decoded;
      }

      function createGameSaveManager() {
        const key = SAVE_STORAGE_KEY;
        const subscribers = new Set();
        let cache = [];

        function notify(entries) {
          cache = entries;
          subscribers.forEach((listener) => {
            try {
              listener(cache.slice());
            } catch (error) {
              console.error("Save manager listener failed", error);
            }
          });
        }

        function normalizeEntry(entry) {
          if (!entry || typeof entry !== "object") return null;
          const decoded = decodeSaveStorageEntry(entry) || entry;
          const idRaw = decoded.id != null ? String(decoded.id) : "";
          const id = idRaw.trim();
          if (!id) return null;
          const data = compactPuzzleSnapshot(decoded.data);
          if (!data) return null;
          const normalized = {
            id,
            timestamp:
              typeof decoded.timestamp === "number" && Number.isFinite(decoded.timestamp)
                ? decoded.timestamp
                : Date.now(),
            data,
          };
          const settingsSource =
            decoded.settings && typeof decoded.settings === "object"
              ? decoded.settings
              : entry.settings && typeof entry.settings === "object"
              ? entry.settings
              : null;
          if (settingsSource && typeof settingsSource === "object") {
            const settingsSnapshot = getUserSettingsSnapshot(settingsSource);
            if (settingsSnapshot) {
              normalized.settings = settingsSnapshot;
            }
          }
          if (typeof decoded.title === "string" && decoded.title.trim()) {
            normalized.title = decoded.title.trim();
          } else if (typeof data.title === "string" && data.title) {
            normalized.title = data.title;
          }
          return normalized;
        }

        function readFromStorage() {
          try {
            const raw = localStorage.getItem(key);
            if (!raw) return [];
            const parsed = JSON.parse(raw);
            if (!Array.isArray(parsed)) return [];
            const normalized = [];
            for (const entry of parsed) {
              const result = normalizeEntry(entry);
              if (result) {
                normalized.push(result);
              }
            }
            return normalized;
          } catch (error) {
            console.error("Failed to load saves", error);
            return [];
          }
        }

        function writeToStorage(entries) {
          let serialized = "[]";
          let attemptedBytes = 0;
          try {
            const prepared = Array.isArray(entries)
              ? entries
                  .map((entry) => encodeSaveStorageEntry(entry))
                  .filter((entry) => entry && typeof entry === "object")
              : [];
            serialized = JSON.stringify(prepared);
            attemptedBytes = getStoredStringSize(serialized);
          } catch (error) {
            console.error("Failed to prepare saves for storage", error);
          }
          try {
            localStorage.setItem(key, serialized);
          } catch (error) {
            console.error("Failed to persist saves", error);
            if (error && error.name === "QuotaExceededError") {
              logDebug("Storage full: unable to write save snapshot. Delete old saves or exports and retry.");
              logStorageFailureDetails("manual", attemptedBytes);
            }
          }
        }

        function hydrate() {
          const entries = readFromStorage();
          writeToStorage(entries);
          notify(entries);
          return cache.slice();
        }

        function persist(entries) {
          if (!Array.isArray(entries)) {
            writeToStorage([]);
            notify([]);
            return [];
          }
          const normalized = [];
          for (const entry of entries) {
            const result = normalizeEntry(entry);
            if (result) {
              normalized.push(result);
            }
          }
          writeToStorage(normalized);
          notify(normalized);
          return cache.slice();
        }

        function list() {
          return cache.slice();
        }

        function clear() {
          try {
            localStorage.removeItem(key);
          } catch (error) {
            console.error("Failed to clear saves", error);
          }
          notify([]);
          return [];
        }

        function subscribe(listener) {
          if (typeof listener !== "function") return () => {};
          subscribers.add(listener);
          if (cache.length) {
            try {
              listener(cache.slice());
            } catch (error) {
              console.error("Save manager listener failed", error);
            }
          }
          return () => subscribers.delete(listener);
        }

        if (typeof window !== "undefined") {
          window.addEventListener("storage", (event) => {
            if (event.key === key) {
              const entries = readFromStorage();
              notify(entries);
            }
          });
        }

        const api = {
          hydrate,
          persist,
          list,
          clear,
          subscribe,
        };

        if (typeof window !== "undefined") {
          window.capyGameSaveManager = {
            hydrate: api.hydrate,
            persist: api.persist,
            list: api.list,
            clear: api.clear,
            subscribe: api.subscribe,
          };
        }

        return api;
      }

      function resetCurrentProgress() {
        if (!state.puzzle) return false;
        if (state.filled.size === 0) {
          logDebug("No filled regions yet; nothing to reset");
          return false;
        }
        state.filled = new Set();
        markFilledLayerDirty();
        renderPuzzle();
        renderPalette();
        refreshCustomCursorHighlight();
        updateProgress();
        updateCommandStates();
        scheduleAutosave("reset-progress", { immediate: true });
        logDebug("Reset puzzle progress to a blank canvas");
        return true;
      }

      function saveCurrentSnapshot() {
        const payload = serializeCurrentPuzzle();
        const settingsSnapshot = getUserSettingsSnapshot(state.settings);
        const resolvedTitle =
          (typeof payload?.title === "string" && payload.title.trim()) ||
          (typeof state.sourceTitle === "string" && state.sourceTitle.trim()) ||
          `Puzzle ${new Date().toLocaleTimeString()}`;
        if (payload && typeof payload === "object") {
          payload.title = resolvedTitle;
        }
        const now = Date.now();
        const activeSaveId = typeof state.loadedSaveId === "string" ? state.loadedSaveId : null;
        let entry = activeSaveId ? state.saves.find((item) => item.id === activeSaveId) : null;
        if (entry) {
          entry.title = resolvedTitle;
          entry.timestamp = now;
          entry.data = payload;
          if (settingsSnapshot) {
            entry.settings = settingsSnapshot;
          } else {
            delete entry.settings;
          }
          state.loadedSaveId = activeSaveId;
          state.saves = [entry, ...state.saves.filter((item) => item.id !== activeSaveId)];
          logDebug(`Updated save: ${entry.title}`);
        } else {
          const id = `save-${now}-${Math.floor(Math.random() * 10000)}`;
          entry = {
            id,
            title: resolvedTitle,
            timestamp: now,
            data: payload,
          };
          if (settingsSnapshot) {
            entry.settings = settingsSnapshot;
          }
          state.loadedSaveId = id;
          state.saves.unshift(entry);
          logDebug(`Saved snapshot: ${entry.title}`);
        }
        persistSaves();
        refreshSaveList();
      }

      function estimateSaveEntryBytes(entry) {
        try {
          const encoded = encodeSaveStorageEntry(entry);
          if (!encoded) return 0;
          return getStoredStringSize(JSON.stringify(encoded));
        } catch (error) {
          console.error("Failed to estimate save size", error);
          return 0;
        }
      }

      function describeSaveEntry(entry) {
        const titleSource =
          (typeof entry?.title === "string" && entry.title.trim()) ||
          (typeof entry?.data?.title === "string" && entry.data.title);
        const title = titleSource ? titleSource.trim() : "Untitled puzzle";
        const doneCount = entry?.data?.filled?.length ?? 0;
        const totalCount = entry?.data?.regions?.length ?? 0;
        const progressText = totalCount
          ? `${doneCount} of ${totalCount} regions filled`
          : `${doneCount} regions filled`;
        const timestampValue = Number(entry?.timestamp);
        const hasTimestamp = Number.isFinite(timestampValue) && timestampValue > 0;
        const timestamp = hasTimestamp ? new Date(timestampValue) : null;
        const timestampLabel = timestamp ? `Saved ${timestamp.toLocaleString()}` : "";
        const storageBytes = estimateSaveEntryBytes(entry);
        const storageLabel = storageBytes > 0 ? formatBytes(storageBytes) : "";
        const ariaLabelParts = [title, progressText];
        if (timestampLabel) {
          ariaLabelParts.push(timestampLabel);
        }
        if (storageLabel) {
          ariaLabelParts.push(`Storage ${storageLabel}`);
        }
        return {
          id: entry?.id,
          title,
          progressText,
          timestamp,
          timestampLabel,
          storageBytes,
          storageLabel,
          ariaLabel: ariaLabelParts.join(" – "),
        };
      }

      function createSaveActionButton(action, label) {
        const button = document.createElement("button");
        button.type = "button";
        button.dataset.action = action;
        button.textContent = label;
        return button;
      }

      function createSaveSelectionItem(entry) {
        const metadata = describeSaveEntry(entry);
        const item = document.createElement("li");
        item.className = "game-option";
        const button = document.createElement("button");
        button.type = "button";
        button.className = "game-option-button";
        button.dataset.gameId = metadata.id;
        const title = document.createElement("span");
        title.className = "game-option-title";
        title.textContent = metadata.title;
        const progress = document.createElement("span");
        progress.className = "game-option-meta";
        progress.textContent = metadata.progressText;
        button.append(title, progress);
        if (metadata.timestampLabel) {
          const time = document.createElement("span");
          time.className = "game-option-meta";
          time.textContent = metadata.timestampLabel;
          button.append(time);
        }
        if (metadata.storageLabel) {
          const storage = document.createElement("span");
          storage.className = "game-option-meta";
          storage.textContent = `Storage ${metadata.storageLabel}`;
          button.append(storage);
        }
        button.setAttribute("aria-label", metadata.ariaLabel);
        item.appendChild(button);
        return item;
      }

      function createSaveManagementItem(entry) {
        const metadata = describeSaveEntry(entry);
        const item = document.createElement("article");
        item.className = "save-entry";
        item.setAttribute("role", "listitem");
        item.dataset.saveId = metadata.id;
        const isLoaded = Boolean(state.loadedSaveId && metadata.id === state.loadedSaveId);
        if (isLoaded) {
          item.dataset.loaded = "true";
        }
        const header = document.createElement("header");
        const title = document.createElement("strong");
        title.textContent = metadata.title;
        header.appendChild(title);
        if (metadata.timestamp) {
          const time = document.createElement("time");
          time.dateTime = metadata.timestamp.toISOString();
          time.textContent = metadata.timestamp.toLocaleString();
          header.appendChild(time);
        }
        const meta = document.createElement("div");
        meta.className = "save-entry-meta";
        const progress = document.createElement("span");
        progress.textContent = metadata.progressText;
        meta.appendChild(progress);
        if (metadata.storageLabel) {
          const storage = document.createElement("span");
          storage.className = "save-entry-storage";
          storage.textContent = `Storage ${metadata.storageLabel}`;
          meta.appendChild(storage);
        }
        const actions = document.createElement("div");
        actions.className = "save-actions";
        actions.append(
          createSaveActionButton("load", "Load"),
          createSaveActionButton("rename", "Rename"),
          createSaveActionButton("export", "Export"),
          createSaveActionButton("delete", "Delete"),
        );
        item.append(header, meta, actions);
        if (isLoaded) {
          const status = document.createElement("div");
          status.className = "save-entry-status";
          status.textContent = "Autosaving this slot";
          item.appendChild(status);
        }
        return item;
      }




      function refreshGameSelection() {
        if (!gameSelectionList) return;
        gameSelectionList.innerHTML = "";
        const fragment = document.createDocumentFragment();

        const defaultItem = document.createElement("li");
        defaultItem.className = "game-option";
        const defaultButton = document.createElement("button");
        defaultButton.type = "button";
        defaultButton.className = "game-option-button";
        const defaultMetadata = state.defaultGame || {};
        defaultButton.dataset.gameId = defaultMetadata.id || DEFAULT_GAME_SOURCE.id;
        const defaultTitle = document.createElement("span");
        defaultTitle.className = "game-option-title";
        const resolvedTitle = getDefaultGameTitle();
        defaultTitle.textContent = resolvedTitle;
        const defaultMeta = document.createElement("span");
        defaultMeta.className = "game-option-meta";
        const resolvedDescription = getDefaultGameDescription();
        const fallbackMeta = DEFAULT_GAME_FALLBACK.description || DEFAULT_GAME_SOURCE.path;
        const metaText = resolvedDescription || fallbackMeta;
        defaultMeta.textContent = metaText;
        const hideMeta = !resolvedDescription && (!metaText || metaText === resolvedTitle);
        defaultMeta.hidden = hideMeta;
        const labelParts = [resolvedTitle];
        if (!hideMeta && metaText && metaText !== resolvedTitle) {
          labelParts.push(metaText);
        }
        defaultButton.setAttribute("aria-label", labelParts.join(" – "));
        defaultButton.append(defaultTitle, defaultMeta);
        defaultItem.appendChild(defaultButton);
        fragment.appendChild(defaultItem);

        const hasSaves = Array.isArray(state.saves) && state.saves.length > 0;
        if (hasSaves) {
          for (const entry of state.saves) {
            fragment.appendChild(createSaveSelectionItem(entry));
          }
        }

        gameSelectionList.appendChild(fragment);
        if (gameSelectionEmpty) {
          gameSelectionEmpty.hidden = hasSaves;
        }
      }

      function refreshSaveList() {
        const manualEntries = Array.isArray(state.saves) ? state.saves : [];
        const hasEntries = manualEntries.length > 0;
        for (const list of saveListContainers) {
          if (!list) continue;
          list.innerHTML = "";
          if (hasEntries) {
            const fragment = document.createDocumentFragment();
            for (const entry of manualEntries) {
              fragment.appendChild(createSaveManagementItem(entry));
            }
            list.appendChild(fragment);
          }
        }
        for (const emptyState of saveListEmptyStates) {
          if (!emptyState) continue;
          if (hasEntries) {
            emptyState.hidden = true;
          } else {
            emptyState.hidden = false;
            emptyState.textContent = "No saves yet. Create one above to start autosaving progress.";
          }
        }
        updateCommandStates();
        refreshGameSelection();
      }

      function persistSaves() {
        state.saves = gameSaveManager.persist(state.saves);
      }

      function loadSavedEntries() {
        return gameSaveManager.list();
      }

      function loadSaveEntry(id) {
        const entry = state.saves.find((item) => item.id === id);
        if (!entry) return;
        if (
          applyPuzzleResult(entry.data, {
            options: entry.data.options,
            activeColor: entry.data.activeColor,
            backgroundColor: entry.data.backgroundColor,
            stageBackgroundColor: entry.data.stageBackgroundColor,
            viewport: entry.data.viewport,
            settings: entry.settings ?? entry.data.settings,
            title: entry.title || entry.data.title,
            loadedSaveId: entry.id,
          })
        ) {
          state.sourceUrl = entry.data.sourceUrl ?? null;
          state.sourceTitle = entry.title || state.sourceTitle;
          state.loadedSaveId = entry.id;
          hideStartScreen();
          refreshSaveList();
          logDebug(`Loaded save: ${entry.title || "Untitled puzzle"}`);
        }
      }

      function deleteSaveEntry(id) {
        const entry = state.saves.find((item) => item.id === id);
        state.saves = state.saves.filter((item) => item.id !== id);
        if (state.loadedSaveId === id) {
          state.loadedSaveId = null;
        }
        persistSaves();
        refreshSaveList();
        logDebug(`Deleted save: ${(entry && entry.title) || id}`);
      }

      function clearAllSaveData() {
        gameSaveManager.clear();
        state.saves = [];
        state.loadedSaveId = null;
        refreshSaveList();
        try {
          localStorage.removeItem(LEGACY_AUTOSAVE_STORAGE_KEY);
        } catch (error) {
          console.error("Failed to clear legacy autosave", error);
        }
        updateStorageUsageSummary();
        logDebug("Cleared all saves");
      }

      function renameSaveEntry(id) {
        const entry = state.saves.find((item) => item.id === id);
        if (!entry) return;
        const next = prompt("Rename save", entry.title || "Untitled puzzle");
        if (typeof next === "string" && next.trim()) {
          entry.title = next.trim();
          entry.timestamp = Date.now();
          persistSaves();
          refreshSaveList();
          logDebug(`Renamed save to: ${entry.title}`);
        }
      }

      function exportSaveEntry(id) {
        const entry = state.saves.find((item) => item.id === id);
        if (!entry) return;
        const blob = new Blob([JSON.stringify(entry.data, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = `${entry.title || "capy-save"}.json`;
        document.body.appendChild(link);
        link.click();
        requestAnimationFrame(() => {
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        });
        logDebug(`Exported save: ${entry.title || "capy-save"}`);
      }

      function sanitizeHexColor(value, fallback = DEFAULT_BACKGROUND_HEX) {
        if (typeof value !== "string") return fallback;
        const trimmed = value.trim();
        if (/^#[0-9a-fA-F]{6}$/.test(trimmed)) {
          return `#${trimmed.slice(1).toLowerCase()}`;
        }
        if (/^[0-9a-fA-F]{6}$/.test(trimmed)) {
          return `#${trimmed.toLowerCase()}`;
        }
        return fallback;
      }

      function computeInkStyles(hex) {
        const [r, g, b] = hexToRgb(hex);
        const luminance = relativeLuminance([r, g, b]);
        if (luminance < 0.45) {
          return {
            outline: "rgba(248, 250, 252, 0.75)",
            number: "rgba(248, 250, 252, 0.95)",
          };
        }
        return {
          outline: "rgba(15, 23, 42, 0.65)",
          number: "rgba(15, 23, 42, 0.95)",
        };
      }

      function computePointerNumberColor(hex) {
        if (typeof hex !== "string") {
          return null;
        }
        const sanitizedHex = sanitizeHexColor(hex, DEFAULT_BACKGROUND_HEX);
        const [r, g, b] = hexToRgb(sanitizedHex);
        const tooltipBackgroundLuminance = relativeLuminance([248, 250, 252]);
        const numberLuminance = relativeLuminance([r, g, b]);
        const contrast = contrastRatio(tooltipBackgroundLuminance, numberLuminance);
        const MIN_POINTER_TOOLTIP_CONTRAST = 4.5;
        if (contrast >= MIN_POINTER_TOOLTIP_CONTRAST) {
          return sanitizedHex;
        }
        return null;
      }

      function computeSwatchLabelStyles(hex) {
        const darkLabel = {
          styles: {
            color: "rgba(15, 23, 42, 0.92)",
            outline: "rgba(15, 23, 42, 0.55)",
            shadow: [
              "0 0 1px rgba(248, 250, 252, 0.85)",
              "0 0 3px rgba(248, 250, 252, 0.6)",
              "0 0 6px rgba(248, 250, 252, 0.5)",
            ].join(", "),
          },
          luminance: relativeLuminance([15, 23, 42]),
        };
        const lightLabel = {
          styles: {
            color: "rgba(248, 250, 252, 0.98)",
            outline: "rgba(248, 250, 252, 0.55)",
            shadow: [
              "0 0 1px rgba(15, 23, 42, 0.82)",
              "0 0 3px rgba(15, 23, 42, 0.65)",
              "0 0 6px rgba(15, 23, 42, 0.5)",
            ].join(", "),
          },
          luminance: relativeLuminance([248, 250, 252]),
        };

        const sanitizedHex = sanitizeHexColor(hex, DEFAULT_BACKGROUND_HEX);
        const [r, g, b] = hexToRgb(sanitizedHex);
        const backgroundLuminance = relativeLuminance([r, g, b]);
        if (!Number.isFinite(backgroundLuminance)) {
          return darkLabel.styles;
        }

        const isBackgroundDark = backgroundLuminance <= 0.45;
        const [preferredLabel, alternateLabel] = isBackgroundDark
          ? [lightLabel, darkLabel]
          : [darkLabel, lightLabel];

        const preferredContrast = contrastRatio(
          backgroundLuminance,
          preferredLabel.luminance
        );
        const alternateContrast = contrastRatio(
          backgroundLuminance,
          alternateLabel.luminance
        );

        if (alternateContrast > preferredContrast) {
          return alternateLabel.styles;
        }

        return preferredLabel.styles;
      }

      function relativeLuminance([r, g, b]) {
        const toLinear = (channel) => {
          const value = channel / 255;
          return value <= 0.03928 ? value / 12.92 : Math.pow((value + 0.055) / 1.055, 2.4);
        };
        const linearR = toLinear(r);
        const linearG = toLinear(g);
        const linearB = toLinear(b);
        return 0.2126 * linearR + 0.7152 * linearG + 0.0722 * linearB;
      }

      function contrastRatio(l1, l2) {
        const lighter = Math.max(l1, l2);
        const darker = Math.min(l1, l2);
        return (lighter + 0.05) / (darker + 0.05);
      }

      function oklchFromHex(hex) {
        const [r, g, b] = hexToRgb(hex);
        const { l, a, b: bb } = oklabFromRgb([r, g, b]);
        const chroma = Math.sqrt(a * a + bb * bb);
        const hueRaw = Math.atan2(bb, a) * (180 / Math.PI);
        const hue = Number.isFinite(hueRaw) ? (hueRaw + 360) % 360 : 0;
        const lightness = clamp(Number.isFinite(l) ? l : 0, 0, 1);
        const safeChroma = Number.isFinite(chroma) && chroma > 0 ? chroma : 0;
        return {
          lightness,
          chroma: safeChroma,
          hue,
        };
      }

      function oklabFromRgb([r, g, b]) {
        const linearize = (channel) => {
          const normalized = channel / 255;
          if (normalized <= 0.04045) {
            return normalized / 12.92;
          }
          return Math.pow((normalized + 0.055) / 1.055, 2.4);
        };
        const lr = linearize(r);
        const lg = linearize(g);
        const lb = linearize(b);
        const l = 0.4122214708 * lr + 0.5363325363 * lg + 0.0514459929 * lb;
        const m = 0.2119034982 * lr + 0.6806995451 * lg + 0.1073969566 * lb;
        const s = 0.0883024619 * lr + 0.2817188376 * lg + 0.6299787005 * lb;
        const lRoot = Math.cbrt(l);
        const mRoot = Math.cbrt(m);
        const sRoot = Math.cbrt(s);
        const L = 0.2104542553 * lRoot + 0.793617785 * mRoot - 0.0040720468 * sRoot;
        const A = 1.9779984951 * lRoot - 2.428592205 * mRoot + 0.4505937099 * sRoot;
        const B = 0.0259040371 * lRoot + 0.7827717662 * mRoot - 0.808675766 * sRoot;
        return {
          l: Number.isFinite(L) ? L : 0,
          a: Number.isFinite(A) ? A : 0,
          b: Number.isFinite(B) ? B : 0,
        };
      }

      function hexToRgb(hex) {
        if (typeof hex !== "string") return [255, 255, 255];
        const normalized = hex.replace("#", "").trim();
        if (normalized.length !== 6) {
          return [255, 255, 255];
        }
        const r = parseInt(normalized.slice(0, 2), 16);
        const g = parseInt(normalized.slice(2, 4), 16);
        const b = parseInt(normalized.slice(4, 6), 16);
        return [r, g, b];
      }

      function rgbaFromHex(hex, alpha = 1) {
        const [r, g, b] = hexToRgb(hex);
        const normalized = clamp(alpha, 0, 1);
        return `rgba(${r}, ${g}, ${b}, ${normalized})`;
      }

      function clamp(value, min, max) {
        if (Number.isNaN(value)) return min;
        if (value < min) return min;
        if (value > max) return max;
        return value;
      }

    </script>
  </body>
</html>
